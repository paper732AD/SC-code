// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flat.proto

#include "flat.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace test {
PROTOBUF_CONSTEXPR FixedUUIDInfoPB::FixedUUIDInfoPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.low_)*/uint64_t{0u}
  , /*decltype(_impl_.high_)*/uint64_t{0u}} {}
struct FixedUUIDInfoPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FixedUUIDInfoPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FixedUUIDInfoPBDefaultTypeInternal() {}
  union {
    FixedUUIDInfoPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FixedUUIDInfoPBDefaultTypeInternal _FixedUUIDInfoPB_default_instance_;
PROTOBUF_CONSTEXPR MirrorArgsPB::MirrorArgsPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.copy_)*/0
  , /*decltype(_impl_.ftt_)*/0} {}
struct MirrorArgsPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MirrorArgsPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MirrorArgsPBDefaultTypeInternal() {}
  union {
    MirrorArgsPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MirrorArgsPBDefaultTypeInternal _MirrorArgsPB_default_instance_;
PROTOBUF_CONSTEXPR ChunkOptionsPB::ChunkOptionsPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.placement_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mirror_)*/nullptr
  , /*decltype(_impl_.ftttype_)*/0} {}
struct ChunkOptionsPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkOptionsPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkOptionsPBDefaultTypeInternal() {}
  union {
    ChunkOptionsPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkOptionsPBDefaultTypeInternal _ChunkOptionsPB_default_instance_;
PROTOBUF_CONSTEXPR ReplicaLocationPB::ReplicaLocationPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cslocation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.disklocation_)*/0
  , /*decltype(_impl_.disktype_)*/0u} {}
struct ReplicaLocationPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplicaLocationPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplicaLocationPBDefaultTypeInternal() {}
  union {
    ReplicaLocationPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplicaLocationPBDefaultTypeInternal _ReplicaLocationPB_default_instance_;
PROTOBUF_CONSTEXPR AccelerateOpenOptionsPB::AccelerateOpenOptionsPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chunklocation_)*/{}
  , /*decltype(_impl_.chunkoptions_)*/nullptr
  , /*decltype(_impl_.chunksizeexponent_)*/0u
  , /*decltype(_impl_.checksumcategory_)*/0u} {}
struct AccelerateOpenOptionsPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccelerateOpenOptionsPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccelerateOpenOptionsPBDefaultTypeInternal() {}
  union {
    AccelerateOpenOptionsPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccelerateOpenOptionsPBDefaultTypeInternal _AccelerateOpenOptionsPB_default_instance_;
PROTOBUF_CONSTEXPR IONicePB::IONicePB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.priority_)*/0
  , /*decltype(_impl_.ioclass_)*/0} {}
struct IONicePBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IONicePBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IONicePBDefaultTypeInternal() {}
  union {
    IONicePB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IONicePBDefaultTypeInternal _IONicePB_default_instance_;
PROTOBUF_CONSTEXPR CsChooseDiskStrategyCJPB::CsChooseDiskStrategyCJPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.strategies_)*/{}
  , /*decltype(_impl_.diskstoragetype_)*/0
  , /*decltype(_impl_.targetstoragetype_)*/0} {}
struct CsChooseDiskStrategyCJPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CsChooseDiskStrategyCJPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CsChooseDiskStrategyCJPBDefaultTypeInternal() {}
  union {
    CsChooseDiskStrategyCJPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CsChooseDiskStrategyCJPBDefaultTypeInternal _CsChooseDiskStrategyCJPB_default_instance_;
PROTOBUF_CONSTEXPR ChunkOrStreamIdInfoPB::ChunkOrStreamIdInfoPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uuid_)*/nullptr
  , /*decltype(_impl_.partition_index_)*/0u
  , /*decltype(_impl_.padding_)*/0u} {}
struct ChunkOrStreamIdInfoPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkOrStreamIdInfoPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkOrStreamIdInfoPBDefaultTypeInternal() {}
  union {
    ChunkOrStreamIdInfoPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkOrStreamIdInfoPBDefaultTypeInternal _ChunkOrStreamIdInfoPB_default_instance_;
PROTOBUF_CONSTEXPR QosOptionsPB::QosOptionsPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.serviceid_)*/0u
  , /*decltype(_impl_.flowid_)*/0u
  , /*decltype(_impl_.adjust_)*/0
  , /*decltype(_impl_.cachegroupid_)*/0u
  , /*decltype(_impl_.networkpriority_)*/0} {}
struct QosOptionsPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QosOptionsPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QosOptionsPBDefaultTypeInternal() {}
  union {
    QosOptionsPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QosOptionsPBDefaultTypeInternal _QosOptionsPB_default_instance_;
PROTOBUF_CONSTEXPR FlushChecksumPB::FlushChecksumPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/int64_t{0}
  , /*decltype(_impl_.category_)*/0u} {}
struct FlushChecksumPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlushChecksumPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlushChecksumPBDefaultTypeInternal() {}
  union {
    FlushChecksumPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlushChecksumPBDefaultTypeInternal _FlushChecksumPB_default_instance_;
PROTOBUF_CONSTEXPR UUIDInfoPB::UUIDInfoPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.low_)*/uint64_t{0u}
  , /*decltype(_impl_.high_)*/uint64_t{0u}} {}
struct UUIDInfoPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UUIDInfoPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UUIDInfoPBDefaultTypeInternal() {}
  union {
    UUIDInfoPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UUIDInfoPBDefaultTypeInternal _UUIDInfoPB_default_instance_;
PROTOBUF_CONSTEXPR RootServerIdPB::RootServerIdPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uuid_)*/nullptr
  , /*decltype(_impl_.leader_term_)*/int64_t{0}} {}
struct RootServerIdPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RootServerIdPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RootServerIdPBDefaultTypeInternal() {}
  union {
    RootServerIdPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RootServerIdPBDefaultTypeInternal _RootServerIdPB_default_instance_;
PROTOBUF_CONSTEXPR ChunkIdTypeCJPB::ChunkIdTypeCJPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.belongedfileid_)*/uint64_t{0u}
  , /*decltype(_impl_.chunkindex_)*/0u
  , /*decltype(_impl_.padding_)*/0u} {}
struct ChunkIdTypeCJPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkIdTypeCJPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkIdTypeCJPBDefaultTypeInternal() {}
  union {
    ChunkIdTypeCJPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkIdTypeCJPBDefaultTypeInternal _ChunkIdTypeCJPB_default_instance_;
PROTOBUF_CONSTEXPR PanguTraceSpanInfo::PanguTraceSpanInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.traceidlow_)*/uint64_t{0u}
  , /*decltype(_impl_.traceidhigh_)*/uint64_t{0u}
  , /*decltype(_impl_.spanid_)*/uint64_t{0u}} {}
struct PanguTraceSpanInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PanguTraceSpanInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PanguTraceSpanInfoDefaultTypeInternal() {}
  union {
    PanguTraceSpanInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PanguTraceSpanInfoDefaultTypeInternal _PanguTraceSpanInfo_default_instance_;
PROTOBUF_CONSTEXPR CsChooseDiskStrategySingleCJPB::CsChooseDiskStrategySingleCJPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.method_)*/0u
  , /*decltype(_impl_.weight_)*/0u
  , /*decltype(_impl_.parameter_)*/uint64_t{0u}} {}
struct CsChooseDiskStrategySingleCJPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CsChooseDiskStrategySingleCJPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CsChooseDiskStrategySingleCJPBDefaultTypeInternal() {}
  union {
    CsChooseDiskStrategySingleCJPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CsChooseDiskStrategySingleCJPBDefaultTypeInternal _CsChooseDiskStrategySingleCJPB_default_instance_;
PROTOBUF_CONSTEXPR FlatLogFileFlushChunkRequestPB::FlatLogFileFlushChunkRequestPB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.userid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.chunkid_)*/nullptr
  , /*decltype(_impl_.ionice_)*/nullptr
  , /*decltype(_impl_.openchunkoptions_)*/nullptr
  , /*decltype(_impl_.trace_span_)*/nullptr
  , /*decltype(_impl_.strategy_)*/nullptr
  , /*decltype(_impl_.chunkidv2_)*/nullptr
  , /*decltype(_impl_.qosoptions_)*/nullptr
  , /*decltype(_impl_.checksum_)*/nullptr
  , /*decltype(_impl_.volumeuuid_)*/nullptr
  , /*decltype(_impl_.root_server_id_)*/nullptr
  , /*decltype(_impl_.offset_)*/0u
  , /*decltype(_impl_.length_)*/0u
  , /*decltype(_impl_.storageid_)*/0u
  , /*decltype(_impl_.hint_)*/0u
  , /*decltype(_impl_.isreplication_)*/false
  , /*decltype(_impl_.trace_open_)*/false
  , /*decltype(_impl_.createifnotexists_)*/false
  , /*decltype(_impl_.openmode_)*/0
  , /*decltype(_impl_.handle_)*/int64_t{0}
  , /*decltype(_impl_.moduleversion_)*/0u
  , /*decltype(_impl_.diskid_)*/0u
  , /*decltype(_impl_.requestid_)*/uint64_t{0u}
  , /*decltype(_impl_.requiredmincsversion_)*/0u
  , /*decltype(_impl_.fromtype_)*/0
  , /*decltype(_impl_.offset64_)*/uint64_t{0u}
  , /*decltype(_impl_.recordsize_)*/0u
  , /*decltype(_impl_.poolid_)*/0u
  , /*decltype(_impl_.storagepoolconfversion_)*/uint64_t{0u}
  , /*decltype(_impl_.a_)*/0
  , /*decltype(_impl_.datasync_)*/true} {}
struct FlatLogFileFlushChunkRequestPBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlatLogFileFlushChunkRequestPBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlatLogFileFlushChunkRequestPBDefaultTypeInternal() {}
  union {
    FlatLogFileFlushChunkRequestPB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlatLogFileFlushChunkRequestPBDefaultTypeInternal _FlatLogFileFlushChunkRequestPB_default_instance_;
PROTOBUF_CONSTEXPR FlatLogFileFlushChunkResponsePB::FlatLogFileFlushChunkResponsePB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trace_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.errorcode_)*/0
  , /*decltype(_impl_.chunkstatus_)*/0u
  , /*decltype(_impl_.hint_)*/0u
  , /*decltype(_impl_.acklength_)*/0u
  , /*decltype(_impl_.trace_type_)*/0u
  , /*decltype(_impl_.storageid_)*/0u
  , /*decltype(_impl_.handle_)*/int64_t{0}
  , /*decltype(_impl_.requestid_)*/uint64_t{0u}
  , /*decltype(_impl_.checksum_)*/int64_t{0}
  , /*decltype(_impl_.diskid_)*/0u
  , /*decltype(_impl_.a_)*/0
  , /*decltype(_impl_.leftreplicasize_)*/uint64_t{0u}} {}
struct FlatLogFileFlushChunkResponsePBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlatLogFileFlushChunkResponsePBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlatLogFileFlushChunkResponsePBDefaultTypeInternal() {}
  union {
    FlatLogFileFlushChunkResponsePB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlatLogFileFlushChunkResponsePBDefaultTypeInternal _FlatLogFileFlushChunkResponsePB_default_instance_;
}  // namespace test
static ::_pb::Metadata file_level_metadata_flat_2eproto[17];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_flat_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_flat_2eproto = nullptr;

const uint32_t TableStruct_flat_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::test::FixedUUIDInfoPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::FixedUUIDInfoPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::FixedUUIDInfoPB, _impl_.low_),
  PROTOBUF_FIELD_OFFSET(::test::FixedUUIDInfoPB, _impl_.high_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::test::MirrorArgsPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::MirrorArgsPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::MirrorArgsPB, _impl_.copy_),
  PROTOBUF_FIELD_OFFSET(::test::MirrorArgsPB, _impl_.ftt_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::test::ChunkOptionsPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkOptionsPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::ChunkOptionsPB, _impl_.ftttype_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkOptionsPB, _impl_.mirror_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkOptionsPB, _impl_.placement_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::test::ReplicaLocationPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::ReplicaLocationPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::ReplicaLocationPB, _impl_.cslocation_),
  PROTOBUF_FIELD_OFFSET(::test::ReplicaLocationPB, _impl_.disklocation_),
  PROTOBUF_FIELD_OFFSET(::test::ReplicaLocationPB, _impl_.disktype_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::test::AccelerateOpenOptionsPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::AccelerateOpenOptionsPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::AccelerateOpenOptionsPB, _impl_.chunkoptions_),
  PROTOBUF_FIELD_OFFSET(::test::AccelerateOpenOptionsPB, _impl_.chunklocation_),
  PROTOBUF_FIELD_OFFSET(::test::AccelerateOpenOptionsPB, _impl_.chunksizeexponent_),
  PROTOBUF_FIELD_OFFSET(::test::AccelerateOpenOptionsPB, _impl_.checksumcategory_),
  0,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::test::IONicePB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::IONicePB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::IONicePB, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::test::IONicePB, _impl_.ioclass_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategyCJPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategyCJPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategyCJPB, _impl_.strategies_),
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategyCJPB, _impl_.diskstoragetype_),
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategyCJPB, _impl_.targetstoragetype_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::test::ChunkOrStreamIdInfoPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkOrStreamIdInfoPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::ChunkOrStreamIdInfoPB, _impl_.uuid_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkOrStreamIdInfoPB, _impl_.partition_index_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkOrStreamIdInfoPB, _impl_.padding_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::test::QosOptionsPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::QosOptionsPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::QosOptionsPB, _impl_.serviceid_),
  PROTOBUF_FIELD_OFFSET(::test::QosOptionsPB, _impl_.flowid_),
  PROTOBUF_FIELD_OFFSET(::test::QosOptionsPB, _impl_.adjust_),
  PROTOBUF_FIELD_OFFSET(::test::QosOptionsPB, _impl_.cachegroupid_),
  PROTOBUF_FIELD_OFFSET(::test::QosOptionsPB, _impl_.networkpriority_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::test::FlushChecksumPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::FlushChecksumPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::FlushChecksumPB, _impl_.category_),
  PROTOBUF_FIELD_OFFSET(::test::FlushChecksumPB, _impl_.value_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::test::UUIDInfoPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::UUIDInfoPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::UUIDInfoPB, _impl_.low_),
  PROTOBUF_FIELD_OFFSET(::test::UUIDInfoPB, _impl_.high_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::test::RootServerIdPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::RootServerIdPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::RootServerIdPB, _impl_.uuid_),
  PROTOBUF_FIELD_OFFSET(::test::RootServerIdPB, _impl_.leader_term_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::test::ChunkIdTypeCJPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkIdTypeCJPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::ChunkIdTypeCJPB, _impl_.belongedfileid_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkIdTypeCJPB, _impl_.chunkindex_),
  PROTOBUF_FIELD_OFFSET(::test::ChunkIdTypeCJPB, _impl_.padding_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::test::PanguTraceSpanInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::PanguTraceSpanInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::PanguTraceSpanInfo, _impl_.traceidlow_),
  PROTOBUF_FIELD_OFFSET(::test::PanguTraceSpanInfo, _impl_.traceidhigh_),
  PROTOBUF_FIELD_OFFSET(::test::PanguTraceSpanInfo, _impl_.spanid_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategySingleCJPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategySingleCJPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategySingleCJPB, _impl_.method_),
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategySingleCJPB, _impl_.weight_),
  PROTOBUF_FIELD_OFFSET(::test::CsChooseDiskStrategySingleCJPB, _impl_.parameter_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.chunkid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.storageid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.hint_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.isreplication_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.trace_open_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.ionice_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.openchunkoptions_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.openmode_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.datasync_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.trace_span_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.createifnotexists_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.strategy_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.chunkidv2_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.qosoptions_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.checksum_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.volumeuuid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.moduleversion_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.hostname_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.diskid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.requestid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.userid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.root_server_id_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.requiredmincsversion_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.fromtype_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.offset64_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.recordsize_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.poolid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.storagepoolconfversion_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkRequestPB, _impl_.a_),
  3,
  13,
  14,
  15,
  0,
  16,
  17,
  18,
  4,
  5,
  20,
  21,
  32,
  6,
  19,
  7,
  8,
  9,
  10,
  11,
  22,
  1,
  23,
  24,
  2,
  12,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.errorcode_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.chunkstatus_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.hint_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.acklength_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.trace_type_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.trace_data_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.storageid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.diskid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.requestid_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.checksum_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.leftreplicasize_),
  PROTOBUF_FIELD_OFFSET(::test::FlatLogFileFlushChunkResponsePB, _impl_.a_),
  1,
  2,
  3,
  4,
  5,
  0,
  7,
  6,
  10,
  8,
  9,
  12,
  11,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::test::FixedUUIDInfoPB)},
  { 10, 18, -1, sizeof(::test::MirrorArgsPB)},
  { 20, 29, -1, sizeof(::test::ChunkOptionsPB)},
  { 32, 41, -1, sizeof(::test::ReplicaLocationPB)},
  { 44, 54, -1, sizeof(::test::AccelerateOpenOptionsPB)},
  { 58, 66, -1, sizeof(::test::IONicePB)},
  { 68, 77, -1, sizeof(::test::CsChooseDiskStrategyCJPB)},
  { 80, 89, -1, sizeof(::test::ChunkOrStreamIdInfoPB)},
  { 92, 103, -1, sizeof(::test::QosOptionsPB)},
  { 108, 116, -1, sizeof(::test::FlushChecksumPB)},
  { 118, 126, -1, sizeof(::test::UUIDInfoPB)},
  { 128, 136, -1, sizeof(::test::RootServerIdPB)},
  { 138, 147, -1, sizeof(::test::ChunkIdTypeCJPB)},
  { 150, 159, -1, sizeof(::test::PanguTraceSpanInfo)},
  { 162, 171, -1, sizeof(::test::CsChooseDiskStrategySingleCJPB)},
  { 174, 213, -1, sizeof(::test::FlatLogFileFlushChunkRequestPB)},
  { 246, 265, -1, sizeof(::test::FlatLogFileFlushChunkResponsePB)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::test::_FixedUUIDInfoPB_default_instance_._instance,
  &::test::_MirrorArgsPB_default_instance_._instance,
  &::test::_ChunkOptionsPB_default_instance_._instance,
  &::test::_ReplicaLocationPB_default_instance_._instance,
  &::test::_AccelerateOpenOptionsPB_default_instance_._instance,
  &::test::_IONicePB_default_instance_._instance,
  &::test::_CsChooseDiskStrategyCJPB_default_instance_._instance,
  &::test::_ChunkOrStreamIdInfoPB_default_instance_._instance,
  &::test::_QosOptionsPB_default_instance_._instance,
  &::test::_FlushChecksumPB_default_instance_._instance,
  &::test::_UUIDInfoPB_default_instance_._instance,
  &::test::_RootServerIdPB_default_instance_._instance,
  &::test::_ChunkIdTypeCJPB_default_instance_._instance,
  &::test::_PanguTraceSpanInfo_default_instance_._instance,
  &::test::_CsChooseDiskStrategySingleCJPB_default_instance_._instance,
  &::test::_FlatLogFileFlushChunkRequestPB_default_instance_._instance,
  &::test::_FlatLogFileFlushChunkResponsePB_default_instance_._instance,
};

const char descriptor_table_protodef_flat_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\nflat.proto\022\004test\",\n\017FixedUUIDInfoPB\022\013\n"
  "\003low\030\001 \001(\006\022\014\n\004high\030\002 \001(\006\")\n\014MirrorArgsPB"
  "\022\014\n\004Copy\030\001 \001(\005\022\013\n\003FTT\030\002 \001(\005\"X\n\016ChunkOpti"
  "onsPB\022\017\n\007FTTType\030\001 \001(\005\022\"\n\006Mirror\030\002 \001(\0132\022"
  ".test.MirrorArgsPB\022\021\n\tPlacement\030\003 \001(\014\"O\n"
  "\021ReplicaLocationPB\022\022\n\nCSLocation\030\001 \001(\014\022\024"
  "\n\014diskLocation\030\002 \001(\005\022\020\n\010diskType\030\003 \001(\r\"\252"
  "\001\n\027AccelerateOpenOptionsPB\022*\n\014ChunkOptio"
  "ns\030\001 \001(\0132\024.test.ChunkOptionsPB\022.\n\rChunkL"
  "ocation\030\002 \003(\0132\027.test.ReplicaLocationPB\022\031"
  "\n\021chunkSizeExponent\030\003 \001(\r\022\030\n\020checksumCat"
  "egory\030\004 \001(\r\"-\n\010IONicePB\022\020\n\010Priority\030\001 \001("
  "\005\022\017\n\007IOClass\030\002 \001(\005\"\210\001\n\030CsChooseDiskStrat"
  "egyCJPB\0228\n\nStrategies\030\001 \003(\0132$.test.CsCho"
  "oseDiskStrategySingleCJPB\022\027\n\017DiskStorage"
  "Type\030\002 \001(\005\022\031\n\021TargetStorageType\030\003 \001(\005\"a\n"
  "\025ChunkOrStreamIdInfoPB\022\036\n\004uuid\030\001 \001(\0132\020.t"
  "est.UUIDInfoPB\022\027\n\017partition_index\030\002 \001(\r\022"
  "\017\n\007padding\030\003 \001(\r\"\226\002\n\014QosOptionsPB\022\021\n\tser"
  "viceId\030\001 \001(\r\022\016\n\006flowId\030\002 \001(\r\022\016\n\006adjust\030\003"
  " \001(\005\022\027\n\014cacheGroupId\030\004 \001(\r:\0010\022\027\n\017network"
  "Priority\030\005 \001(\005\"6\n\nAdjustType\022\010\n\004KEEP\020\000\022\022"
  "\n\005LOWER\020\377\377\377\377\377\377\377\377\377\001\022\n\n\006HIGHER\020\001\"i\n\016CacheG"
  "roupType\022\025\n\010NO_CACHE\020\377\377\377\377\377\377\377\377\377\001\022\013\n\007DEFAU"
  "LT\020\000\022\014\n\010INTERNAL\020\001\022\r\n\tUSER_BASE\020d\022\n\n\006USE"
  "R_0\020e\022\n\n\006USER_1\020f\"2\n\017FlushChecksumPB\022\020\n\010"
  "category\030\001 \001(\r\022\r\n\005value\030\002 \001(\003\"\'\n\nUUIDInf"
  "oPB\022\013\n\003low\030\001 \001(\004\022\014\n\004high\030\002 \001(\004\"E\n\016RootSe"
  "rverIdPB\022\036\n\004uuid\030\001 \001(\0132\020.test.UUIDInfoPB"
  "\022\023\n\013leader_term\030\002 \001(\003\"Q\n\017ChunkIdTypeCJPB"
  "\022\026\n\016BelongedFileId\030\001 \001(\004\022\022\n\nChunkIndex\030\002"
  " \001(\r\022\022\n\007Padding\030\003 \001(\r:\0010\"M\n\022PanguTraceSp"
  "anInfo\022\022\n\nTraceIdLow\030\001 \001(\004\022\023\n\013TraceIdHig"
  "h\030\002 \001(\004\022\016\n\006SpanId\030\003 \001(\004\"V\n\036CsChooseDiskS"
  "trategySingleCJPB\022\016\n\006Method\030\001 \001(\r\022\016\n\006Wei"
  "ght\030\002 \001(\r\022\024\n\tParameter\030\003 \001(\004:\0010\"\240\007\n\036Flat"
  "LogFileFlushChunkRequestPB\022&\n\007ChunkId\030\001 "
  "\001(\0132\025.test.ChunkIdTypeCJPB\022\016\n\006Offset\030\002 \001"
  "(\r\022\016\n\006Length\030\003 \001(\r\022\021\n\tStorageId\030\004 \001(\r\022\014\n"
  "\004Data\030\005 \001(\014\022\014\n\004Hint\030\006 \001(\r\022\034\n\rIsReplicati"
  "on\030\007 \001(\010:\005false\022\031\n\ntrace_open\030\010 \001(\010:\005fal"
  "se\022\036\n\006IONice\030\t \001(\0132\016.test.IONicePB\0227\n\020Op"
  "enChunkOptions\030\n \001(\0132\035.test.AccelerateOp"
  "enOptionsPB\022\020\n\010OpenMode\030\013 \001(\005\022\016\n\006Handle\030"
  "\014 \001(\003\022\026\n\010DataSync\030\r \001(\010:\004true\022,\n\ntrace_s"
  "pan\030\016 \001(\0132\030.test.PanguTraceSpanInfo\022\031\n\021C"
  "reateIfNotExists\030\017 \001(\010\0220\n\010Strategy\030\020 \001(\013"
  "2\036.test.CsChooseDiskStrategyCJPB\022.\n\tChun"
  "kIdV2\030\021 \001(\0132\033.test.ChunkOrStreamIdInfoPB"
  "\022&\n\nqosOptions\030\022 \001(\0132\022.test.QosOptionsPB"
  "\022\'\n\010Checksum\030\023 \001(\0132\025.test.FlushChecksumP"
  "B\022$\n\nvolumeUUID\030\024 \001(\0132\020.test.UUIDInfoPB\022"
  "\025\n\rModuleVersion\030\025 \001(\r\022\020\n\010HostName\030\026 \001(\014"
  "\022\016\n\006DiskId\030\027 \001(\r\022\021\n\tRequestId\030\030 \001(\004\022\016\n\006U"
  "serId\030\031 \001(\014\022,\n\016root_server_id\030\032 \001(\0132\024.te"
  "st.RootServerIdPB\022\034\n\024RequiredMinCSVersio"
  "n\030\033 \001(\r\022\020\n\010FromType\030\034 \001(\005\022\020\n\010Offset64\030\035 "
  "\001(\004\022\022\n\nRecordSize\030\036 \001(\r\022\016\n\006PoolId\030\037 \001(\r\022"
  "\036\n\026StoragePoolConfVersion\030  \001(\004\022\t\n\001a\030! \001"
  "(\005\"\221\002\n\037FlatLogFileFlushChunkResponsePB\022\021"
  "\n\tErrorcode\030\001 \001(\005\022\026\n\013ChunkStatus\030\002 \001(\r:\001"
  "0\022\014\n\004Hint\030\003 \001(\r\022\021\n\tAckLength\030\004 \001(\r\022\022\n\ntr"
  "ace_type\030\005 \001(\r\022\022\n\ntrace_data\030\006 \001(\014\022\016\n\006Ha"
  "ndle\030\007 \001(\003\022\021\n\tStorageId\030\010 \001(\r\022\016\n\006DiskId\030"
  "\t \001(\r\022\021\n\tRequestId\030\n \001(\004\022\020\n\010Checksum\030\013 \001"
  "(\003\022\027\n\017LeftReplicaSize\030\014 \001(\004\022\t\n\001a\030\r \001(\0052]"
  "\n\004Test\022U\n\004Echo\022$.test.FlatLogFileFlushCh"
  "unkRequestPB\032%.test.FlatLogFileFlushChun"
  "kResponsePB\"\000"
  ;
static ::_pbi::once_flag descriptor_table_flat_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_flat_2eproto = {
    false, false, 2733, descriptor_table_protodef_flat_2eproto,
    "flat.proto",
    &descriptor_table_flat_2eproto_once, nullptr, 0, 17,
    schemas, file_default_instances, TableStruct_flat_2eproto::offsets,
    file_level_metadata_flat_2eproto, file_level_enum_descriptors_flat_2eproto,
    file_level_service_descriptors_flat_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_flat_2eproto_getter() {
  return &descriptor_table_flat_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_flat_2eproto(&descriptor_table_flat_2eproto);
namespace test {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QosOptionsPB_AdjustType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_flat_2eproto);
  return file_level_enum_descriptors_flat_2eproto[0];
}
bool QosOptionsPB_AdjustType_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr QosOptionsPB_AdjustType QosOptionsPB::KEEP;
constexpr QosOptionsPB_AdjustType QosOptionsPB::LOWER;
constexpr QosOptionsPB_AdjustType QosOptionsPB::HIGHER;
constexpr QosOptionsPB_AdjustType QosOptionsPB::AdjustType_MIN;
constexpr QosOptionsPB_AdjustType QosOptionsPB::AdjustType_MAX;
constexpr int QosOptionsPB::AdjustType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QosOptionsPB_CacheGroupType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_flat_2eproto);
  return file_level_enum_descriptors_flat_2eproto[1];
}
bool QosOptionsPB_CacheGroupType_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 100:
    case 101:
    case 102:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr QosOptionsPB_CacheGroupType QosOptionsPB::NO_CACHE;
constexpr QosOptionsPB_CacheGroupType QosOptionsPB::DEFAULT;
constexpr QosOptionsPB_CacheGroupType QosOptionsPB::INTERNAL;
constexpr QosOptionsPB_CacheGroupType QosOptionsPB::USER_BASE;
constexpr QosOptionsPB_CacheGroupType QosOptionsPB::USER_0;
constexpr QosOptionsPB_CacheGroupType QosOptionsPB::USER_1;
constexpr QosOptionsPB_CacheGroupType QosOptionsPB::CacheGroupType_MIN;
constexpr QosOptionsPB_CacheGroupType QosOptionsPB::CacheGroupType_MAX;
constexpr int QosOptionsPB::CacheGroupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class FixedUUIDInfoPB::_Internal {
 public:
  using HasBits = decltype(std::declval<FixedUUIDInfoPB>()._impl_._has_bits_);
  static void set_has_low(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_high(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FixedUUIDInfoPB::FixedUUIDInfoPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.FixedUUIDInfoPB)
}
FixedUUIDInfoPB::FixedUUIDInfoPB(const FixedUUIDInfoPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FixedUUIDInfoPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.low_){}
    , decltype(_impl_.high_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.low_, &from._impl_.low_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.high_) -
    reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  // @@protoc_insertion_point(copy_constructor:test.FixedUUIDInfoPB)
}

inline void FixedUUIDInfoPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.low_){uint64_t{0u}}
    , decltype(_impl_.high_){uint64_t{0u}}
  };
}

FixedUUIDInfoPB::~FixedUUIDInfoPB() {
  // @@protoc_insertion_point(destructor:test.FixedUUIDInfoPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FixedUUIDInfoPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FixedUUIDInfoPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FixedUUIDInfoPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.FixedUUIDInfoPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.low_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.high_) -
        reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FixedUUIDInfoPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 low = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_low(&has_bits);
          _impl_.low_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 high = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_high(&has_bits);
          _impl_.high_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FixedUUIDInfoPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.FixedUUIDInfoPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 low = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_low(), target);
  }

  // optional fixed64 high = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_high(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.FixedUUIDInfoPB)
  return target;
}

size_t FixedUUIDInfoPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.FixedUUIDInfoPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 low = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 high = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FixedUUIDInfoPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FixedUUIDInfoPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FixedUUIDInfoPB::GetClassData() const { return &_class_data_; }


void FixedUUIDInfoPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FixedUUIDInfoPB*>(&to_msg);
  auto& from = static_cast<const FixedUUIDInfoPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.FixedUUIDInfoPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.low_ = from._impl_.low_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.high_ = from._impl_.high_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FixedUUIDInfoPB::CopyFrom(const FixedUUIDInfoPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.FixedUUIDInfoPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FixedUUIDInfoPB::IsInitialized() const {
  return true;
}

void FixedUUIDInfoPB::InternalSwap(FixedUUIDInfoPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FixedUUIDInfoPB, _impl_.high_)
      + sizeof(FixedUUIDInfoPB::_impl_.high_)
      - PROTOBUF_FIELD_OFFSET(FixedUUIDInfoPB, _impl_.low_)>(
          reinterpret_cast<char*>(&_impl_.low_),
          reinterpret_cast<char*>(&other->_impl_.low_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FixedUUIDInfoPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[0]);
}

// ===================================================================

class MirrorArgsPB::_Internal {
 public:
  using HasBits = decltype(std::declval<MirrorArgsPB>()._impl_._has_bits_);
  static void set_has_copy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ftt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MirrorArgsPB::MirrorArgsPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.MirrorArgsPB)
}
MirrorArgsPB::MirrorArgsPB(const MirrorArgsPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MirrorArgsPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.copy_){}
    , decltype(_impl_.ftt_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.copy_, &from._impl_.copy_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ftt_) -
    reinterpret_cast<char*>(&_impl_.copy_)) + sizeof(_impl_.ftt_));
  // @@protoc_insertion_point(copy_constructor:test.MirrorArgsPB)
}

inline void MirrorArgsPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.copy_){0}
    , decltype(_impl_.ftt_){0}
  };
}

MirrorArgsPB::~MirrorArgsPB() {
  // @@protoc_insertion_point(destructor:test.MirrorArgsPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MirrorArgsPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MirrorArgsPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MirrorArgsPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.MirrorArgsPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.copy_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ftt_) -
        reinterpret_cast<char*>(&_impl_.copy_)) + sizeof(_impl_.ftt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MirrorArgsPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 Copy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_copy(&has_bits);
          _impl_.copy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 FTT = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ftt(&has_bits);
          _impl_.ftt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MirrorArgsPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.MirrorArgsPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 Copy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_copy(), target);
  }

  // optional int32 FTT = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ftt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.MirrorArgsPB)
  return target;
}

size_t MirrorArgsPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.MirrorArgsPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 Copy = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_copy());
    }

    // optional int32 FTT = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ftt());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MirrorArgsPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MirrorArgsPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MirrorArgsPB::GetClassData() const { return &_class_data_; }


void MirrorArgsPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MirrorArgsPB*>(&to_msg);
  auto& from = static_cast<const MirrorArgsPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.MirrorArgsPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.copy_ = from._impl_.copy_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ftt_ = from._impl_.ftt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MirrorArgsPB::CopyFrom(const MirrorArgsPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.MirrorArgsPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MirrorArgsPB::IsInitialized() const {
  return true;
}

void MirrorArgsPB::InternalSwap(MirrorArgsPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MirrorArgsPB, _impl_.ftt_)
      + sizeof(MirrorArgsPB::_impl_.ftt_)
      - PROTOBUF_FIELD_OFFSET(MirrorArgsPB, _impl_.copy_)>(
          reinterpret_cast<char*>(&_impl_.copy_),
          reinterpret_cast<char*>(&other->_impl_.copy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MirrorArgsPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[1]);
}

// ===================================================================

class ChunkOptionsPB::_Internal {
 public:
  using HasBits = decltype(std::declval<ChunkOptionsPB>()._impl_._has_bits_);
  static void set_has_ftttype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::test::MirrorArgsPB& mirror(const ChunkOptionsPB* msg);
  static void set_has_mirror(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_placement(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::test::MirrorArgsPB&
ChunkOptionsPB::_Internal::mirror(const ChunkOptionsPB* msg) {
  return *msg->_impl_.mirror_;
}
ChunkOptionsPB::ChunkOptionsPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.ChunkOptionsPB)
}
ChunkOptionsPB::ChunkOptionsPB(const ChunkOptionsPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChunkOptionsPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.placement_){}
    , decltype(_impl_.mirror_){nullptr}
    , decltype(_impl_.ftttype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.placement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.placement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_placement()) {
    _this->_impl_.placement_.Set(from._internal_placement(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_mirror()) {
    _this->_impl_.mirror_ = new ::test::MirrorArgsPB(*from._impl_.mirror_);
  }
  _this->_impl_.ftttype_ = from._impl_.ftttype_;
  // @@protoc_insertion_point(copy_constructor:test.ChunkOptionsPB)
}

inline void ChunkOptionsPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.placement_){}
    , decltype(_impl_.mirror_){nullptr}
    , decltype(_impl_.ftttype_){0}
  };
  _impl_.placement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.placement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChunkOptionsPB::~ChunkOptionsPB() {
  // @@protoc_insertion_point(destructor:test.ChunkOptionsPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChunkOptionsPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.placement_.Destroy();
  if (this != internal_default_instance()) delete _impl_.mirror_;
}

void ChunkOptionsPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChunkOptionsPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.ChunkOptionsPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.placement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.mirror_ != nullptr);
      _impl_.mirror_->Clear();
    }
  }
  _impl_.ftttype_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChunkOptionsPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 FTTType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ftttype(&has_bits);
          _impl_.ftttype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.MirrorArgsPB Mirror = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_mirror(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes Placement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_placement();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChunkOptionsPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.ChunkOptionsPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 FTTType = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ftttype(), target);
  }

  // optional .test.MirrorArgsPB Mirror = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::mirror(this),
        _Internal::mirror(this).GetCachedSize(), target, stream);
  }

  // optional bytes Placement = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_placement(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.ChunkOptionsPB)
  return target;
}

size_t ChunkOptionsPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.ChunkOptionsPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes Placement = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_placement());
    }

    // optional .test.MirrorArgsPB Mirror = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mirror_);
    }

    // optional int32 FTTType = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ftttype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChunkOptionsPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChunkOptionsPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChunkOptionsPB::GetClassData() const { return &_class_data_; }


void ChunkOptionsPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChunkOptionsPB*>(&to_msg);
  auto& from = static_cast<const ChunkOptionsPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.ChunkOptionsPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_placement(from._internal_placement());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_mirror()->::test::MirrorArgsPB::MergeFrom(
          from._internal_mirror());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ftttype_ = from._impl_.ftttype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkOptionsPB::CopyFrom(const ChunkOptionsPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.ChunkOptionsPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkOptionsPB::IsInitialized() const {
  return true;
}

void ChunkOptionsPB::InternalSwap(ChunkOptionsPB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.placement_, lhs_arena,
      &other->_impl_.placement_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChunkOptionsPB, _impl_.ftttype_)
      + sizeof(ChunkOptionsPB::_impl_.ftttype_)
      - PROTOBUF_FIELD_OFFSET(ChunkOptionsPB, _impl_.mirror_)>(
          reinterpret_cast<char*>(&_impl_.mirror_),
          reinterpret_cast<char*>(&other->_impl_.mirror_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChunkOptionsPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[2]);
}

// ===================================================================

class ReplicaLocationPB::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplicaLocationPB>()._impl_._has_bits_);
  static void set_has_cslocation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_disklocation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_disktype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ReplicaLocationPB::ReplicaLocationPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.ReplicaLocationPB)
}
ReplicaLocationPB::ReplicaLocationPB(const ReplicaLocationPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplicaLocationPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cslocation_){}
    , decltype(_impl_.disklocation_){}
    , decltype(_impl_.disktype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cslocation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cslocation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cslocation()) {
    _this->_impl_.cslocation_.Set(from._internal_cslocation(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.disklocation_, &from._impl_.disklocation_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.disktype_) -
    reinterpret_cast<char*>(&_impl_.disklocation_)) + sizeof(_impl_.disktype_));
  // @@protoc_insertion_point(copy_constructor:test.ReplicaLocationPB)
}

inline void ReplicaLocationPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cslocation_){}
    , decltype(_impl_.disklocation_){0}
    , decltype(_impl_.disktype_){0u}
  };
  _impl_.cslocation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cslocation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReplicaLocationPB::~ReplicaLocationPB() {
  // @@protoc_insertion_point(destructor:test.ReplicaLocationPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplicaLocationPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cslocation_.Destroy();
}

void ReplicaLocationPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplicaLocationPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.ReplicaLocationPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.cslocation_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.disklocation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.disktype_) -
        reinterpret_cast<char*>(&_impl_.disklocation_)) + sizeof(_impl_.disktype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplicaLocationPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes CSLocation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cslocation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 diskLocation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_disklocation(&has_bits);
          _impl_.disklocation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 diskType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_disktype(&has_bits);
          _impl_.disktype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplicaLocationPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.ReplicaLocationPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes CSLocation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_cslocation(), target);
  }

  // optional int32 diskLocation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_disklocation(), target);
  }

  // optional uint32 diskType = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_disktype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.ReplicaLocationPB)
  return target;
}

size_t ReplicaLocationPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.ReplicaLocationPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes CSLocation = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cslocation());
    }

    // optional int32 diskLocation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_disklocation());
    }

    // optional uint32 diskType = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_disktype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplicaLocationPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplicaLocationPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplicaLocationPB::GetClassData() const { return &_class_data_; }


void ReplicaLocationPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplicaLocationPB*>(&to_msg);
  auto& from = static_cast<const ReplicaLocationPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.ReplicaLocationPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cslocation(from._internal_cslocation());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.disklocation_ = from._impl_.disklocation_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.disktype_ = from._impl_.disktype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplicaLocationPB::CopyFrom(const ReplicaLocationPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.ReplicaLocationPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplicaLocationPB::IsInitialized() const {
  return true;
}

void ReplicaLocationPB::InternalSwap(ReplicaLocationPB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cslocation_, lhs_arena,
      &other->_impl_.cslocation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplicaLocationPB, _impl_.disktype_)
      + sizeof(ReplicaLocationPB::_impl_.disktype_)
      - PROTOBUF_FIELD_OFFSET(ReplicaLocationPB, _impl_.disklocation_)>(
          reinterpret_cast<char*>(&_impl_.disklocation_),
          reinterpret_cast<char*>(&other->_impl_.disklocation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplicaLocationPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[3]);
}

// ===================================================================

class AccelerateOpenOptionsPB::_Internal {
 public:
  using HasBits = decltype(std::declval<AccelerateOpenOptionsPB>()._impl_._has_bits_);
  static const ::test::ChunkOptionsPB& chunkoptions(const AccelerateOpenOptionsPB* msg);
  static void set_has_chunkoptions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chunksizeexponent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_checksumcategory(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::test::ChunkOptionsPB&
AccelerateOpenOptionsPB::_Internal::chunkoptions(const AccelerateOpenOptionsPB* msg) {
  return *msg->_impl_.chunkoptions_;
}
AccelerateOpenOptionsPB::AccelerateOpenOptionsPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.AccelerateOpenOptionsPB)
}
AccelerateOpenOptionsPB::AccelerateOpenOptionsPB(const AccelerateOpenOptionsPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccelerateOpenOptionsPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chunklocation_){from._impl_.chunklocation_}
    , decltype(_impl_.chunkoptions_){nullptr}
    , decltype(_impl_.chunksizeexponent_){}
    , decltype(_impl_.checksumcategory_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chunkoptions()) {
    _this->_impl_.chunkoptions_ = new ::test::ChunkOptionsPB(*from._impl_.chunkoptions_);
  }
  ::memcpy(&_impl_.chunksizeexponent_, &from._impl_.chunksizeexponent_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.checksumcategory_) -
    reinterpret_cast<char*>(&_impl_.chunksizeexponent_)) + sizeof(_impl_.checksumcategory_));
  // @@protoc_insertion_point(copy_constructor:test.AccelerateOpenOptionsPB)
}

inline void AccelerateOpenOptionsPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chunklocation_){arena}
    , decltype(_impl_.chunkoptions_){nullptr}
    , decltype(_impl_.chunksizeexponent_){0u}
    , decltype(_impl_.checksumcategory_){0u}
  };
}

AccelerateOpenOptionsPB::~AccelerateOpenOptionsPB() {
  // @@protoc_insertion_point(destructor:test.AccelerateOpenOptionsPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccelerateOpenOptionsPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chunklocation_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.chunkoptions_;
}

void AccelerateOpenOptionsPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccelerateOpenOptionsPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.AccelerateOpenOptionsPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.chunklocation_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.chunkoptions_ != nullptr);
    _impl_.chunkoptions_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.chunksizeexponent_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.checksumcategory_) -
        reinterpret_cast<char*>(&_impl_.chunksizeexponent_)) + sizeof(_impl_.checksumcategory_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccelerateOpenOptionsPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .test.ChunkOptionsPB ChunkOptions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chunkoptions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .test.ReplicaLocationPB ChunkLocation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_chunklocation(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 chunkSizeExponent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_chunksizeexponent(&has_bits);
          _impl_.chunksizeexponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 checksumCategory = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_checksumcategory(&has_bits);
          _impl_.checksumcategory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AccelerateOpenOptionsPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.AccelerateOpenOptionsPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .test.ChunkOptionsPB ChunkOptions = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chunkoptions(this),
        _Internal::chunkoptions(this).GetCachedSize(), target, stream);
  }

  // repeated .test.ReplicaLocationPB ChunkLocation = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chunklocation_size()); i < n; i++) {
    const auto& repfield = this->_internal_chunklocation(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 chunkSizeExponent = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_chunksizeexponent(), target);
  }

  // optional uint32 checksumCategory = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_checksumcategory(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.AccelerateOpenOptionsPB)
  return target;
}

size_t AccelerateOpenOptionsPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.AccelerateOpenOptionsPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .test.ReplicaLocationPB ChunkLocation = 2;
  total_size += 1UL * this->_internal_chunklocation_size();
  for (const auto& msg : this->_impl_.chunklocation_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .test.ChunkOptionsPB ChunkOptions = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chunkoptions_);
    }

    // optional uint32 chunkSizeExponent = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chunksizeexponent());
    }

    // optional uint32 checksumCategory = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_checksumcategory());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccelerateOpenOptionsPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccelerateOpenOptionsPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccelerateOpenOptionsPB::GetClassData() const { return &_class_data_; }


void AccelerateOpenOptionsPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccelerateOpenOptionsPB*>(&to_msg);
  auto& from = static_cast<const AccelerateOpenOptionsPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.AccelerateOpenOptionsPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.chunklocation_.MergeFrom(from._impl_.chunklocation_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_chunkoptions()->::test::ChunkOptionsPB::MergeFrom(
          from._internal_chunkoptions());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.chunksizeexponent_ = from._impl_.chunksizeexponent_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.checksumcategory_ = from._impl_.checksumcategory_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccelerateOpenOptionsPB::CopyFrom(const AccelerateOpenOptionsPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.AccelerateOpenOptionsPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccelerateOpenOptionsPB::IsInitialized() const {
  return true;
}

void AccelerateOpenOptionsPB::InternalSwap(AccelerateOpenOptionsPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.chunklocation_.InternalSwap(&other->_impl_.chunklocation_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AccelerateOpenOptionsPB, _impl_.checksumcategory_)
      + sizeof(AccelerateOpenOptionsPB::_impl_.checksumcategory_)
      - PROTOBUF_FIELD_OFFSET(AccelerateOpenOptionsPB, _impl_.chunkoptions_)>(
          reinterpret_cast<char*>(&_impl_.chunkoptions_),
          reinterpret_cast<char*>(&other->_impl_.chunkoptions_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AccelerateOpenOptionsPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[4]);
}

// ===================================================================

class IONicePB::_Internal {
 public:
  using HasBits = decltype(std::declval<IONicePB>()._impl_._has_bits_);
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ioclass(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IONicePB::IONicePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.IONicePB)
}
IONicePB::IONicePB(const IONicePB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IONicePB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.ioclass_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.priority_, &from._impl_.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ioclass_) -
    reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.ioclass_));
  // @@protoc_insertion_point(copy_constructor:test.IONicePB)
}

inline void IONicePB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.priority_){0}
    , decltype(_impl_.ioclass_){0}
  };
}

IONicePB::~IONicePB() {
  // @@protoc_insertion_point(destructor:test.IONicePB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IONicePB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IONicePB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IONicePB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.IONicePB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.priority_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ioclass_) -
        reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.ioclass_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IONicePB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 Priority = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_priority(&has_bits);
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 IOClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ioclass(&has_bits);
          _impl_.ioclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IONicePB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.IONicePB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 Priority = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_priority(), target);
  }

  // optional int32 IOClass = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ioclass(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.IONicePB)
  return target;
}

size_t IONicePB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.IONicePB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 Priority = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_priority());
    }

    // optional int32 IOClass = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ioclass());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IONicePB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IONicePB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IONicePB::GetClassData() const { return &_class_data_; }


void IONicePB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IONicePB*>(&to_msg);
  auto& from = static_cast<const IONicePB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.IONicePB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.priority_ = from._impl_.priority_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ioclass_ = from._impl_.ioclass_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IONicePB::CopyFrom(const IONicePB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.IONicePB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IONicePB::IsInitialized() const {
  return true;
}

void IONicePB::InternalSwap(IONicePB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IONicePB, _impl_.ioclass_)
      + sizeof(IONicePB::_impl_.ioclass_)
      - PROTOBUF_FIELD_OFFSET(IONicePB, _impl_.priority_)>(
          reinterpret_cast<char*>(&_impl_.priority_),
          reinterpret_cast<char*>(&other->_impl_.priority_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IONicePB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[5]);
}

// ===================================================================

class CsChooseDiskStrategyCJPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CsChooseDiskStrategyCJPB>()._impl_._has_bits_);
  static void set_has_diskstoragetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_targetstoragetype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CsChooseDiskStrategyCJPB::CsChooseDiskStrategyCJPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.CsChooseDiskStrategyCJPB)
}
CsChooseDiskStrategyCJPB::CsChooseDiskStrategyCJPB(const CsChooseDiskStrategyCJPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CsChooseDiskStrategyCJPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.strategies_){from._impl_.strategies_}
    , decltype(_impl_.diskstoragetype_){}
    , decltype(_impl_.targetstoragetype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.diskstoragetype_, &from._impl_.diskstoragetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.targetstoragetype_) -
    reinterpret_cast<char*>(&_impl_.diskstoragetype_)) + sizeof(_impl_.targetstoragetype_));
  // @@protoc_insertion_point(copy_constructor:test.CsChooseDiskStrategyCJPB)
}

inline void CsChooseDiskStrategyCJPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.strategies_){arena}
    , decltype(_impl_.diskstoragetype_){0}
    , decltype(_impl_.targetstoragetype_){0}
  };
}

CsChooseDiskStrategyCJPB::~CsChooseDiskStrategyCJPB() {
  // @@protoc_insertion_point(destructor:test.CsChooseDiskStrategyCJPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CsChooseDiskStrategyCJPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.strategies_.~RepeatedPtrField();
}

void CsChooseDiskStrategyCJPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CsChooseDiskStrategyCJPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.CsChooseDiskStrategyCJPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.strategies_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.diskstoragetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.targetstoragetype_) -
        reinterpret_cast<char*>(&_impl_.diskstoragetype_)) + sizeof(_impl_.targetstoragetype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CsChooseDiskStrategyCJPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .test.CsChooseDiskStrategySingleCJPB Strategies = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_strategies(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 DiskStorageType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_diskstoragetype(&has_bits);
          _impl_.diskstoragetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 TargetStorageType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_targetstoragetype(&has_bits);
          _impl_.targetstoragetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CsChooseDiskStrategyCJPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.CsChooseDiskStrategyCJPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .test.CsChooseDiskStrategySingleCJPB Strategies = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_strategies_size()); i < n; i++) {
    const auto& repfield = this->_internal_strategies(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 DiskStorageType = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_diskstoragetype(), target);
  }

  // optional int32 TargetStorageType = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_targetstoragetype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.CsChooseDiskStrategyCJPB)
  return target;
}

size_t CsChooseDiskStrategyCJPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.CsChooseDiskStrategyCJPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .test.CsChooseDiskStrategySingleCJPB Strategies = 1;
  total_size += 1UL * this->_internal_strategies_size();
  for (const auto& msg : this->_impl_.strategies_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 DiskStorageType = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_diskstoragetype());
    }

    // optional int32 TargetStorageType = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_targetstoragetype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CsChooseDiskStrategyCJPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CsChooseDiskStrategyCJPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CsChooseDiskStrategyCJPB::GetClassData() const { return &_class_data_; }


void CsChooseDiskStrategyCJPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CsChooseDiskStrategyCJPB*>(&to_msg);
  auto& from = static_cast<const CsChooseDiskStrategyCJPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.CsChooseDiskStrategyCJPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.strategies_.MergeFrom(from._impl_.strategies_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.diskstoragetype_ = from._impl_.diskstoragetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.targetstoragetype_ = from._impl_.targetstoragetype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CsChooseDiskStrategyCJPB::CopyFrom(const CsChooseDiskStrategyCJPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.CsChooseDiskStrategyCJPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CsChooseDiskStrategyCJPB::IsInitialized() const {
  return true;
}

void CsChooseDiskStrategyCJPB::InternalSwap(CsChooseDiskStrategyCJPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.strategies_.InternalSwap(&other->_impl_.strategies_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CsChooseDiskStrategyCJPB, _impl_.targetstoragetype_)
      + sizeof(CsChooseDiskStrategyCJPB::_impl_.targetstoragetype_)
      - PROTOBUF_FIELD_OFFSET(CsChooseDiskStrategyCJPB, _impl_.diskstoragetype_)>(
          reinterpret_cast<char*>(&_impl_.diskstoragetype_),
          reinterpret_cast<char*>(&other->_impl_.diskstoragetype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CsChooseDiskStrategyCJPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[6]);
}

// ===================================================================

class ChunkOrStreamIdInfoPB::_Internal {
 public:
  using HasBits = decltype(std::declval<ChunkOrStreamIdInfoPB>()._impl_._has_bits_);
  static const ::test::UUIDInfoPB& uuid(const ChunkOrStreamIdInfoPB* msg);
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_partition_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_padding(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::test::UUIDInfoPB&
ChunkOrStreamIdInfoPB::_Internal::uuid(const ChunkOrStreamIdInfoPB* msg) {
  return *msg->_impl_.uuid_;
}
ChunkOrStreamIdInfoPB::ChunkOrStreamIdInfoPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.ChunkOrStreamIdInfoPB)
}
ChunkOrStreamIdInfoPB::ChunkOrStreamIdInfoPB(const ChunkOrStreamIdInfoPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChunkOrStreamIdInfoPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.partition_index_){}
    , decltype(_impl_.padding_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_uuid()) {
    _this->_impl_.uuid_ = new ::test::UUIDInfoPB(*from._impl_.uuid_);
  }
  ::memcpy(&_impl_.partition_index_, &from._impl_.partition_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.padding_) -
    reinterpret_cast<char*>(&_impl_.partition_index_)) + sizeof(_impl_.padding_));
  // @@protoc_insertion_point(copy_constructor:test.ChunkOrStreamIdInfoPB)
}

inline void ChunkOrStreamIdInfoPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.partition_index_){0u}
    , decltype(_impl_.padding_){0u}
  };
}

ChunkOrStreamIdInfoPB::~ChunkOrStreamIdInfoPB() {
  // @@protoc_insertion_point(destructor:test.ChunkOrStreamIdInfoPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChunkOrStreamIdInfoPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.uuid_;
}

void ChunkOrStreamIdInfoPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChunkOrStreamIdInfoPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.ChunkOrStreamIdInfoPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.uuid_ != nullptr);
    _impl_.uuid_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.partition_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.padding_) -
        reinterpret_cast<char*>(&_impl_.partition_index_)) + sizeof(_impl_.padding_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChunkOrStreamIdInfoPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .test.UUIDInfoPB uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 partition_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_partition_index(&has_bits);
          _impl_.partition_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 padding = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_padding(&has_bits);
          _impl_.padding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChunkOrStreamIdInfoPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.ChunkOrStreamIdInfoPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .test.UUIDInfoPB uuid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::uuid(this),
        _Internal::uuid(this).GetCachedSize(), target, stream);
  }

  // optional uint32 partition_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_partition_index(), target);
  }

  // optional uint32 padding = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_padding(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.ChunkOrStreamIdInfoPB)
  return target;
}

size_t ChunkOrStreamIdInfoPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.ChunkOrStreamIdInfoPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .test.UUIDInfoPB uuid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.uuid_);
    }

    // optional uint32 partition_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partition_index());
    }

    // optional uint32 padding = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_padding());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChunkOrStreamIdInfoPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChunkOrStreamIdInfoPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChunkOrStreamIdInfoPB::GetClassData() const { return &_class_data_; }


void ChunkOrStreamIdInfoPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChunkOrStreamIdInfoPB*>(&to_msg);
  auto& from = static_cast<const ChunkOrStreamIdInfoPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.ChunkOrStreamIdInfoPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_uuid()->::test::UUIDInfoPB::MergeFrom(
          from._internal_uuid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.partition_index_ = from._impl_.partition_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.padding_ = from._impl_.padding_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkOrStreamIdInfoPB::CopyFrom(const ChunkOrStreamIdInfoPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.ChunkOrStreamIdInfoPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkOrStreamIdInfoPB::IsInitialized() const {
  return true;
}

void ChunkOrStreamIdInfoPB::InternalSwap(ChunkOrStreamIdInfoPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChunkOrStreamIdInfoPB, _impl_.padding_)
      + sizeof(ChunkOrStreamIdInfoPB::_impl_.padding_)
      - PROTOBUF_FIELD_OFFSET(ChunkOrStreamIdInfoPB, _impl_.uuid_)>(
          reinterpret_cast<char*>(&_impl_.uuid_),
          reinterpret_cast<char*>(&other->_impl_.uuid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChunkOrStreamIdInfoPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[7]);
}

// ===================================================================

class QosOptionsPB::_Internal {
 public:
  using HasBits = decltype(std::declval<QosOptionsPB>()._impl_._has_bits_);
  static void set_has_serviceid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flowid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_adjust(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cachegroupid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_networkpriority(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

QosOptionsPB::QosOptionsPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.QosOptionsPB)
}
QosOptionsPB::QosOptionsPB(const QosOptionsPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QosOptionsPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serviceid_){}
    , decltype(_impl_.flowid_){}
    , decltype(_impl_.adjust_){}
    , decltype(_impl_.cachegroupid_){}
    , decltype(_impl_.networkpriority_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.serviceid_, &from._impl_.serviceid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.networkpriority_) -
    reinterpret_cast<char*>(&_impl_.serviceid_)) + sizeof(_impl_.networkpriority_));
  // @@protoc_insertion_point(copy_constructor:test.QosOptionsPB)
}

inline void QosOptionsPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.serviceid_){0u}
    , decltype(_impl_.flowid_){0u}
    , decltype(_impl_.adjust_){0}
    , decltype(_impl_.cachegroupid_){0u}
    , decltype(_impl_.networkpriority_){0}
  };
}

QosOptionsPB::~QosOptionsPB() {
  // @@protoc_insertion_point(destructor:test.QosOptionsPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void QosOptionsPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void QosOptionsPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QosOptionsPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.QosOptionsPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.serviceid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.networkpriority_) -
        reinterpret_cast<char*>(&_impl_.serviceid_)) + sizeof(_impl_.networkpriority_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QosOptionsPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 serviceId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_serviceid(&has_bits);
          _impl_.serviceid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flowId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flowid(&has_bits);
          _impl_.flowid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 adjust = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_adjust(&has_bits);
          _impl_.adjust_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cacheGroupId = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cachegroupid(&has_bits);
          _impl_.cachegroupid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 networkPriority = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_networkpriority(&has_bits);
          _impl_.networkpriority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QosOptionsPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.QosOptionsPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 serviceId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_serviceid(), target);
  }

  // optional uint32 flowId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flowid(), target);
  }

  // optional int32 adjust = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_adjust(), target);
  }

  // optional uint32 cacheGroupId = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cachegroupid(), target);
  }

  // optional int32 networkPriority = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_networkpriority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.QosOptionsPB)
  return target;
}

size_t QosOptionsPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.QosOptionsPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 serviceId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_serviceid());
    }

    // optional uint32 flowId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flowid());
    }

    // optional int32 adjust = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_adjust());
    }

    // optional uint32 cacheGroupId = 4 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cachegroupid());
    }

    // optional int32 networkPriority = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_networkpriority());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QosOptionsPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QosOptionsPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QosOptionsPB::GetClassData() const { return &_class_data_; }


void QosOptionsPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QosOptionsPB*>(&to_msg);
  auto& from = static_cast<const QosOptionsPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.QosOptionsPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.serviceid_ = from._impl_.serviceid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.flowid_ = from._impl_.flowid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.adjust_ = from._impl_.adjust_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cachegroupid_ = from._impl_.cachegroupid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.networkpriority_ = from._impl_.networkpriority_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QosOptionsPB::CopyFrom(const QosOptionsPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.QosOptionsPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QosOptionsPB::IsInitialized() const {
  return true;
}

void QosOptionsPB::InternalSwap(QosOptionsPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QosOptionsPB, _impl_.networkpriority_)
      + sizeof(QosOptionsPB::_impl_.networkpriority_)
      - PROTOBUF_FIELD_OFFSET(QosOptionsPB, _impl_.serviceid_)>(
          reinterpret_cast<char*>(&_impl_.serviceid_),
          reinterpret_cast<char*>(&other->_impl_.serviceid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QosOptionsPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[8]);
}

// ===================================================================

class FlushChecksumPB::_Internal {
 public:
  using HasBits = decltype(std::declval<FlushChecksumPB>()._impl_._has_bits_);
  static void set_has_category(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FlushChecksumPB::FlushChecksumPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.FlushChecksumPB)
}
FlushChecksumPB::FlushChecksumPB(const FlushChecksumPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlushChecksumPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.category_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.value_, &from._impl_.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.category_) -
    reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.category_));
  // @@protoc_insertion_point(copy_constructor:test.FlushChecksumPB)
}

inline void FlushChecksumPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){int64_t{0}}
    , decltype(_impl_.category_){0u}
  };
}

FlushChecksumPB::~FlushChecksumPB() {
  // @@protoc_insertion_point(destructor:test.FlushChecksumPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlushChecksumPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FlushChecksumPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlushChecksumPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.FlushChecksumPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.category_) -
        reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.category_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlushChecksumPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 category = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_category(&has_bits);
          _impl_.category_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlushChecksumPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.FlushChecksumPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 category = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_category(), target);
  }

  // optional int64 value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.FlushChecksumPB)
  return target;
}

size_t FlushChecksumPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.FlushChecksumPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_value());
    }

    // optional uint32 category = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_category());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlushChecksumPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlushChecksumPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlushChecksumPB::GetClassData() const { return &_class_data_; }


void FlushChecksumPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlushChecksumPB*>(&to_msg);
  auto& from = static_cast<const FlushChecksumPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.FlushChecksumPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.category_ = from._impl_.category_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlushChecksumPB::CopyFrom(const FlushChecksumPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.FlushChecksumPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushChecksumPB::IsInitialized() const {
  return true;
}

void FlushChecksumPB::InternalSwap(FlushChecksumPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlushChecksumPB, _impl_.category_)
      + sizeof(FlushChecksumPB::_impl_.category_)
      - PROTOBUF_FIELD_OFFSET(FlushChecksumPB, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlushChecksumPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[9]);
}

// ===================================================================

class UUIDInfoPB::_Internal {
 public:
  using HasBits = decltype(std::declval<UUIDInfoPB>()._impl_._has_bits_);
  static void set_has_low(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_high(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UUIDInfoPB::UUIDInfoPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.UUIDInfoPB)
}
UUIDInfoPB::UUIDInfoPB(const UUIDInfoPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UUIDInfoPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.low_){}
    , decltype(_impl_.high_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.low_, &from._impl_.low_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.high_) -
    reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  // @@protoc_insertion_point(copy_constructor:test.UUIDInfoPB)
}

inline void UUIDInfoPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.low_){uint64_t{0u}}
    , decltype(_impl_.high_){uint64_t{0u}}
  };
}

UUIDInfoPB::~UUIDInfoPB() {
  // @@protoc_insertion_point(destructor:test.UUIDInfoPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UUIDInfoPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UUIDInfoPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UUIDInfoPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.UUIDInfoPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.low_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.high_) -
        reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UUIDInfoPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 low = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_low(&has_bits);
          _impl_.low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 high = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_high(&has_bits);
          _impl_.high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UUIDInfoPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.UUIDInfoPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 low = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_low(), target);
  }

  // optional uint64 high = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_high(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.UUIDInfoPB)
  return target;
}

size_t UUIDInfoPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.UUIDInfoPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 low = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_low());
    }

    // optional uint64 high = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_high());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UUIDInfoPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UUIDInfoPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UUIDInfoPB::GetClassData() const { return &_class_data_; }


void UUIDInfoPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UUIDInfoPB*>(&to_msg);
  auto& from = static_cast<const UUIDInfoPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.UUIDInfoPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.low_ = from._impl_.low_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.high_ = from._impl_.high_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UUIDInfoPB::CopyFrom(const UUIDInfoPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.UUIDInfoPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UUIDInfoPB::IsInitialized() const {
  return true;
}

void UUIDInfoPB::InternalSwap(UUIDInfoPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UUIDInfoPB, _impl_.high_)
      + sizeof(UUIDInfoPB::_impl_.high_)
      - PROTOBUF_FIELD_OFFSET(UUIDInfoPB, _impl_.low_)>(
          reinterpret_cast<char*>(&_impl_.low_),
          reinterpret_cast<char*>(&other->_impl_.low_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UUIDInfoPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[10]);
}

// ===================================================================

class RootServerIdPB::_Internal {
 public:
  using HasBits = decltype(std::declval<RootServerIdPB>()._impl_._has_bits_);
  static const ::test::UUIDInfoPB& uuid(const RootServerIdPB* msg);
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_leader_term(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::test::UUIDInfoPB&
RootServerIdPB::_Internal::uuid(const RootServerIdPB* msg) {
  return *msg->_impl_.uuid_;
}
RootServerIdPB::RootServerIdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.RootServerIdPB)
}
RootServerIdPB::RootServerIdPB(const RootServerIdPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RootServerIdPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.leader_term_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_uuid()) {
    _this->_impl_.uuid_ = new ::test::UUIDInfoPB(*from._impl_.uuid_);
  }
  _this->_impl_.leader_term_ = from._impl_.leader_term_;
  // @@protoc_insertion_point(copy_constructor:test.RootServerIdPB)
}

inline void RootServerIdPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.leader_term_){int64_t{0}}
  };
}

RootServerIdPB::~RootServerIdPB() {
  // @@protoc_insertion_point(destructor:test.RootServerIdPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RootServerIdPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.uuid_;
}

void RootServerIdPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RootServerIdPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.RootServerIdPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.uuid_ != nullptr);
    _impl_.uuid_->Clear();
  }
  _impl_.leader_term_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RootServerIdPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .test.UUIDInfoPB uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 leader_term = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_leader_term(&has_bits);
          _impl_.leader_term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RootServerIdPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.RootServerIdPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .test.UUIDInfoPB uuid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::uuid(this),
        _Internal::uuid(this).GetCachedSize(), target, stream);
  }

  // optional int64 leader_term = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_leader_term(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.RootServerIdPB)
  return target;
}

size_t RootServerIdPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.RootServerIdPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .test.UUIDInfoPB uuid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.uuid_);
    }

    // optional int64 leader_term = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_leader_term());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RootServerIdPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RootServerIdPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RootServerIdPB::GetClassData() const { return &_class_data_; }


void RootServerIdPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RootServerIdPB*>(&to_msg);
  auto& from = static_cast<const RootServerIdPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.RootServerIdPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_uuid()->::test::UUIDInfoPB::MergeFrom(
          from._internal_uuid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.leader_term_ = from._impl_.leader_term_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RootServerIdPB::CopyFrom(const RootServerIdPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.RootServerIdPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RootServerIdPB::IsInitialized() const {
  return true;
}

void RootServerIdPB::InternalSwap(RootServerIdPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RootServerIdPB, _impl_.leader_term_)
      + sizeof(RootServerIdPB::_impl_.leader_term_)
      - PROTOBUF_FIELD_OFFSET(RootServerIdPB, _impl_.uuid_)>(
          reinterpret_cast<char*>(&_impl_.uuid_),
          reinterpret_cast<char*>(&other->_impl_.uuid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RootServerIdPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[11]);
}

// ===================================================================

class ChunkIdTypeCJPB::_Internal {
 public:
  using HasBits = decltype(std::declval<ChunkIdTypeCJPB>()._impl_._has_bits_);
  static void set_has_belongedfileid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chunkindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_padding(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ChunkIdTypeCJPB::ChunkIdTypeCJPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.ChunkIdTypeCJPB)
}
ChunkIdTypeCJPB::ChunkIdTypeCJPB(const ChunkIdTypeCJPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChunkIdTypeCJPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.belongedfileid_){}
    , decltype(_impl_.chunkindex_){}
    , decltype(_impl_.padding_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.belongedfileid_, &from._impl_.belongedfileid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.padding_) -
    reinterpret_cast<char*>(&_impl_.belongedfileid_)) + sizeof(_impl_.padding_));
  // @@protoc_insertion_point(copy_constructor:test.ChunkIdTypeCJPB)
}

inline void ChunkIdTypeCJPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.belongedfileid_){uint64_t{0u}}
    , decltype(_impl_.chunkindex_){0u}
    , decltype(_impl_.padding_){0u}
  };
}

ChunkIdTypeCJPB::~ChunkIdTypeCJPB() {
  // @@protoc_insertion_point(destructor:test.ChunkIdTypeCJPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChunkIdTypeCJPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChunkIdTypeCJPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChunkIdTypeCJPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.ChunkIdTypeCJPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.belongedfileid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.padding_) -
        reinterpret_cast<char*>(&_impl_.belongedfileid_)) + sizeof(_impl_.padding_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChunkIdTypeCJPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 BelongedFileId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_belongedfileid(&has_bits);
          _impl_.belongedfileid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ChunkIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_chunkindex(&has_bits);
          _impl_.chunkindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Padding = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_padding(&has_bits);
          _impl_.padding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChunkIdTypeCJPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.ChunkIdTypeCJPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 BelongedFileId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_belongedfileid(), target);
  }

  // optional uint32 ChunkIndex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_chunkindex(), target);
  }

  // optional uint32 Padding = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_padding(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.ChunkIdTypeCJPB)
  return target;
}

size_t ChunkIdTypeCJPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.ChunkIdTypeCJPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 BelongedFileId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_belongedfileid());
    }

    // optional uint32 ChunkIndex = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chunkindex());
    }

    // optional uint32 Padding = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_padding());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChunkIdTypeCJPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChunkIdTypeCJPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChunkIdTypeCJPB::GetClassData() const { return &_class_data_; }


void ChunkIdTypeCJPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChunkIdTypeCJPB*>(&to_msg);
  auto& from = static_cast<const ChunkIdTypeCJPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.ChunkIdTypeCJPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.belongedfileid_ = from._impl_.belongedfileid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.chunkindex_ = from._impl_.chunkindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.padding_ = from._impl_.padding_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkIdTypeCJPB::CopyFrom(const ChunkIdTypeCJPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.ChunkIdTypeCJPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkIdTypeCJPB::IsInitialized() const {
  return true;
}

void ChunkIdTypeCJPB::InternalSwap(ChunkIdTypeCJPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChunkIdTypeCJPB, _impl_.padding_)
      + sizeof(ChunkIdTypeCJPB::_impl_.padding_)
      - PROTOBUF_FIELD_OFFSET(ChunkIdTypeCJPB, _impl_.belongedfileid_)>(
          reinterpret_cast<char*>(&_impl_.belongedfileid_),
          reinterpret_cast<char*>(&other->_impl_.belongedfileid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChunkIdTypeCJPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[12]);
}

// ===================================================================

class PanguTraceSpanInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PanguTraceSpanInfo>()._impl_._has_bits_);
  static void set_has_traceidlow(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_traceidhigh(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_spanid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PanguTraceSpanInfo::PanguTraceSpanInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.PanguTraceSpanInfo)
}
PanguTraceSpanInfo::PanguTraceSpanInfo(const PanguTraceSpanInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PanguTraceSpanInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.traceidlow_){}
    , decltype(_impl_.traceidhigh_){}
    , decltype(_impl_.spanid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.traceidlow_, &from._impl_.traceidlow_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.spanid_) -
    reinterpret_cast<char*>(&_impl_.traceidlow_)) + sizeof(_impl_.spanid_));
  // @@protoc_insertion_point(copy_constructor:test.PanguTraceSpanInfo)
}

inline void PanguTraceSpanInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.traceidlow_){uint64_t{0u}}
    , decltype(_impl_.traceidhigh_){uint64_t{0u}}
    , decltype(_impl_.spanid_){uint64_t{0u}}
  };
}

PanguTraceSpanInfo::~PanguTraceSpanInfo() {
  // @@protoc_insertion_point(destructor:test.PanguTraceSpanInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PanguTraceSpanInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PanguTraceSpanInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PanguTraceSpanInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:test.PanguTraceSpanInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.traceidlow_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.spanid_) -
        reinterpret_cast<char*>(&_impl_.traceidlow_)) + sizeof(_impl_.spanid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PanguTraceSpanInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 TraceIdLow = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_traceidlow(&has_bits);
          _impl_.traceidlow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 TraceIdHigh = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_traceidhigh(&has_bits);
          _impl_.traceidhigh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 SpanId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_spanid(&has_bits);
          _impl_.spanid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PanguTraceSpanInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.PanguTraceSpanInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 TraceIdLow = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_traceidlow(), target);
  }

  // optional uint64 TraceIdHigh = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_traceidhigh(), target);
  }

  // optional uint64 SpanId = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_spanid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.PanguTraceSpanInfo)
  return target;
}

size_t PanguTraceSpanInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.PanguTraceSpanInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 TraceIdLow = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_traceidlow());
    }

    // optional uint64 TraceIdHigh = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_traceidhigh());
    }

    // optional uint64 SpanId = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_spanid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PanguTraceSpanInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PanguTraceSpanInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PanguTraceSpanInfo::GetClassData() const { return &_class_data_; }


void PanguTraceSpanInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PanguTraceSpanInfo*>(&to_msg);
  auto& from = static_cast<const PanguTraceSpanInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.PanguTraceSpanInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.traceidlow_ = from._impl_.traceidlow_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.traceidhigh_ = from._impl_.traceidhigh_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.spanid_ = from._impl_.spanid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PanguTraceSpanInfo::CopyFrom(const PanguTraceSpanInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.PanguTraceSpanInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PanguTraceSpanInfo::IsInitialized() const {
  return true;
}

void PanguTraceSpanInfo::InternalSwap(PanguTraceSpanInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PanguTraceSpanInfo, _impl_.spanid_)
      + sizeof(PanguTraceSpanInfo::_impl_.spanid_)
      - PROTOBUF_FIELD_OFFSET(PanguTraceSpanInfo, _impl_.traceidlow_)>(
          reinterpret_cast<char*>(&_impl_.traceidlow_),
          reinterpret_cast<char*>(&other->_impl_.traceidlow_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PanguTraceSpanInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[13]);
}

// ===================================================================

class CsChooseDiskStrategySingleCJPB::_Internal {
 public:
  using HasBits = decltype(std::declval<CsChooseDiskStrategySingleCJPB>()._impl_._has_bits_);
  static void set_has_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CsChooseDiskStrategySingleCJPB::CsChooseDiskStrategySingleCJPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.CsChooseDiskStrategySingleCJPB)
}
CsChooseDiskStrategySingleCJPB::CsChooseDiskStrategySingleCJPB(const CsChooseDiskStrategySingleCJPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CsChooseDiskStrategySingleCJPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.method_){}
    , decltype(_impl_.weight_){}
    , decltype(_impl_.parameter_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.method_, &from._impl_.method_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.parameter_) -
    reinterpret_cast<char*>(&_impl_.method_)) + sizeof(_impl_.parameter_));
  // @@protoc_insertion_point(copy_constructor:test.CsChooseDiskStrategySingleCJPB)
}

inline void CsChooseDiskStrategySingleCJPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.method_){0u}
    , decltype(_impl_.weight_){0u}
    , decltype(_impl_.parameter_){uint64_t{0u}}
  };
}

CsChooseDiskStrategySingleCJPB::~CsChooseDiskStrategySingleCJPB() {
  // @@protoc_insertion_point(destructor:test.CsChooseDiskStrategySingleCJPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CsChooseDiskStrategySingleCJPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CsChooseDiskStrategySingleCJPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CsChooseDiskStrategySingleCJPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.CsChooseDiskStrategySingleCJPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.method_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.parameter_) -
        reinterpret_cast<char*>(&_impl_.method_)) + sizeof(_impl_.parameter_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CsChooseDiskStrategySingleCJPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 Method = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_method(&has_bits);
          _impl_.method_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Weight = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_weight(&has_bits);
          _impl_.weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 Parameter = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_parameter(&has_bits);
          _impl_.parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CsChooseDiskStrategySingleCJPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.CsChooseDiskStrategySingleCJPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 Method = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_method(), target);
  }

  // optional uint32 Weight = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_weight(), target);
  }

  // optional uint64 Parameter = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_parameter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.CsChooseDiskStrategySingleCJPB)
  return target;
}

size_t CsChooseDiskStrategySingleCJPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.CsChooseDiskStrategySingleCJPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 Method = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_method());
    }

    // optional uint32 Weight = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_weight());
    }

    // optional uint64 Parameter = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_parameter());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CsChooseDiskStrategySingleCJPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CsChooseDiskStrategySingleCJPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CsChooseDiskStrategySingleCJPB::GetClassData() const { return &_class_data_; }


void CsChooseDiskStrategySingleCJPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CsChooseDiskStrategySingleCJPB*>(&to_msg);
  auto& from = static_cast<const CsChooseDiskStrategySingleCJPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.CsChooseDiskStrategySingleCJPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.method_ = from._impl_.method_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.weight_ = from._impl_.weight_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.parameter_ = from._impl_.parameter_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CsChooseDiskStrategySingleCJPB::CopyFrom(const CsChooseDiskStrategySingleCJPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.CsChooseDiskStrategySingleCJPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CsChooseDiskStrategySingleCJPB::IsInitialized() const {
  return true;
}

void CsChooseDiskStrategySingleCJPB::InternalSwap(CsChooseDiskStrategySingleCJPB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CsChooseDiskStrategySingleCJPB, _impl_.parameter_)
      + sizeof(CsChooseDiskStrategySingleCJPB::_impl_.parameter_)
      - PROTOBUF_FIELD_OFFSET(CsChooseDiskStrategySingleCJPB, _impl_.method_)>(
          reinterpret_cast<char*>(&_impl_.method_),
          reinterpret_cast<char*>(&other->_impl_.method_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CsChooseDiskStrategySingleCJPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[14]);
}

// ===================================================================

class FlatLogFileFlushChunkRequestPB::_Internal {
 public:
  using HasBits = decltype(std::declval<FlatLogFileFlushChunkRequestPB>()._impl_._has_bits_);
  static const ::test::ChunkIdTypeCJPB& chunkid(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_chunkid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_storageid(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_isreplication(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_trace_open(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::test::IONicePB& ionice(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_ionice(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::test::AccelerateOpenOptionsPB& openchunkoptions(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_openchunkoptions(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_openmode(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_datasync(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::test::PanguTraceSpanInfo& trace_span(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_trace_span(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_createifnotexists(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::test::CsChooseDiskStrategyCJPB& strategy(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::test::ChunkOrStreamIdInfoPB& chunkidv2(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_chunkidv2(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::test::QosOptionsPB& qosoptions(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_qosoptions(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::test::FlushChecksumPB& checksum(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::test::UUIDInfoPB& volumeuuid(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_volumeuuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_moduleversion(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_diskid(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_requestid(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::test::RootServerIdPB& root_server_id(const FlatLogFileFlushChunkRequestPB* msg);
  static void set_has_root_server_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_requiredmincsversion(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_fromtype(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_offset64(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_recordsize(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_poolid(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_storagepoolconfversion(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_a(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
};

const ::test::ChunkIdTypeCJPB&
FlatLogFileFlushChunkRequestPB::_Internal::chunkid(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.chunkid_;
}
const ::test::IONicePB&
FlatLogFileFlushChunkRequestPB::_Internal::ionice(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.ionice_;
}
const ::test::AccelerateOpenOptionsPB&
FlatLogFileFlushChunkRequestPB::_Internal::openchunkoptions(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.openchunkoptions_;
}
const ::test::PanguTraceSpanInfo&
FlatLogFileFlushChunkRequestPB::_Internal::trace_span(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.trace_span_;
}
const ::test::CsChooseDiskStrategyCJPB&
FlatLogFileFlushChunkRequestPB::_Internal::strategy(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.strategy_;
}
const ::test::ChunkOrStreamIdInfoPB&
FlatLogFileFlushChunkRequestPB::_Internal::chunkidv2(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.chunkidv2_;
}
const ::test::QosOptionsPB&
FlatLogFileFlushChunkRequestPB::_Internal::qosoptions(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.qosoptions_;
}
const ::test::FlushChecksumPB&
FlatLogFileFlushChunkRequestPB::_Internal::checksum(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.checksum_;
}
const ::test::UUIDInfoPB&
FlatLogFileFlushChunkRequestPB::_Internal::volumeuuid(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.volumeuuid_;
}
const ::test::RootServerIdPB&
FlatLogFileFlushChunkRequestPB::_Internal::root_server_id(const FlatLogFileFlushChunkRequestPB* msg) {
  return *msg->_impl_.root_server_id_;
}
FlatLogFileFlushChunkRequestPB::FlatLogFileFlushChunkRequestPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.FlatLogFileFlushChunkRequestPB)
}
FlatLogFileFlushChunkRequestPB::FlatLogFileFlushChunkRequestPB(const FlatLogFileFlushChunkRequestPB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlatLogFileFlushChunkRequestPB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.chunkid_){nullptr}
    , decltype(_impl_.ionice_){nullptr}
    , decltype(_impl_.openchunkoptions_){nullptr}
    , decltype(_impl_.trace_span_){nullptr}
    , decltype(_impl_.strategy_){nullptr}
    , decltype(_impl_.chunkidv2_){nullptr}
    , decltype(_impl_.qosoptions_){nullptr}
    , decltype(_impl_.checksum_){nullptr}
    , decltype(_impl_.volumeuuid_){nullptr}
    , decltype(_impl_.root_server_id_){nullptr}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.length_){}
    , decltype(_impl_.storageid_){}
    , decltype(_impl_.hint_){}
    , decltype(_impl_.isreplication_){}
    , decltype(_impl_.trace_open_){}
    , decltype(_impl_.createifnotexists_){}
    , decltype(_impl_.openmode_){}
    , decltype(_impl_.handle_){}
    , decltype(_impl_.moduleversion_){}
    , decltype(_impl_.diskid_){}
    , decltype(_impl_.requestid_){}
    , decltype(_impl_.requiredmincsversion_){}
    , decltype(_impl_.fromtype_){}
    , decltype(_impl_.offset64_){}
    , decltype(_impl_.recordsize_){}
    , decltype(_impl_.poolid_){}
    , decltype(_impl_.storagepoolconfversion_){}
    , decltype(_impl_.a_){}
    , decltype(_impl_.datasync_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    _this->_impl_.hostname_.Set(from._internal_hostname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userid()) {
    _this->_impl_.userid_.Set(from._internal_userid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_chunkid()) {
    _this->_impl_.chunkid_ = new ::test::ChunkIdTypeCJPB(*from._impl_.chunkid_);
  }
  if (from._internal_has_ionice()) {
    _this->_impl_.ionice_ = new ::test::IONicePB(*from._impl_.ionice_);
  }
  if (from._internal_has_openchunkoptions()) {
    _this->_impl_.openchunkoptions_ = new ::test::AccelerateOpenOptionsPB(*from._impl_.openchunkoptions_);
  }
  if (from._internal_has_trace_span()) {
    _this->_impl_.trace_span_ = new ::test::PanguTraceSpanInfo(*from._impl_.trace_span_);
  }
  if (from._internal_has_strategy()) {
    _this->_impl_.strategy_ = new ::test::CsChooseDiskStrategyCJPB(*from._impl_.strategy_);
  }
  if (from._internal_has_chunkidv2()) {
    _this->_impl_.chunkidv2_ = new ::test::ChunkOrStreamIdInfoPB(*from._impl_.chunkidv2_);
  }
  if (from._internal_has_qosoptions()) {
    _this->_impl_.qosoptions_ = new ::test::QosOptionsPB(*from._impl_.qosoptions_);
  }
  if (from._internal_has_checksum()) {
    _this->_impl_.checksum_ = new ::test::FlushChecksumPB(*from._impl_.checksum_);
  }
  if (from._internal_has_volumeuuid()) {
    _this->_impl_.volumeuuid_ = new ::test::UUIDInfoPB(*from._impl_.volumeuuid_);
  }
  if (from._internal_has_root_server_id()) {
    _this->_impl_.root_server_id_ = new ::test::RootServerIdPB(*from._impl_.root_server_id_);
  }
  ::memcpy(&_impl_.offset_, &from._impl_.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.datasync_) -
    reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.datasync_));
  // @@protoc_insertion_point(copy_constructor:test.FlatLogFileFlushChunkRequestPB)
}

inline void FlatLogFileFlushChunkRequestPB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.userid_){}
    , decltype(_impl_.chunkid_){nullptr}
    , decltype(_impl_.ionice_){nullptr}
    , decltype(_impl_.openchunkoptions_){nullptr}
    , decltype(_impl_.trace_span_){nullptr}
    , decltype(_impl_.strategy_){nullptr}
    , decltype(_impl_.chunkidv2_){nullptr}
    , decltype(_impl_.qosoptions_){nullptr}
    , decltype(_impl_.checksum_){nullptr}
    , decltype(_impl_.volumeuuid_){nullptr}
    , decltype(_impl_.root_server_id_){nullptr}
    , decltype(_impl_.offset_){0u}
    , decltype(_impl_.length_){0u}
    , decltype(_impl_.storageid_){0u}
    , decltype(_impl_.hint_){0u}
    , decltype(_impl_.isreplication_){false}
    , decltype(_impl_.trace_open_){false}
    , decltype(_impl_.createifnotexists_){false}
    , decltype(_impl_.openmode_){0}
    , decltype(_impl_.handle_){int64_t{0}}
    , decltype(_impl_.moduleversion_){0u}
    , decltype(_impl_.diskid_){0u}
    , decltype(_impl_.requestid_){uint64_t{0u}}
    , decltype(_impl_.requiredmincsversion_){0u}
    , decltype(_impl_.fromtype_){0}
    , decltype(_impl_.offset64_){uint64_t{0u}}
    , decltype(_impl_.recordsize_){0u}
    , decltype(_impl_.poolid_){0u}
    , decltype(_impl_.storagepoolconfversion_){uint64_t{0u}}
    , decltype(_impl_.a_){0}
    , decltype(_impl_.datasync_){true}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.userid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FlatLogFileFlushChunkRequestPB::~FlatLogFileFlushChunkRequestPB() {
  // @@protoc_insertion_point(destructor:test.FlatLogFileFlushChunkRequestPB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlatLogFileFlushChunkRequestPB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
  _impl_.hostname_.Destroy();
  _impl_.userid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.chunkid_;
  if (this != internal_default_instance()) delete _impl_.ionice_;
  if (this != internal_default_instance()) delete _impl_.openchunkoptions_;
  if (this != internal_default_instance()) delete _impl_.trace_span_;
  if (this != internal_default_instance()) delete _impl_.strategy_;
  if (this != internal_default_instance()) delete _impl_.chunkidv2_;
  if (this != internal_default_instance()) delete _impl_.qosoptions_;
  if (this != internal_default_instance()) delete _impl_.checksum_;
  if (this != internal_default_instance()) delete _impl_.volumeuuid_;
  if (this != internal_default_instance()) delete _impl_.root_server_id_;
}

void FlatLogFileFlushChunkRequestPB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlatLogFileFlushChunkRequestPB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.FlatLogFileFlushChunkRequestPB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.userid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.chunkid_ != nullptr);
      _impl_.chunkid_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.ionice_ != nullptr);
      _impl_.ionice_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.openchunkoptions_ != nullptr);
      _impl_.openchunkoptions_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.trace_span_ != nullptr);
      _impl_.trace_span_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.strategy_ != nullptr);
      _impl_.strategy_->Clear();
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.chunkidv2_ != nullptr);
      _impl_.chunkidv2_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.qosoptions_ != nullptr);
      _impl_.qosoptions_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.checksum_ != nullptr);
      _impl_.checksum_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.volumeuuid_ != nullptr);
      _impl_.volumeuuid_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.root_server_id_ != nullptr);
      _impl_.root_server_id_->Clear();
    }
  }
  if (cached_has_bits & 0x0000e000u) {
    ::memset(&_impl_.offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.storageid_) -
        reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.storageid_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.hint_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.diskid_) -
        reinterpret_cast<char*>(&_impl_.hint_)) + sizeof(_impl_.diskid_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.requestid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.a_) -
        reinterpret_cast<char*>(&_impl_.requestid_)) + sizeof(_impl_.a_));
  }
  _impl_.datasync_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlatLogFileFlushChunkRequestPB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .test.ChunkIdTypeCJPB ChunkId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chunkid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_offset(&_impl_._has_bits_);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_length(&_impl_._has_bits_);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 StorageId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_storageid(&_impl_._has_bits_);
          _impl_.storageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes Data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Hint = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_hint(&_impl_._has_bits_);
          _impl_.hint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool IsReplication = 7 [default = false];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_isreplication(&_impl_._has_bits_);
          _impl_.isreplication_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool trace_open = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_trace_open(&_impl_._has_bits_);
          _impl_.trace_open_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.IONicePB IONice = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_ionice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.AccelerateOpenOptionsPB OpenChunkOptions = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_openchunkoptions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 OpenMode = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_openmode(&_impl_._has_bits_);
          _impl_.openmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 Handle = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_handle(&_impl_._has_bits_);
          _impl_.handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool DataSync = 13 [default = true];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_datasync(&_impl_._has_bits_);
          _impl_.datasync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.PanguTraceSpanInfo trace_span = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_trace_span(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool CreateIfNotExists = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_createifnotexists(&_impl_._has_bits_);
          _impl_.createifnotexists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.CsChooseDiskStrategyCJPB Strategy = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_strategy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.ChunkOrStreamIdInfoPB ChunkIdV2 = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_chunkidv2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.QosOptionsPB qosOptions = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_qosoptions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.FlushChecksumPB Checksum = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_checksum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.UUIDInfoPB volumeUUID = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_volumeuuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ModuleVersion = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_moduleversion(&_impl_._has_bits_);
          _impl_.moduleversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes HostName = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 DiskId = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_diskid(&_impl_._has_bits_);
          _impl_.diskid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 RequestId = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_requestid(&_impl_._has_bits_);
          _impl_.requestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes UserId = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_userid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .test.RootServerIdPB root_server_id = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_root_server_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 RequiredMinCSVersion = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_requiredmincsversion(&_impl_._has_bits_);
          _impl_.requiredmincsversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 FromType = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_fromtype(&_impl_._has_bits_);
          _impl_.fromtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 Offset64 = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_offset64(&_impl_._has_bits_);
          _impl_.offset64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 RecordSize = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_recordsize(&_impl_._has_bits_);
          _impl_.recordsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 PoolId = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_poolid(&_impl_._has_bits_);
          _impl_.poolid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 StoragePoolConfVersion = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_storagepoolconfversion(&_impl_._has_bits_);
          _impl_.storagepoolconfversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 a = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_a(&_impl_._has_bits_);
          _impl_.a_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlatLogFileFlushChunkRequestPB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.FlatLogFileFlushChunkRequestPB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .test.ChunkIdTypeCJPB ChunkId = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chunkid(this),
        _Internal::chunkid(this).GetCachedSize(), target, stream);
  }

  // optional uint32 Offset = 2;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_offset(), target);
  }

  // optional uint32 Length = 3;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_length(), target);
  }

  // optional uint32 StorageId = 4;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_storageid(), target);
  }

  // optional bytes Data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_data(), target);
  }

  // optional uint32 Hint = 6;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_hint(), target);
  }

  // optional bool IsReplication = 7 [default = false];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_isreplication(), target);
  }

  // optional bool trace_open = 8 [default = false];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_trace_open(), target);
  }

  // optional .test.IONicePB IONice = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::ionice(this),
        _Internal::ionice(this).GetCachedSize(), target, stream);
  }

  // optional .test.AccelerateOpenOptionsPB OpenChunkOptions = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::openchunkoptions(this),
        _Internal::openchunkoptions(this).GetCachedSize(), target, stream);
  }

  // optional int32 OpenMode = 11;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_openmode(), target);
  }

  // optional int64 Handle = 12;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_handle(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool DataSync = 13 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_datasync(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .test.PanguTraceSpanInfo trace_span = 14;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::trace_span(this),
        _Internal::trace_span(this).GetCachedSize(), target, stream);
  }

  // optional bool CreateIfNotExists = 15;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_createifnotexists(), target);
  }

  // optional .test.CsChooseDiskStrategyCJPB Strategy = 16;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::strategy(this),
        _Internal::strategy(this).GetCachedSize(), target, stream);
  }

  // optional .test.ChunkOrStreamIdInfoPB ChunkIdV2 = 17;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::chunkidv2(this),
        _Internal::chunkidv2(this).GetCachedSize(), target, stream);
  }

  // optional .test.QosOptionsPB qosOptions = 18;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::qosoptions(this),
        _Internal::qosoptions(this).GetCachedSize(), target, stream);
  }

  // optional .test.FlushChecksumPB Checksum = 19;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::checksum(this),
        _Internal::checksum(this).GetCachedSize(), target, stream);
  }

  // optional .test.UUIDInfoPB volumeUUID = 20;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::volumeuuid(this),
        _Internal::volumeuuid(this).GetCachedSize(), target, stream);
  }

  // optional uint32 ModuleVersion = 21;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_moduleversion(), target);
  }

  // optional bytes HostName = 22;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        22, this->_internal_hostname(), target);
  }

  // optional uint32 DiskId = 23;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_diskid(), target);
  }

  // optional uint64 RequestId = 24;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(24, this->_internal_requestid(), target);
  }

  // optional bytes UserId = 25;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        25, this->_internal_userid(), target);
  }

  // optional .test.RootServerIdPB root_server_id = 26;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::root_server_id(this),
        _Internal::root_server_id(this).GetCachedSize(), target, stream);
  }

  // optional uint32 RequiredMinCSVersion = 27;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_requiredmincsversion(), target);
  }

  // optional int32 FromType = 28;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(28, this->_internal_fromtype(), target);
  }

  // optional uint64 Offset64 = 29;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(29, this->_internal_offset64(), target);
  }

  // optional uint32 RecordSize = 30;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_recordsize(), target);
  }

  // optional uint32 PoolId = 31;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_poolid(), target);
  }

  // optional uint64 StoragePoolConfVersion = 32;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(32, this->_internal_storagepoolconfversion(), target);
  }

  // optional int32 a = 33;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(33, this->_internal_a(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.FlatLogFileFlushChunkRequestPB)
  return target;
}

size_t FlatLogFileFlushChunkRequestPB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.FlatLogFileFlushChunkRequestPB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes Data = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional bytes HostName = 22;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hostname());
    }

    // optional bytes UserId = 25;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_userid());
    }

    // optional .test.ChunkIdTypeCJPB ChunkId = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chunkid_);
    }

    // optional .test.IONicePB IONice = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ionice_);
    }

    // optional .test.AccelerateOpenOptionsPB OpenChunkOptions = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.openchunkoptions_);
    }

    // optional .test.PanguTraceSpanInfo trace_span = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trace_span_);
    }

    // optional .test.CsChooseDiskStrategyCJPB Strategy = 16;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.strategy_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .test.ChunkOrStreamIdInfoPB ChunkIdV2 = 17;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chunkidv2_);
    }

    // optional .test.QosOptionsPB qosOptions = 18;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.qosoptions_);
    }

    // optional .test.FlushChecksumPB Checksum = 19;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.checksum_);
    }

    // optional .test.UUIDInfoPB volumeUUID = 20;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.volumeuuid_);
    }

    // optional .test.RootServerIdPB root_server_id = 26;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.root_server_id_);
    }

    // optional uint32 Offset = 2;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_offset());
    }

    // optional uint32 Length = 3;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
    }

    // optional uint32 StorageId = 4;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_storageid());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 Hint = 6;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hint());
    }

    // optional bool IsReplication = 7 [default = false];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

    // optional bool trace_open = 8 [default = false];
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional bool CreateIfNotExists = 15;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 1;
    }

    // optional int32 OpenMode = 11;
    if (cached_has_bits & 0x00100000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_openmode());
    }

    // optional int64 Handle = 12;
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_handle());
    }

    // optional uint32 ModuleVersion = 21;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_moduleversion());
    }

    // optional uint32 DiskId = 23;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_diskid());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint64 RequestId = 24;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_requestid());
    }

    // optional uint32 RequiredMinCSVersion = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_requiredmincsversion());
    }

    // optional int32 FromType = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_fromtype());
    }

    // optional uint64 Offset64 = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_offset64());
    }

    // optional uint32 RecordSize = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_recordsize());
    }

    // optional uint32 PoolId = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_poolid());
    }

    // optional uint64 StoragePoolConfVersion = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_storagepoolconfversion());
    }

    // optional int32 a = 33;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_a());
    }

  }
  // optional bool DataSync = 13 [default = true];
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlatLogFileFlushChunkRequestPB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlatLogFileFlushChunkRequestPB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlatLogFileFlushChunkRequestPB::GetClassData() const { return &_class_data_; }


void FlatLogFileFlushChunkRequestPB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlatLogFileFlushChunkRequestPB*>(&to_msg);
  auto& from = static_cast<const FlatLogFileFlushChunkRequestPB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.FlatLogFileFlushChunkRequestPB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_userid(from._internal_userid());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_chunkid()->::test::ChunkIdTypeCJPB::MergeFrom(
          from._internal_chunkid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_ionice()->::test::IONicePB::MergeFrom(
          from._internal_ionice());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_openchunkoptions()->::test::AccelerateOpenOptionsPB::MergeFrom(
          from._internal_openchunkoptions());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_trace_span()->::test::PanguTraceSpanInfo::MergeFrom(
          from._internal_trace_span());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_strategy()->::test::CsChooseDiskStrategyCJPB::MergeFrom(
          from._internal_strategy());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_chunkidv2()->::test::ChunkOrStreamIdInfoPB::MergeFrom(
          from._internal_chunkidv2());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_qosoptions()->::test::QosOptionsPB::MergeFrom(
          from._internal_qosoptions());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_checksum()->::test::FlushChecksumPB::MergeFrom(
          from._internal_checksum());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_volumeuuid()->::test::UUIDInfoPB::MergeFrom(
          from._internal_volumeuuid());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_root_server_id()->::test::RootServerIdPB::MergeFrom(
          from._internal_root_server_id());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.storageid_ = from._impl_.storageid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.hint_ = from._impl_.hint_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.isreplication_ = from._impl_.isreplication_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.trace_open_ = from._impl_.trace_open_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.createifnotexists_ = from._impl_.createifnotexists_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.openmode_ = from._impl_.openmode_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.handle_ = from._impl_.handle_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.moduleversion_ = from._impl_.moduleversion_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.diskid_ = from._impl_.diskid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.requestid_ = from._impl_.requestid_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.requiredmincsversion_ = from._impl_.requiredmincsversion_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.fromtype_ = from._impl_.fromtype_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.offset64_ = from._impl_.offset64_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.recordsize_ = from._impl_.recordsize_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.poolid_ = from._impl_.poolid_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.storagepoolconfversion_ = from._impl_.storagepoolconfversion_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.a_ = from._impl_.a_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_has_datasync()) {
    _this->_internal_set_datasync(from._internal_datasync());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlatLogFileFlushChunkRequestPB::CopyFrom(const FlatLogFileFlushChunkRequestPB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.FlatLogFileFlushChunkRequestPB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlatLogFileFlushChunkRequestPB::IsInitialized() const {
  return true;
}

void FlatLogFileFlushChunkRequestPB::InternalSwap(FlatLogFileFlushChunkRequestPB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostname_, lhs_arena,
      &other->_impl_.hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userid_, lhs_arena,
      &other->_impl_.userid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlatLogFileFlushChunkRequestPB, _impl_.a_)
      + sizeof(FlatLogFileFlushChunkRequestPB::_impl_.a_)
      - PROTOBUF_FIELD_OFFSET(FlatLogFileFlushChunkRequestPB, _impl_.chunkid_)>(
          reinterpret_cast<char*>(&_impl_.chunkid_),
          reinterpret_cast<char*>(&other->_impl_.chunkid_));
  swap(_impl_.datasync_, other->_impl_.datasync_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlatLogFileFlushChunkRequestPB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[15]);
}

// ===================================================================

class FlatLogFileFlushChunkResponsePB::_Internal {
 public:
  using HasBits = decltype(std::declval<FlatLogFileFlushChunkResponsePB>()._impl_._has_bits_);
  static void set_has_errorcode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chunkstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_acklength(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_trace_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_trace_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_storageid(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_diskid(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_requestid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_leftreplicasize(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_a(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

FlatLogFileFlushChunkResponsePB::FlatLogFileFlushChunkResponsePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:test.FlatLogFileFlushChunkResponsePB)
}
FlatLogFileFlushChunkResponsePB::FlatLogFileFlushChunkResponsePB(const FlatLogFileFlushChunkResponsePB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlatLogFileFlushChunkResponsePB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trace_data_){}
    , decltype(_impl_.errorcode_){}
    , decltype(_impl_.chunkstatus_){}
    , decltype(_impl_.hint_){}
    , decltype(_impl_.acklength_){}
    , decltype(_impl_.trace_type_){}
    , decltype(_impl_.storageid_){}
    , decltype(_impl_.handle_){}
    , decltype(_impl_.requestid_){}
    , decltype(_impl_.checksum_){}
    , decltype(_impl_.diskid_){}
    , decltype(_impl_.a_){}
    , decltype(_impl_.leftreplicasize_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.trace_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.trace_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trace_data()) {
    _this->_impl_.trace_data_.Set(from._internal_trace_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.errorcode_, &from._impl_.errorcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.leftreplicasize_) -
    reinterpret_cast<char*>(&_impl_.errorcode_)) + sizeof(_impl_.leftreplicasize_));
  // @@protoc_insertion_point(copy_constructor:test.FlatLogFileFlushChunkResponsePB)
}

inline void FlatLogFileFlushChunkResponsePB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trace_data_){}
    , decltype(_impl_.errorcode_){0}
    , decltype(_impl_.chunkstatus_){0u}
    , decltype(_impl_.hint_){0u}
    , decltype(_impl_.acklength_){0u}
    , decltype(_impl_.trace_type_){0u}
    , decltype(_impl_.storageid_){0u}
    , decltype(_impl_.handle_){int64_t{0}}
    , decltype(_impl_.requestid_){uint64_t{0u}}
    , decltype(_impl_.checksum_){int64_t{0}}
    , decltype(_impl_.diskid_){0u}
    , decltype(_impl_.a_){0}
    , decltype(_impl_.leftreplicasize_){uint64_t{0u}}
  };
  _impl_.trace_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.trace_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FlatLogFileFlushChunkResponsePB::~FlatLogFileFlushChunkResponsePB() {
  // @@protoc_insertion_point(destructor:test.FlatLogFileFlushChunkResponsePB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlatLogFileFlushChunkResponsePB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.trace_data_.Destroy();
}

void FlatLogFileFlushChunkResponsePB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlatLogFileFlushChunkResponsePB::Clear() {
// @@protoc_insertion_point(message_clear_start:test.FlatLogFileFlushChunkResponsePB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.trace_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.errorcode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.handle_) -
        reinterpret_cast<char*>(&_impl_.errorcode_)) + sizeof(_impl_.handle_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.requestid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.leftreplicasize_) -
        reinterpret_cast<char*>(&_impl_.requestid_)) + sizeof(_impl_.leftreplicasize_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlatLogFileFlushChunkResponsePB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 Errorcode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_errorcode(&has_bits);
          _impl_.errorcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ChunkStatus = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_chunkstatus(&has_bits);
          _impl_.chunkstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Hint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hint(&has_bits);
          _impl_.hint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 AckLength = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_acklength(&has_bits);
          _impl_.acklength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 trace_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_trace_type(&has_bits);
          _impl_.trace_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes trace_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_trace_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 Handle = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_handle(&has_bits);
          _impl_.handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 StorageId = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_storageid(&has_bits);
          _impl_.storageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 DiskId = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_diskid(&has_bits);
          _impl_.diskid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 RequestId = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_requestid(&has_bits);
          _impl_.requestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 Checksum = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_checksum(&has_bits);
          _impl_.checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 LeftReplicaSize = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_leftreplicasize(&has_bits);
          _impl_.leftreplicasize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 a = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_a(&has_bits);
          _impl_.a_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlatLogFileFlushChunkResponsePB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:test.FlatLogFileFlushChunkResponsePB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 Errorcode = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_errorcode(), target);
  }

  // optional uint32 ChunkStatus = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_chunkstatus(), target);
  }

  // optional uint32 Hint = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hint(), target);
  }

  // optional uint32 AckLength = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_acklength(), target);
  }

  // optional uint32 trace_type = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_trace_type(), target);
  }

  // optional bytes trace_data = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_trace_data(), target);
  }

  // optional int64 Handle = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_handle(), target);
  }

  // optional uint32 StorageId = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_storageid(), target);
  }

  // optional uint32 DiskId = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_diskid(), target);
  }

  // optional uint64 RequestId = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_requestid(), target);
  }

  // optional int64 Checksum = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_checksum(), target);
  }

  // optional uint64 LeftReplicaSize = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_leftreplicasize(), target);
  }

  // optional int32 a = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_a(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:test.FlatLogFileFlushChunkResponsePB)
  return target;
}

size_t FlatLogFileFlushChunkResponsePB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:test.FlatLogFileFlushChunkResponsePB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes trace_data = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_trace_data());
    }

    // optional int32 Errorcode = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_errorcode());
    }

    // optional uint32 ChunkStatus = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chunkstatus());
    }

    // optional uint32 Hint = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hint());
    }

    // optional uint32 AckLength = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_acklength());
    }

    // optional uint32 trace_type = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_trace_type());
    }

    // optional uint32 StorageId = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_storageid());
    }

    // optional int64 Handle = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_handle());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint64 RequestId = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_requestid());
    }

    // optional int64 Checksum = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_checksum());
    }

    // optional uint32 DiskId = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_diskid());
    }

    // optional int32 a = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_a());
    }

    // optional uint64 LeftReplicaSize = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_leftreplicasize());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlatLogFileFlushChunkResponsePB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlatLogFileFlushChunkResponsePB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlatLogFileFlushChunkResponsePB::GetClassData() const { return &_class_data_; }


void FlatLogFileFlushChunkResponsePB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlatLogFileFlushChunkResponsePB*>(&to_msg);
  auto& from = static_cast<const FlatLogFileFlushChunkResponsePB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:test.FlatLogFileFlushChunkResponsePB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_trace_data(from._internal_trace_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.errorcode_ = from._impl_.errorcode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.chunkstatus_ = from._impl_.chunkstatus_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.hint_ = from._impl_.hint_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.acklength_ = from._impl_.acklength_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.trace_type_ = from._impl_.trace_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.storageid_ = from._impl_.storageid_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.handle_ = from._impl_.handle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.requestid_ = from._impl_.requestid_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.checksum_ = from._impl_.checksum_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.diskid_ = from._impl_.diskid_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.a_ = from._impl_.a_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.leftreplicasize_ = from._impl_.leftreplicasize_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlatLogFileFlushChunkResponsePB::CopyFrom(const FlatLogFileFlushChunkResponsePB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:test.FlatLogFileFlushChunkResponsePB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlatLogFileFlushChunkResponsePB::IsInitialized() const {
  return true;
}

void FlatLogFileFlushChunkResponsePB::InternalSwap(FlatLogFileFlushChunkResponsePB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.trace_data_, lhs_arena,
      &other->_impl_.trace_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlatLogFileFlushChunkResponsePB, _impl_.leftreplicasize_)
      + sizeof(FlatLogFileFlushChunkResponsePB::_impl_.leftreplicasize_)
      - PROTOBUF_FIELD_OFFSET(FlatLogFileFlushChunkResponsePB, _impl_.errorcode_)>(
          reinterpret_cast<char*>(&_impl_.errorcode_),
          reinterpret_cast<char*>(&other->_impl_.errorcode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlatLogFileFlushChunkResponsePB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_flat_2eproto_getter, &descriptor_table_flat_2eproto_once,
      file_level_metadata_flat_2eproto[16]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace test
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::test::FixedUUIDInfoPB*
Arena::CreateMaybeMessage< ::test::FixedUUIDInfoPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::FixedUUIDInfoPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::MirrorArgsPB*
Arena::CreateMaybeMessage< ::test::MirrorArgsPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::MirrorArgsPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::ChunkOptionsPB*
Arena::CreateMaybeMessage< ::test::ChunkOptionsPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::ChunkOptionsPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::ReplicaLocationPB*
Arena::CreateMaybeMessage< ::test::ReplicaLocationPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::ReplicaLocationPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::AccelerateOpenOptionsPB*
Arena::CreateMaybeMessage< ::test::AccelerateOpenOptionsPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::AccelerateOpenOptionsPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::IONicePB*
Arena::CreateMaybeMessage< ::test::IONicePB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::IONicePB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::CsChooseDiskStrategyCJPB*
Arena::CreateMaybeMessage< ::test::CsChooseDiskStrategyCJPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::CsChooseDiskStrategyCJPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::ChunkOrStreamIdInfoPB*
Arena::CreateMaybeMessage< ::test::ChunkOrStreamIdInfoPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::ChunkOrStreamIdInfoPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::QosOptionsPB*
Arena::CreateMaybeMessage< ::test::QosOptionsPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::QosOptionsPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::FlushChecksumPB*
Arena::CreateMaybeMessage< ::test::FlushChecksumPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::FlushChecksumPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::UUIDInfoPB*
Arena::CreateMaybeMessage< ::test::UUIDInfoPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::UUIDInfoPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::RootServerIdPB*
Arena::CreateMaybeMessage< ::test::RootServerIdPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::RootServerIdPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::ChunkIdTypeCJPB*
Arena::CreateMaybeMessage< ::test::ChunkIdTypeCJPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::ChunkIdTypeCJPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::PanguTraceSpanInfo*
Arena::CreateMaybeMessage< ::test::PanguTraceSpanInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::PanguTraceSpanInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::test::CsChooseDiskStrategySingleCJPB*
Arena::CreateMaybeMessage< ::test::CsChooseDiskStrategySingleCJPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::CsChooseDiskStrategySingleCJPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::FlatLogFileFlushChunkRequestPB*
Arena::CreateMaybeMessage< ::test::FlatLogFileFlushChunkRequestPB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::FlatLogFileFlushChunkRequestPB >(arena);
}
template<> PROTOBUF_NOINLINE ::test::FlatLogFileFlushChunkResponsePB*
Arena::CreateMaybeMessage< ::test::FlatLogFileFlushChunkResponsePB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::test::FlatLogFileFlushChunkResponsePB >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
