// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GREETER_H_
#define FLATBUFFERS_GENERATED_GREETER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct FixedUUIDInfoFB;
struct FixedUUIDInfoFBBuilder;

struct MirrorArgsFB;
struct MirrorArgsFBBuilder;

struct ChunkOptionsFB;
struct ChunkOptionsFBBuilder;

struct ReplicaLocationFB;
struct ReplicaLocationFBBuilder;

struct AccelerateOpenOptionsFB;
struct AccelerateOpenOptionsFBBuilder;

struct IONiceFB;
struct IONiceFBBuilder;

struct CsChooseDiskStrategyCJFB;
struct CsChooseDiskStrategyCJFBBuilder;

struct ChunkOrStreamIdInfoFB;
struct ChunkOrStreamIdInfoFBBuilder;

struct QosOptionsFB;
struct QosOptionsFBBuilder;

struct FlushChecksumFB;
struct FlushChecksumFBBuilder;

struct UUIDInfoFB;
struct UUIDInfoFBBuilder;

struct RootServerIdFB;
struct RootServerIdFBBuilder;

struct ChunkIdTypeCJFB;
struct ChunkIdTypeCJFBBuilder;

struct PanguTraceSpanInfoFB;
struct PanguTraceSpanInfoFBBuilder;

struct CsChooseDiskStrategySingleCJFB;
struct CsChooseDiskStrategySingleCJFBBuilder;

struct FlatLogFileFlushChunkRequestFB;
struct FlatLogFileFlushChunkRequestFBBuilder;

struct FlatLogFileFlushChunkResponseFB;
struct FlatLogFileFlushChunkResponseFBBuilder;

enum AdjustType : int16_t {
  AdjustType_LOWER = -1,
  AdjustType_KEEP = 0,
  AdjustType_HIGHER = 1,
  AdjustType_MIN = AdjustType_LOWER,
  AdjustType_MAX = AdjustType_HIGHER
};

inline const AdjustType (&EnumValuesAdjustType())[3] {
  static const AdjustType values[] = {
    AdjustType_LOWER,
    AdjustType_KEEP,
    AdjustType_HIGHER
  };
  return values;
}

inline const char * const *EnumNamesAdjustType() {
  static const char * const names[4] = {
    "LOWER",
    "KEEP",
    "HIGHER",
    nullptr
  };
  return names;
}

inline const char *EnumNameAdjustType(AdjustType e) {
  if (::flatbuffers::IsOutRange(e, AdjustType_LOWER, AdjustType_HIGHER)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AdjustType_LOWER);
  return EnumNamesAdjustType()[index];
}

enum CacheGroupType : uint32_t {
  CacheGroupType_DEFAULT = 0,
  CacheGroupType_INTERNAL = 1,
  CacheGroupType_USER_BASE = 100,
  CacheGroupType_USER_0 = 101,
  CacheGroupType_USER_1 = 102,
  CacheGroupType_NO_CACHE = 4294967295,
  CacheGroupType_MIN = CacheGroupType_DEFAULT,
  CacheGroupType_MAX = CacheGroupType_NO_CACHE
};

inline const CacheGroupType (&EnumValuesCacheGroupType())[6] {
  static const CacheGroupType values[] = {
    CacheGroupType_DEFAULT,
    CacheGroupType_INTERNAL,
    CacheGroupType_USER_BASE,
    CacheGroupType_USER_0,
    CacheGroupType_USER_1,
    CacheGroupType_NO_CACHE
  };
  return values;
}

inline const char *EnumNameCacheGroupType(CacheGroupType e) {
  switch (e) {
    case CacheGroupType_DEFAULT: return "DEFAULT";
    case CacheGroupType_INTERNAL: return "INTERNAL";
    case CacheGroupType_USER_BASE: return "USER_BASE";
    case CacheGroupType_USER_0: return "USER_0";
    case CacheGroupType_USER_1: return "USER_1";
    case CacheGroupType_NO_CACHE: return "NO_CACHE";
    default: return "";
  }
}

struct FixedUUIDInfoFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FixedUUIDInfoFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW = 4,
    VT_HIGH = 6
  };
  uint64_t low() const {
    return GetField<uint64_t>(VT_LOW, 0);
  }
  uint64_t high() const {
    return GetField<uint64_t>(VT_HIGH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOW, 8) &&
           VerifyField<uint64_t>(verifier, VT_HIGH, 8) &&
           verifier.EndTable();
  }
};

struct FixedUUIDInfoFBBuilder {
  typedef FixedUUIDInfoFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_low(uint64_t low) {
    fbb_.AddElement<uint64_t>(FixedUUIDInfoFB::VT_LOW, low, 0);
  }
  void add_high(uint64_t high) {
    fbb_.AddElement<uint64_t>(FixedUUIDInfoFB::VT_HIGH, high, 0);
  }
  explicit FixedUUIDInfoFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FixedUUIDInfoFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FixedUUIDInfoFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FixedUUIDInfoFB> CreateFixedUUIDInfoFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t low = 0,
    uint64_t high = 0) {
  FixedUUIDInfoFBBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  return builder_.Finish();
}

struct MirrorArgsFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MirrorArgsFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COPY = 4,
    VT_FTT = 6
  };
  int32_t copy() const {
    return GetField<int32_t>(VT_COPY, 0);
  }
  int32_t ftt() const {
    return GetField<int32_t>(VT_FTT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COPY, 4) &&
           VerifyField<int32_t>(verifier, VT_FTT, 4) &&
           verifier.EndTable();
  }
};

struct MirrorArgsFBBuilder {
  typedef MirrorArgsFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_copy(int32_t copy) {
    fbb_.AddElement<int32_t>(MirrorArgsFB::VT_COPY, copy, 0);
  }
  void add_ftt(int32_t ftt) {
    fbb_.AddElement<int32_t>(MirrorArgsFB::VT_FTT, ftt, 0);
  }
  explicit MirrorArgsFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MirrorArgsFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MirrorArgsFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MirrorArgsFB> CreateMirrorArgsFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t copy = 0,
    int32_t ftt = 0) {
  MirrorArgsFBBuilder builder_(_fbb);
  builder_.add_ftt(ftt);
  builder_.add_copy(copy);
  return builder_.Finish();
}

struct ChunkOptionsFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkOptionsFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FTT_TYPE = 4,
    VT_MIRROR = 6,
    VT_PLACEMENT = 8
  };
  int32_t ftt_type() const {
    return GetField<int32_t>(VT_FTT_TYPE, 0);
  }
  const MirrorArgsFB *mirror() const {
    return GetPointer<const MirrorArgsFB *>(VT_MIRROR);
  }
  const ::flatbuffers::String *placement() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLACEMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FTT_TYPE, 4) &&
           VerifyOffset(verifier, VT_MIRROR) &&
           verifier.VerifyTable(mirror()) &&
           VerifyOffset(verifier, VT_PLACEMENT) &&
           verifier.VerifyString(placement()) &&
           verifier.EndTable();
  }
};

struct ChunkOptionsFBBuilder {
  typedef ChunkOptionsFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ftt_type(int32_t ftt_type) {
    fbb_.AddElement<int32_t>(ChunkOptionsFB::VT_FTT_TYPE, ftt_type, 0);
  }
  void add_mirror(::flatbuffers::Offset<MirrorArgsFB> mirror) {
    fbb_.AddOffset(ChunkOptionsFB::VT_MIRROR, mirror);
  }
  void add_placement(::flatbuffers::Offset<::flatbuffers::String> placement) {
    fbb_.AddOffset(ChunkOptionsFB::VT_PLACEMENT, placement);
  }
  explicit ChunkOptionsFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChunkOptionsFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChunkOptionsFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChunkOptionsFB> CreateChunkOptionsFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ftt_type = 0,
    ::flatbuffers::Offset<MirrorArgsFB> mirror = 0,
    ::flatbuffers::Offset<::flatbuffers::String> placement = 0) {
  ChunkOptionsFBBuilder builder_(_fbb);
  builder_.add_placement(placement);
  builder_.add_mirror(mirror);
  builder_.add_ftt_type(ftt_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ChunkOptionsFB> CreateChunkOptionsFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ftt_type = 0,
    ::flatbuffers::Offset<MirrorArgsFB> mirror = 0,
    const char *placement = nullptr) {
  auto placement__ = placement ? _fbb.CreateString(placement) : 0;
  return CreateChunkOptionsFB(
      _fbb,
      ftt_type,
      mirror,
      placement__);
}

struct ReplicaLocationFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReplicaLocationFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CS_LOCATION = 4,
    VT_DISK_LOCATION = 6,
    VT_DISK_TYPE = 8
  };
  const ::flatbuffers::String *cs_location() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CS_LOCATION);
  }
  int32_t disk_location() const {
    return GetField<int32_t>(VT_DISK_LOCATION, 0);
  }
  uint32_t disk_type() const {
    return GetField<uint32_t>(VT_DISK_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CS_LOCATION) &&
           verifier.VerifyString(cs_location()) &&
           VerifyField<int32_t>(verifier, VT_DISK_LOCATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_DISK_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct ReplicaLocationFBBuilder {
  typedef ReplicaLocationFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cs_location(::flatbuffers::Offset<::flatbuffers::String> cs_location) {
    fbb_.AddOffset(ReplicaLocationFB::VT_CS_LOCATION, cs_location);
  }
  void add_disk_location(int32_t disk_location) {
    fbb_.AddElement<int32_t>(ReplicaLocationFB::VT_DISK_LOCATION, disk_location, 0);
  }
  void add_disk_type(uint32_t disk_type) {
    fbb_.AddElement<uint32_t>(ReplicaLocationFB::VT_DISK_TYPE, disk_type, 0);
  }
  explicit ReplicaLocationFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReplicaLocationFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReplicaLocationFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReplicaLocationFB> CreateReplicaLocationFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> cs_location = 0,
    int32_t disk_location = 0,
    uint32_t disk_type = 0) {
  ReplicaLocationFBBuilder builder_(_fbb);
  builder_.add_disk_type(disk_type);
  builder_.add_disk_location(disk_location);
  builder_.add_cs_location(cs_location);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReplicaLocationFB> CreateReplicaLocationFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *cs_location = nullptr,
    int32_t disk_location = 0,
    uint32_t disk_type = 0) {
  auto cs_location__ = cs_location ? _fbb.CreateString(cs_location) : 0;
  return CreateReplicaLocationFB(
      _fbb,
      cs_location__,
      disk_location,
      disk_type);
}

struct AccelerateOpenOptionsFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerateOpenOptionsFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNK_OPTIONS = 4,
    VT_CHUNK_LOCATION = 6,
    VT_CHUNK_SIZEEXPONENT = 8,
    VT_CHECK_SUMCATEGORY = 10
  };
  const ChunkOptionsFB *chunk_options() const {
    return GetPointer<const ChunkOptionsFB *>(VT_CHUNK_OPTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ReplicaLocationFB>> *chunk_location() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ReplicaLocationFB>> *>(VT_CHUNK_LOCATION);
  }
  uint32_t chunk_sizeexponent() const {
    return GetField<uint32_t>(VT_CHUNK_SIZEEXPONENT, 0);
  }
  uint32_t check_sumcategory() const {
    return GetField<uint32_t>(VT_CHECK_SUMCATEGORY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNK_OPTIONS) &&
           verifier.VerifyTable(chunk_options()) &&
           VerifyOffset(verifier, VT_CHUNK_LOCATION) &&
           verifier.VerifyVector(chunk_location()) &&
           verifier.VerifyVectorOfTables(chunk_location()) &&
           VerifyField<uint32_t>(verifier, VT_CHUNK_SIZEEXPONENT, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHECK_SUMCATEGORY, 4) &&
           verifier.EndTable();
  }
};

struct AccelerateOpenOptionsFBBuilder {
  typedef AccelerateOpenOptionsFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chunk_options(::flatbuffers::Offset<ChunkOptionsFB> chunk_options) {
    fbb_.AddOffset(AccelerateOpenOptionsFB::VT_CHUNK_OPTIONS, chunk_options);
  }
  void add_chunk_location(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ReplicaLocationFB>>> chunk_location) {
    fbb_.AddOffset(AccelerateOpenOptionsFB::VT_CHUNK_LOCATION, chunk_location);
  }
  void add_chunk_sizeexponent(uint32_t chunk_sizeexponent) {
    fbb_.AddElement<uint32_t>(AccelerateOpenOptionsFB::VT_CHUNK_SIZEEXPONENT, chunk_sizeexponent, 0);
  }
  void add_check_sumcategory(uint32_t check_sumcategory) {
    fbb_.AddElement<uint32_t>(AccelerateOpenOptionsFB::VT_CHECK_SUMCATEGORY, check_sumcategory, 0);
  }
  explicit AccelerateOpenOptionsFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerateOpenOptionsFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerateOpenOptionsFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerateOpenOptionsFB> CreateAccelerateOpenOptionsFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChunkOptionsFB> chunk_options = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ReplicaLocationFB>>> chunk_location = 0,
    uint32_t chunk_sizeexponent = 0,
    uint32_t check_sumcategory = 0) {
  AccelerateOpenOptionsFBBuilder builder_(_fbb);
  builder_.add_check_sumcategory(check_sumcategory);
  builder_.add_chunk_sizeexponent(chunk_sizeexponent);
  builder_.add_chunk_location(chunk_location);
  builder_.add_chunk_options(chunk_options);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AccelerateOpenOptionsFB> CreateAccelerateOpenOptionsFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChunkOptionsFB> chunk_options = 0,
    const std::vector<::flatbuffers::Offset<ReplicaLocationFB>> *chunk_location = nullptr,
    uint32_t chunk_sizeexponent = 0,
    uint32_t check_sumcategory = 0) {
  auto chunk_location__ = chunk_location ? _fbb.CreateVector<::flatbuffers::Offset<ReplicaLocationFB>>(*chunk_location) : 0;
  return CreateAccelerateOpenOptionsFB(
      _fbb,
      chunk_options,
      chunk_location__,
      chunk_sizeexponent,
      check_sumcategory);
}

struct IONiceFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IONiceFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRIORITY = 4,
    VT_IO_CLASS = 6
  };
  int32_t priority() const {
    return GetField<int32_t>(VT_PRIORITY, 0);
  }
  int32_t io_class() const {
    return GetField<int32_t>(VT_IO_CLASS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<int32_t>(verifier, VT_IO_CLASS, 4) &&
           verifier.EndTable();
  }
};

struct IONiceFBBuilder {
  typedef IONiceFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_priority(int32_t priority) {
    fbb_.AddElement<int32_t>(IONiceFB::VT_PRIORITY, priority, 0);
  }
  void add_io_class(int32_t io_class) {
    fbb_.AddElement<int32_t>(IONiceFB::VT_IO_CLASS, io_class, 0);
  }
  explicit IONiceFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IONiceFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IONiceFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IONiceFB> CreateIONiceFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t priority = 0,
    int32_t io_class = 0) {
  IONiceFBBuilder builder_(_fbb);
  builder_.add_io_class(io_class);
  builder_.add_priority(priority);
  return builder_.Finish();
}

struct CsChooseDiskStrategyCJFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CsChooseDiskStrategyCJFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRATEGIES = 4,
    VT_DISK_STORAGE_TYPE = 6,
    VT_TARGET_STORAGE_TYPE = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>> *strategies() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>> *>(VT_STRATEGIES);
  }
  int32_t disk_storage_type() const {
    return GetField<int32_t>(VT_DISK_STORAGE_TYPE, 0);
  }
  int32_t target_storage_type() const {
    return GetField<int32_t>(VT_TARGET_STORAGE_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRATEGIES) &&
           verifier.VerifyVector(strategies()) &&
           verifier.VerifyVectorOfTables(strategies()) &&
           VerifyField<int32_t>(verifier, VT_DISK_STORAGE_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGET_STORAGE_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct CsChooseDiskStrategyCJFBBuilder {
  typedef CsChooseDiskStrategyCJFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_strategies(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>>> strategies) {
    fbb_.AddOffset(CsChooseDiskStrategyCJFB::VT_STRATEGIES, strategies);
  }
  void add_disk_storage_type(int32_t disk_storage_type) {
    fbb_.AddElement<int32_t>(CsChooseDiskStrategyCJFB::VT_DISK_STORAGE_TYPE, disk_storage_type, 0);
  }
  void add_target_storage_type(int32_t target_storage_type) {
    fbb_.AddElement<int32_t>(CsChooseDiskStrategyCJFB::VT_TARGET_STORAGE_TYPE, target_storage_type, 0);
  }
  explicit CsChooseDiskStrategyCJFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CsChooseDiskStrategyCJFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> CreateCsChooseDiskStrategyCJFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>>> strategies = 0,
    int32_t disk_storage_type = 0,
    int32_t target_storage_type = 0) {
  CsChooseDiskStrategyCJFBBuilder builder_(_fbb);
  builder_.add_target_storage_type(target_storage_type);
  builder_.add_disk_storage_type(disk_storage_type);
  builder_.add_strategies(strategies);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> CreateCsChooseDiskStrategyCJFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>> *strategies = nullptr,
    int32_t disk_storage_type = 0,
    int32_t target_storage_type = 0) {
  auto strategies__ = strategies ? _fbb.CreateVector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>>(*strategies) : 0;
  return CreateCsChooseDiskStrategyCJFB(
      _fbb,
      strategies__,
      disk_storage_type,
      target_storage_type);
}

struct ChunkOrStreamIdInfoFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkOrStreamIdInfoFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_PARTITION_INDEX = 6,
    VT_PADDING = 8
  };
  const UUIDInfoFB *uuid() const {
    return GetPointer<const UUIDInfoFB *>(VT_UUID);
  }
  uint32_t partition_index() const {
    return GetField<uint32_t>(VT_PARTITION_INDEX, 0);
  }
  uint32_t padding() const {
    return GetField<uint32_t>(VT_PADDING, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyTable(uuid()) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_INDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
};

struct ChunkOrStreamIdInfoFBBuilder {
  typedef ChunkOrStreamIdInfoFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(::flatbuffers::Offset<UUIDInfoFB> uuid) {
    fbb_.AddOffset(ChunkOrStreamIdInfoFB::VT_UUID, uuid);
  }
  void add_partition_index(uint32_t partition_index) {
    fbb_.AddElement<uint32_t>(ChunkOrStreamIdInfoFB::VT_PARTITION_INDEX, partition_index, 0);
  }
  void add_padding(uint32_t padding) {
    fbb_.AddElement<uint32_t>(ChunkOrStreamIdInfoFB::VT_PADDING, padding, 0);
  }
  explicit ChunkOrStreamIdInfoFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChunkOrStreamIdInfoFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> CreateChunkOrStreamIdInfoFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UUIDInfoFB> uuid = 0,
    uint32_t partition_index = 0,
    uint32_t padding = 0) {
  ChunkOrStreamIdInfoFBBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_partition_index(partition_index);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

struct QosOptionsFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QosOptionsFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVICE_ID = 4,
    VT_FLOW_ID = 6,
    VT_ADJUST = 8,
    VT_CACHE_GROUPID = 10,
    VT_NETWORK_PRIORITY = 12
  };
  uint32_t service_id() const {
    return GetField<uint32_t>(VT_SERVICE_ID, 0);
  }
  uint32_t flow_id() const {
    return GetField<uint32_t>(VT_FLOW_ID, 0);
  }
  int32_t adjust() const {
    return GetField<int32_t>(VT_ADJUST, 0);
  }
  uint32_t cache_groupid() const {
    return GetField<uint32_t>(VT_CACHE_GROUPID, 0);
  }
  int32_t network_priority() const {
    return GetField<int32_t>(VT_NETWORK_PRIORITY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SERVICE_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_FLOW_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_ADJUST, 4) &&
           VerifyField<uint32_t>(verifier, VT_CACHE_GROUPID, 4) &&
           VerifyField<int32_t>(verifier, VT_NETWORK_PRIORITY, 4) &&
           verifier.EndTable();
  }
};

struct QosOptionsFBBuilder {
  typedef QosOptionsFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_service_id(uint32_t service_id) {
    fbb_.AddElement<uint32_t>(QosOptionsFB::VT_SERVICE_ID, service_id, 0);
  }
  void add_flow_id(uint32_t flow_id) {
    fbb_.AddElement<uint32_t>(QosOptionsFB::VT_FLOW_ID, flow_id, 0);
  }
  void add_adjust(int32_t adjust) {
    fbb_.AddElement<int32_t>(QosOptionsFB::VT_ADJUST, adjust, 0);
  }
  void add_cache_groupid(uint32_t cache_groupid) {
    fbb_.AddElement<uint32_t>(QosOptionsFB::VT_CACHE_GROUPID, cache_groupid, 0);
  }
  void add_network_priority(int32_t network_priority) {
    fbb_.AddElement<int32_t>(QosOptionsFB::VT_NETWORK_PRIORITY, network_priority, 0);
  }
  explicit QosOptionsFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QosOptionsFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QosOptionsFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QosOptionsFB> CreateQosOptionsFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t service_id = 0,
    uint32_t flow_id = 0,
    int32_t adjust = 0,
    uint32_t cache_groupid = 0,
    int32_t network_priority = 0) {
  QosOptionsFBBuilder builder_(_fbb);
  builder_.add_network_priority(network_priority);
  builder_.add_cache_groupid(cache_groupid);
  builder_.add_adjust(adjust);
  builder_.add_flow_id(flow_id);
  builder_.add_service_id(service_id);
  return builder_.Finish();
}

struct FlushChecksumFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlushChecksumFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CATEGORY = 4,
    VT_VALUE = 6
  };
  uint32_t category() const {
    return GetField<uint32_t>(VT_CATEGORY, 0);
  }
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CATEGORY, 4) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct FlushChecksumFBBuilder {
  typedef FlushChecksumFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_category(uint32_t category) {
    fbb_.AddElement<uint32_t>(FlushChecksumFB::VT_CATEGORY, category, 0);
  }
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(FlushChecksumFB::VT_VALUE, value, 0);
  }
  explicit FlushChecksumFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlushChecksumFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlushChecksumFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlushChecksumFB> CreateFlushChecksumFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t category = 0,
    int64_t value = 0) {
  FlushChecksumFBBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_category(category);
  return builder_.Finish();
}

struct UUIDInfoFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UUIDInfoFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW = 4,
    VT_HIGH = 6
  };
  uint64_t low() const {
    return GetField<uint64_t>(VT_LOW, 0);
  }
  uint64_t high() const {
    return GetField<uint64_t>(VT_HIGH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOW, 8) &&
           VerifyField<uint64_t>(verifier, VT_HIGH, 8) &&
           verifier.EndTable();
  }
};

struct UUIDInfoFBBuilder {
  typedef UUIDInfoFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_low(uint64_t low) {
    fbb_.AddElement<uint64_t>(UUIDInfoFB::VT_LOW, low, 0);
  }
  void add_high(uint64_t high) {
    fbb_.AddElement<uint64_t>(UUIDInfoFB::VT_HIGH, high, 0);
  }
  explicit UUIDInfoFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UUIDInfoFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UUIDInfoFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UUIDInfoFB> CreateUUIDInfoFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t low = 0,
    uint64_t high = 0) {
  UUIDInfoFBBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  return builder_.Finish();
}

struct RootServerIdFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RootServerIdFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_LEADER_TERM = 6
  };
  const UUIDInfoFB *uuid() const {
    return GetPointer<const UUIDInfoFB *>(VT_UUID);
  }
  int64_t leader_term() const {
    return GetField<int64_t>(VT_LEADER_TERM, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyTable(uuid()) &&
           VerifyField<int64_t>(verifier, VT_LEADER_TERM, 8) &&
           verifier.EndTable();
  }
};

struct RootServerIdFBBuilder {
  typedef RootServerIdFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(::flatbuffers::Offset<UUIDInfoFB> uuid) {
    fbb_.AddOffset(RootServerIdFB::VT_UUID, uuid);
  }
  void add_leader_term(int64_t leader_term) {
    fbb_.AddElement<int64_t>(RootServerIdFB::VT_LEADER_TERM, leader_term, 0);
  }
  explicit RootServerIdFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RootServerIdFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RootServerIdFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RootServerIdFB> CreateRootServerIdFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UUIDInfoFB> uuid = 0,
    int64_t leader_term = 0) {
  RootServerIdFBBuilder builder_(_fbb);
  builder_.add_leader_term(leader_term);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

struct ChunkIdTypeCJFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkIdTypeCJFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BELONGED_FILEID = 4,
    VT_CHUNK_INDEX = 6,
    VT_PADDING = 8
  };
  uint64_t belonged_fileid() const {
    return GetField<uint64_t>(VT_BELONGED_FILEID, 0);
  }
  uint32_t chunk_index() const {
    return GetField<uint32_t>(VT_CHUNK_INDEX, 0);
  }
  uint32_t padding() const {
    return GetField<uint32_t>(VT_PADDING, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BELONGED_FILEID, 8) &&
           VerifyField<uint32_t>(verifier, VT_CHUNK_INDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
};

struct ChunkIdTypeCJFBBuilder {
  typedef ChunkIdTypeCJFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_belonged_fileid(uint64_t belonged_fileid) {
    fbb_.AddElement<uint64_t>(ChunkIdTypeCJFB::VT_BELONGED_FILEID, belonged_fileid, 0);
  }
  void add_chunk_index(uint32_t chunk_index) {
    fbb_.AddElement<uint32_t>(ChunkIdTypeCJFB::VT_CHUNK_INDEX, chunk_index, 0);
  }
  void add_padding(uint32_t padding) {
    fbb_.AddElement<uint32_t>(ChunkIdTypeCJFB::VT_PADDING, padding, 0);
  }
  explicit ChunkIdTypeCJFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChunkIdTypeCJFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChunkIdTypeCJFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChunkIdTypeCJFB> CreateChunkIdTypeCJFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t belonged_fileid = 0,
    uint32_t chunk_index = 0,
    uint32_t padding = 0) {
  ChunkIdTypeCJFBBuilder builder_(_fbb);
  builder_.add_belonged_fileid(belonged_fileid);
  builder_.add_padding(padding);
  builder_.add_chunk_index(chunk_index);
  return builder_.Finish();
}

struct PanguTraceSpanInfoFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PanguTraceSpanInfoFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACE_ID_LOW = 4,
    VT_TRACE_ID_HIGH = 6,
    VT_SPAN_ID = 8
  };
  uint64_t trace_id_low() const {
    return GetField<uint64_t>(VT_TRACE_ID_LOW, 0);
  }
  uint64_t trace_id_high() const {
    return GetField<uint64_t>(VT_TRACE_ID_HIGH, 0);
  }
  uint64_t span_id() const {
    return GetField<uint64_t>(VT_SPAN_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TRACE_ID_LOW, 8) &&
           VerifyField<uint64_t>(verifier, VT_TRACE_ID_HIGH, 8) &&
           VerifyField<uint64_t>(verifier, VT_SPAN_ID, 8) &&
           verifier.EndTable();
  }
};

struct PanguTraceSpanInfoFBBuilder {
  typedef PanguTraceSpanInfoFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_trace_id_low(uint64_t trace_id_low) {
    fbb_.AddElement<uint64_t>(PanguTraceSpanInfoFB::VT_TRACE_ID_LOW, trace_id_low, 0);
  }
  void add_trace_id_high(uint64_t trace_id_high) {
    fbb_.AddElement<uint64_t>(PanguTraceSpanInfoFB::VT_TRACE_ID_HIGH, trace_id_high, 0);
  }
  void add_span_id(uint64_t span_id) {
    fbb_.AddElement<uint64_t>(PanguTraceSpanInfoFB::VT_SPAN_ID, span_id, 0);
  }
  explicit PanguTraceSpanInfoFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PanguTraceSpanInfoFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PanguTraceSpanInfoFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PanguTraceSpanInfoFB> CreatePanguTraceSpanInfoFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t trace_id_low = 0,
    uint64_t trace_id_high = 0,
    uint64_t span_id = 0) {
  PanguTraceSpanInfoFBBuilder builder_(_fbb);
  builder_.add_span_id(span_id);
  builder_.add_trace_id_high(trace_id_high);
  builder_.add_trace_id_low(trace_id_low);
  return builder_.Finish();
}

struct CsChooseDiskStrategySingleCJFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CsChooseDiskStrategySingleCJFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_WEIGHT = 6,
    VT_PARAMETER = 8
  };
  uint32_t method() const {
    return GetField<uint32_t>(VT_METHOD, 0);
  }
  uint32_t weight() const {
    return GetField<uint32_t>(VT_WEIGHT, 0);
  }
  uint64_t parameter() const {
    return GetField<uint64_t>(VT_PARAMETER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_METHOD, 4) &&
           VerifyField<uint32_t>(verifier, VT_WEIGHT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PARAMETER, 8) &&
           verifier.EndTable();
  }
};

struct CsChooseDiskStrategySingleCJFBBuilder {
  typedef CsChooseDiskStrategySingleCJFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_method(uint32_t method) {
    fbb_.AddElement<uint32_t>(CsChooseDiskStrategySingleCJFB::VT_METHOD, method, 0);
  }
  void add_weight(uint32_t weight) {
    fbb_.AddElement<uint32_t>(CsChooseDiskStrategySingleCJFB::VT_WEIGHT, weight, 0);
  }
  void add_parameter(uint64_t parameter) {
    fbb_.AddElement<uint64_t>(CsChooseDiskStrategySingleCJFB::VT_PARAMETER, parameter, 0);
  }
  explicit CsChooseDiskStrategySingleCJFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB> CreateCsChooseDiskStrategySingleCJFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t method = 0,
    uint32_t weight = 0,
    uint64_t parameter = 0) {
  CsChooseDiskStrategySingleCJFBBuilder builder_(_fbb);
  builder_.add_parameter(parameter);
  builder_.add_weight(weight);
  builder_.add_method(method);
  return builder_.Finish();
}

struct FlatLogFileFlushChunkRequestFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatLogFileFlushChunkRequestFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNK_ID = 4,
    VT_OFFSET = 6,
    VT_LENGTH = 8,
    VT_STORAGE_ID = 10,
    VT_DATA = 12,
    VT_HINT = 14,
    VT_IS_REPLICATION = 16,
    VT_TRACE_OPEN = 18,
    VT_IO_NICE = 20,
    VT_OPEN_CHUNKOPTIONS = 22,
    VT_OPEN_MODE = 24,
    VT_HANDLE = 26,
    VT_DATA_SYNC = 28,
    VT_TRACE_SPAN = 30,
    VT_CREATE_IFNOTEXISTS = 32,
    VT_STRATEGY = 34,
    VT_CHUNK_ID_V2 = 36,
    VT_QOS_OPTIONS = 38,
    VT_CHECKSUM = 40,
    VT_VOLUME_UUID = 42,
    VT_MODULE_VERSION = 44,
    VT_HOSTNAME = 46,
    VT_DISK_ID = 48,
    VT_REQUEST_ID = 50,
    VT_USER_ID = 52,
    VT_ROOT_SERVER_ID = 54,
    VT_REQUIRED_MIN_CSVERSION = 56,
    VT_FROMTYPE = 58,
    VT_OFFSET64 = 60,
    VT_RECORD_SIZE = 62,
    VT_POOL_ID = 64,
    VT_STORAGE_POOL_CONFVERSION = 66,
    VT_A = 68
  };
  const ChunkIdTypeCJFB *chunk_id() const {
    return GetPointer<const ChunkIdTypeCJFB *>(VT_CHUNK_ID);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint32_t length() const {
    return GetField<uint32_t>(VT_LENGTH, 0);
  }
  uint32_t storage_id() const {
    return GetField<uint32_t>(VT_STORAGE_ID, 0);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  uint32_t hint() const {
    return GetField<uint32_t>(VT_HINT, 0);
  }
  bool is_replication() const {
    return GetField<uint8_t>(VT_IS_REPLICATION, 0) != 0;
  }
  bool trace_open() const {
    return GetField<uint8_t>(VT_TRACE_OPEN, 0) != 0;
  }
  const IONiceFB *io_nice() const {
    return GetPointer<const IONiceFB *>(VT_IO_NICE);
  }
  const AccelerateOpenOptionsFB *open_chunkoptions() const {
    return GetPointer<const AccelerateOpenOptionsFB *>(VT_OPEN_CHUNKOPTIONS);
  }
  int32_t open_mode() const {
    return GetField<int32_t>(VT_OPEN_MODE, 0);
  }
  int64_t handle() const {
    return GetField<int64_t>(VT_HANDLE, 0);
  }
  bool data_sync() const {
    return GetField<uint8_t>(VT_DATA_SYNC, 0) != 0;
  }
  const PanguTraceSpanInfoFB *trace_span() const {
    return GetPointer<const PanguTraceSpanInfoFB *>(VT_TRACE_SPAN);
  }
  bool create_ifnotexists() const {
    return GetField<uint8_t>(VT_CREATE_IFNOTEXISTS, 0) != 0;
  }
  const CsChooseDiskStrategyCJFB *strategy() const {
    return GetPointer<const CsChooseDiskStrategyCJFB *>(VT_STRATEGY);
  }
  const ChunkOrStreamIdInfoFB *chunk_id_v2() const {
    return GetPointer<const ChunkOrStreamIdInfoFB *>(VT_CHUNK_ID_V2);
  }
  const QosOptionsFB *qos_options() const {
    return GetPointer<const QosOptionsFB *>(VT_QOS_OPTIONS);
  }
  const FlushChecksumFB *checksum() const {
    return GetPointer<const FlushChecksumFB *>(VT_CHECKSUM);
  }
  const UUIDInfoFB *volume_uuid() const {
    return GetPointer<const UUIDInfoFB *>(VT_VOLUME_UUID);
  }
  uint32_t module_version() const {
    return GetField<uint32_t>(VT_MODULE_VERSION, 0);
  }
  const ::flatbuffers::String *hostname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOSTNAME);
  }
  uint32_t disk_id() const {
    return GetField<uint32_t>(VT_DISK_ID, 0);
  }
  uint64_t request_id() const {
    return GetField<uint64_t>(VT_REQUEST_ID, 0);
  }
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  const RootServerIdFB *root_server_id() const {
    return GetPointer<const RootServerIdFB *>(VT_ROOT_SERVER_ID);
  }
  uint32_t required_min_csversion() const {
    return GetField<uint32_t>(VT_REQUIRED_MIN_CSVERSION, 0);
  }
  int32_t fromtype() const {
    return GetField<int32_t>(VT_FROMTYPE, 0);
  }
  uint64_t offset64() const {
    return GetField<uint64_t>(VT_OFFSET64, 0);
  }
  uint32_t record_size() const {
    return GetField<uint32_t>(VT_RECORD_SIZE, 0);
  }
  uint32_t pool_id() const {
    return GetField<uint32_t>(VT_POOL_ID, 0);
  }
  uint64_t storage_pool_confversion() const {
    return GetField<uint64_t>(VT_STORAGE_POOL_CONFVERSION, 0);
  }
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNK_ID) &&
           verifier.VerifyTable(chunk_id()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_LENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_STORAGE_ID, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           VerifyField<uint32_t>(verifier, VT_HINT, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_REPLICATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRACE_OPEN, 1) &&
           VerifyOffset(verifier, VT_IO_NICE) &&
           verifier.VerifyTable(io_nice()) &&
           VerifyOffset(verifier, VT_OPEN_CHUNKOPTIONS) &&
           verifier.VerifyTable(open_chunkoptions()) &&
           VerifyField<int32_t>(verifier, VT_OPEN_MODE, 4) &&
           VerifyField<int64_t>(verifier, VT_HANDLE, 8) &&
           VerifyField<uint8_t>(verifier, VT_DATA_SYNC, 1) &&
           VerifyOffset(verifier, VT_TRACE_SPAN) &&
           verifier.VerifyTable(trace_span()) &&
           VerifyField<uint8_t>(verifier, VT_CREATE_IFNOTEXISTS, 1) &&
           VerifyOffset(verifier, VT_STRATEGY) &&
           verifier.VerifyTable(strategy()) &&
           VerifyOffset(verifier, VT_CHUNK_ID_V2) &&
           verifier.VerifyTable(chunk_id_v2()) &&
           VerifyOffset(verifier, VT_QOS_OPTIONS) &&
           verifier.VerifyTable(qos_options()) &&
           VerifyOffset(verifier, VT_CHECKSUM) &&
           verifier.VerifyTable(checksum()) &&
           VerifyOffset(verifier, VT_VOLUME_UUID) &&
           verifier.VerifyTable(volume_uuid()) &&
           VerifyField<uint32_t>(verifier, VT_MODULE_VERSION, 4) &&
           VerifyOffset(verifier, VT_HOSTNAME) &&
           verifier.VerifyString(hostname()) &&
           VerifyField<uint32_t>(verifier, VT_DISK_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_REQUEST_ID, 8) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyOffset(verifier, VT_ROOT_SERVER_ID) &&
           verifier.VerifyTable(root_server_id()) &&
           VerifyField<uint32_t>(verifier, VT_REQUIRED_MIN_CSVERSION, 4) &&
           VerifyField<int32_t>(verifier, VT_FROMTYPE, 4) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET64, 8) &&
           VerifyField<uint32_t>(verifier, VT_RECORD_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_POOL_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_STORAGE_POOL_CONFVERSION, 8) &&
           VerifyField<int32_t>(verifier, VT_A, 4) &&
           verifier.EndTable();
  }
};

struct FlatLogFileFlushChunkRequestFBBuilder {
  typedef FlatLogFileFlushChunkRequestFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chunk_id(::flatbuffers::Offset<ChunkIdTypeCJFB> chunk_id) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_CHUNK_ID, chunk_id);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_OFFSET, offset, 0);
  }
  void add_length(uint32_t length) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_LENGTH, length, 0);
  }
  void add_storage_id(uint32_t storage_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_STORAGE_ID, storage_id, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_DATA, data);
  }
  void add_hint(uint32_t hint) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_HINT, hint, 0);
  }
  void add_is_replication(bool is_replication) {
    fbb_.AddElement<uint8_t>(FlatLogFileFlushChunkRequestFB::VT_IS_REPLICATION, static_cast<uint8_t>(is_replication), 0);
  }
  void add_trace_open(bool trace_open) {
    fbb_.AddElement<uint8_t>(FlatLogFileFlushChunkRequestFB::VT_TRACE_OPEN, static_cast<uint8_t>(trace_open), 0);
  }
  void add_io_nice(::flatbuffers::Offset<IONiceFB> io_nice) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_IO_NICE, io_nice);
  }
  void add_open_chunkoptions(::flatbuffers::Offset<AccelerateOpenOptionsFB> open_chunkoptions) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_OPEN_CHUNKOPTIONS, open_chunkoptions);
  }
  void add_open_mode(int32_t open_mode) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkRequestFB::VT_OPEN_MODE, open_mode, 0);
  }
  void add_handle(int64_t handle) {
    fbb_.AddElement<int64_t>(FlatLogFileFlushChunkRequestFB::VT_HANDLE, handle, 0);
  }
  void add_data_sync(bool data_sync) {
    fbb_.AddElement<uint8_t>(FlatLogFileFlushChunkRequestFB::VT_DATA_SYNC, static_cast<uint8_t>(data_sync), 0);
  }
  void add_trace_span(::flatbuffers::Offset<PanguTraceSpanInfoFB> trace_span) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_TRACE_SPAN, trace_span);
  }
  void add_create_ifnotexists(bool create_ifnotexists) {
    fbb_.AddElement<uint8_t>(FlatLogFileFlushChunkRequestFB::VT_CREATE_IFNOTEXISTS, static_cast<uint8_t>(create_ifnotexists), 0);
  }
  void add_strategy(::flatbuffers::Offset<CsChooseDiskStrategyCJFB> strategy) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_STRATEGY, strategy);
  }
  void add_chunk_id_v2(::flatbuffers::Offset<ChunkOrStreamIdInfoFB> chunk_id_v2) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_CHUNK_ID_V2, chunk_id_v2);
  }
  void add_qos_options(::flatbuffers::Offset<QosOptionsFB> qos_options) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_QOS_OPTIONS, qos_options);
  }
  void add_checksum(::flatbuffers::Offset<FlushChecksumFB> checksum) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_CHECKSUM, checksum);
  }
  void add_volume_uuid(::flatbuffers::Offset<UUIDInfoFB> volume_uuid) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_VOLUME_UUID, volume_uuid);
  }
  void add_module_version(uint32_t module_version) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_MODULE_VERSION, module_version, 0);
  }
  void add_hostname(::flatbuffers::Offset<::flatbuffers::String> hostname) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_HOSTNAME, hostname);
  }
  void add_disk_id(uint32_t disk_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_DISK_ID, disk_id, 0);
  }
  void add_request_id(uint64_t request_id) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkRequestFB::VT_REQUEST_ID, request_id, 0);
  }
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_USER_ID, user_id);
  }
  void add_root_server_id(::flatbuffers::Offset<RootServerIdFB> root_server_id) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_ROOT_SERVER_ID, root_server_id);
  }
  void add_required_min_csversion(uint32_t required_min_csversion) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_REQUIRED_MIN_CSVERSION, required_min_csversion, 0);
  }
  void add_fromtype(int32_t fromtype) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkRequestFB::VT_FROMTYPE, fromtype, 0);
  }
  void add_offset64(uint64_t offset64) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkRequestFB::VT_OFFSET64, offset64, 0);
  }
  void add_record_size(uint32_t record_size) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_RECORD_SIZE, record_size, 0);
  }
  void add_pool_id(uint32_t pool_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_POOL_ID, pool_id, 0);
  }
  void add_storage_pool_confversion(uint64_t storage_pool_confversion) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkRequestFB::VT_STORAGE_POOL_CONFVERSION, storage_pool_confversion, 0);
  }
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkRequestFB::VT_A, a, 0);
  }
  explicit FlatLogFileFlushChunkRequestFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> CreateFlatLogFileFlushChunkRequestFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChunkIdTypeCJFB> chunk_id = 0,
    uint32_t offset = 0,
    uint32_t length = 0,
    uint32_t storage_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0,
    uint32_t hint = 0,
    bool is_replication = false,
    bool trace_open = false,
    ::flatbuffers::Offset<IONiceFB> io_nice = 0,
    ::flatbuffers::Offset<AccelerateOpenOptionsFB> open_chunkoptions = 0,
    int32_t open_mode = 0,
    int64_t handle = 0,
    bool data_sync = false,
    ::flatbuffers::Offset<PanguTraceSpanInfoFB> trace_span = 0,
    bool create_ifnotexists = false,
    ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> strategy = 0,
    ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> chunk_id_v2 = 0,
    ::flatbuffers::Offset<QosOptionsFB> qos_options = 0,
    ::flatbuffers::Offset<FlushChecksumFB> checksum = 0,
    ::flatbuffers::Offset<UUIDInfoFB> volume_uuid = 0,
    uint32_t module_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hostname = 0,
    uint32_t disk_id = 0,
    uint64_t request_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    ::flatbuffers::Offset<RootServerIdFB> root_server_id = 0,
    uint32_t required_min_csversion = 0,
    int32_t fromtype = 0,
    uint64_t offset64 = 0,
    uint32_t record_size = 0,
    uint32_t pool_id = 0,
    uint64_t storage_pool_confversion = 0,
    int32_t a = 0) {
  FlatLogFileFlushChunkRequestFBBuilder builder_(_fbb);
  builder_.add_storage_pool_confversion(storage_pool_confversion);
  builder_.add_offset64(offset64);
  builder_.add_request_id(request_id);
  builder_.add_handle(handle);
  builder_.add_a(a);
  builder_.add_pool_id(pool_id);
  builder_.add_record_size(record_size);
  builder_.add_fromtype(fromtype);
  builder_.add_required_min_csversion(required_min_csversion);
  builder_.add_root_server_id(root_server_id);
  builder_.add_user_id(user_id);
  builder_.add_disk_id(disk_id);
  builder_.add_hostname(hostname);
  builder_.add_module_version(module_version);
  builder_.add_volume_uuid(volume_uuid);
  builder_.add_checksum(checksum);
  builder_.add_qos_options(qos_options);
  builder_.add_chunk_id_v2(chunk_id_v2);
  builder_.add_strategy(strategy);
  builder_.add_trace_span(trace_span);
  builder_.add_open_mode(open_mode);
  builder_.add_open_chunkoptions(open_chunkoptions);
  builder_.add_io_nice(io_nice);
  builder_.add_hint(hint);
  builder_.add_data(data);
  builder_.add_storage_id(storage_id);
  builder_.add_length(length);
  builder_.add_offset(offset);
  builder_.add_chunk_id(chunk_id);
  builder_.add_create_ifnotexists(create_ifnotexists);
  builder_.add_data_sync(data_sync);
  builder_.add_trace_open(trace_open);
  builder_.add_is_replication(is_replication);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> CreateFlatLogFileFlushChunkRequestFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChunkIdTypeCJFB> chunk_id = 0,
    uint32_t offset = 0,
    uint32_t length = 0,
    uint32_t storage_id = 0,
    const char *data = nullptr,
    uint32_t hint = 0,
    bool is_replication = false,
    bool trace_open = false,
    ::flatbuffers::Offset<IONiceFB> io_nice = 0,
    ::flatbuffers::Offset<AccelerateOpenOptionsFB> open_chunkoptions = 0,
    int32_t open_mode = 0,
    int64_t handle = 0,
    bool data_sync = false,
    ::flatbuffers::Offset<PanguTraceSpanInfoFB> trace_span = 0,
    bool create_ifnotexists = false,
    ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> strategy = 0,
    ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> chunk_id_v2 = 0,
    ::flatbuffers::Offset<QosOptionsFB> qos_options = 0,
    ::flatbuffers::Offset<FlushChecksumFB> checksum = 0,
    ::flatbuffers::Offset<UUIDInfoFB> volume_uuid = 0,
    uint32_t module_version = 0,
    const char *hostname = nullptr,
    uint32_t disk_id = 0,
    uint64_t request_id = 0,
    const char *user_id = nullptr,
    ::flatbuffers::Offset<RootServerIdFB> root_server_id = 0,
    uint32_t required_min_csversion = 0,
    int32_t fromtype = 0,
    uint64_t offset64 = 0,
    uint32_t record_size = 0,
    uint32_t pool_id = 0,
    uint64_t storage_pool_confversion = 0,
    int32_t a = 0) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  return CreateFlatLogFileFlushChunkRequestFB(
      _fbb,
      chunk_id,
      offset,
      length,
      storage_id,
      data__,
      hint,
      is_replication,
      trace_open,
      io_nice,
      open_chunkoptions,
      open_mode,
      handle,
      data_sync,
      trace_span,
      create_ifnotexists,
      strategy,
      chunk_id_v2,
      qos_options,
      checksum,
      volume_uuid,
      module_version,
      hostname__,
      disk_id,
      request_id,
      user_id__,
      root_server_id,
      required_min_csversion,
      fromtype,
      offset64,
      record_size,
      pool_id,
      storage_pool_confversion,
      a);
}

struct FlatLogFileFlushChunkResponseFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatLogFileFlushChunkResponseFBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4,
    VT_CHUNK_STATUS = 6,
    VT_HINT = 8,
    VT_ACK_LENGTH = 10,
    VT_TRACE_TYPE = 12,
    VT_TRACE_DATA = 14,
    VT_HANDLE = 16,
    VT_STORAGE_ID = 18,
    VT_DISK_ID = 20,
    VT_REQUEST_ID = 22,
    VT_CHECKSUM = 24,
    VT_LEFT_REPLICA_SIZE = 26,
    VT_A = 28
  };
  int32_t errorcode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  uint32_t chunk_status() const {
    return GetField<uint32_t>(VT_CHUNK_STATUS, 0);
  }
  uint32_t hint() const {
    return GetField<uint32_t>(VT_HINT, 0);
  }
  uint32_t ack_length() const {
    return GetField<uint32_t>(VT_ACK_LENGTH, 0);
  }
  uint32_t trace_type() const {
    return GetField<uint32_t>(VT_TRACE_TYPE, 0);
  }
  const ::flatbuffers::String *trace_data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACE_DATA);
  }
  int64_t handle() const {
    return GetField<int64_t>(VT_HANDLE, 0);
  }
  uint32_t storage_id() const {
    return GetField<uint32_t>(VT_STORAGE_ID, 0);
  }
  uint32_t disk_id() const {
    return GetField<uint32_t>(VT_DISK_ID, 0);
  }
  uint64_t request_id() const {
    return GetField<uint64_t>(VT_REQUEST_ID, 0);
  }
  int64_t checksum() const {
    return GetField<int64_t>(VT_CHECKSUM, 0);
  }
  uint64_t left_replica_size() const {
    return GetField<uint64_t>(VT_LEFT_REPLICA_SIZE, 0);
  }
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHUNK_STATUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_HINT, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACK_LENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_TRACE_TYPE, 4) &&
           VerifyOffset(verifier, VT_TRACE_DATA) &&
           verifier.VerifyString(trace_data()) &&
           VerifyField<int64_t>(verifier, VT_HANDLE, 8) &&
           VerifyField<uint32_t>(verifier, VT_STORAGE_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_DISK_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_REQUEST_ID, 8) &&
           VerifyField<int64_t>(verifier, VT_CHECKSUM, 8) &&
           VerifyField<uint64_t>(verifier, VT_LEFT_REPLICA_SIZE, 8) &&
           VerifyField<int32_t>(verifier, VT_A, 4) &&
           verifier.EndTable();
  }
};

struct FlatLogFileFlushChunkResponseFBBuilder {
  typedef FlatLogFileFlushChunkResponseFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(int32_t errorcode) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkResponseFB::VT_ERRORCODE, errorcode, 0);
  }
  void add_chunk_status(uint32_t chunk_status) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_CHUNK_STATUS, chunk_status, 0);
  }
  void add_hint(uint32_t hint) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_HINT, hint, 0);
  }
  void add_ack_length(uint32_t ack_length) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_ACK_LENGTH, ack_length, 0);
  }
  void add_trace_type(uint32_t trace_type) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_TRACE_TYPE, trace_type, 0);
  }
  void add_trace_data(::flatbuffers::Offset<::flatbuffers::String> trace_data) {
    fbb_.AddOffset(FlatLogFileFlushChunkResponseFB::VT_TRACE_DATA, trace_data);
  }
  void add_handle(int64_t handle) {
    fbb_.AddElement<int64_t>(FlatLogFileFlushChunkResponseFB::VT_HANDLE, handle, 0);
  }
  void add_storage_id(uint32_t storage_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_STORAGE_ID, storage_id, 0);
  }
  void add_disk_id(uint32_t disk_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_DISK_ID, disk_id, 0);
  }
  void add_request_id(uint64_t request_id) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkResponseFB::VT_REQUEST_ID, request_id, 0);
  }
  void add_checksum(int64_t checksum) {
    fbb_.AddElement<int64_t>(FlatLogFileFlushChunkResponseFB::VT_CHECKSUM, checksum, 0);
  }
  void add_left_replica_size(uint64_t left_replica_size) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkResponseFB::VT_LEFT_REPLICA_SIZE, left_replica_size, 0);
  }
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkResponseFB::VT_A, a, 0);
  }
  explicit FlatLogFileFlushChunkResponseFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> CreateFlatLogFileFlushChunkResponseFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    uint32_t chunk_status = 0,
    uint32_t hint = 0,
    uint32_t ack_length = 0,
    uint32_t trace_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trace_data = 0,
    int64_t handle = 0,
    uint32_t storage_id = 0,
    uint32_t disk_id = 0,
    uint64_t request_id = 0,
    int64_t checksum = 0,
    uint64_t left_replica_size = 0,
    int32_t a = 0) {
  FlatLogFileFlushChunkResponseFBBuilder builder_(_fbb);
  builder_.add_left_replica_size(left_replica_size);
  builder_.add_checksum(checksum);
  builder_.add_request_id(request_id);
  builder_.add_handle(handle);
  builder_.add_a(a);
  builder_.add_disk_id(disk_id);
  builder_.add_storage_id(storage_id);
  builder_.add_trace_data(trace_data);
  builder_.add_trace_type(trace_type);
  builder_.add_ack_length(ack_length);
  builder_.add_hint(hint);
  builder_.add_chunk_status(chunk_status);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> CreateFlatLogFileFlushChunkResponseFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    uint32_t chunk_status = 0,
    uint32_t hint = 0,
    uint32_t ack_length = 0,
    uint32_t trace_type = 0,
    const char *trace_data = nullptr,
    int64_t handle = 0,
    uint32_t storage_id = 0,
    uint32_t disk_id = 0,
    uint64_t request_id = 0,
    int64_t checksum = 0,
    uint64_t left_replica_size = 0,
    int32_t a = 0) {
  auto trace_data__ = trace_data ? _fbb.CreateString(trace_data) : 0;
  return CreateFlatLogFileFlushChunkResponseFB(
      _fbb,
      errorcode,
      chunk_status,
      hint,
      ack_length,
      trace_type,
      trace_data__,
      handle,
      storage_id,
      disk_id,
      request_id,
      checksum,
      left_replica_size,
      a);
}

#endif  // FLATBUFFERS_GENERATED_GREETER_H_
