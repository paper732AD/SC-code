// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021011 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flat_2eproto;
namespace test {
class AccelerateOpenOptionsPB;
struct AccelerateOpenOptionsPBDefaultTypeInternal;
extern AccelerateOpenOptionsPBDefaultTypeInternal _AccelerateOpenOptionsPB_default_instance_;
class ChunkIdTypeCJPB;
struct ChunkIdTypeCJPBDefaultTypeInternal;
extern ChunkIdTypeCJPBDefaultTypeInternal _ChunkIdTypeCJPB_default_instance_;
class ChunkOptionsPB;
struct ChunkOptionsPBDefaultTypeInternal;
extern ChunkOptionsPBDefaultTypeInternal _ChunkOptionsPB_default_instance_;
class ChunkOrStreamIdInfoPB;
struct ChunkOrStreamIdInfoPBDefaultTypeInternal;
extern ChunkOrStreamIdInfoPBDefaultTypeInternal _ChunkOrStreamIdInfoPB_default_instance_;
class CsChooseDiskStrategyCJPB;
struct CsChooseDiskStrategyCJPBDefaultTypeInternal;
extern CsChooseDiskStrategyCJPBDefaultTypeInternal _CsChooseDiskStrategyCJPB_default_instance_;
class CsChooseDiskStrategySingleCJPB;
struct CsChooseDiskStrategySingleCJPBDefaultTypeInternal;
extern CsChooseDiskStrategySingleCJPBDefaultTypeInternal _CsChooseDiskStrategySingleCJPB_default_instance_;
class FixedUUIDInfoPB;
struct FixedUUIDInfoPBDefaultTypeInternal;
extern FixedUUIDInfoPBDefaultTypeInternal _FixedUUIDInfoPB_default_instance_;
class FlatLogFileFlushChunkRequestPB;
struct FlatLogFileFlushChunkRequestPBDefaultTypeInternal;
extern FlatLogFileFlushChunkRequestPBDefaultTypeInternal _FlatLogFileFlushChunkRequestPB_default_instance_;
class FlatLogFileFlushChunkResponsePB;
struct FlatLogFileFlushChunkResponsePBDefaultTypeInternal;
extern FlatLogFileFlushChunkResponsePBDefaultTypeInternal _FlatLogFileFlushChunkResponsePB_default_instance_;
class FlushChecksumPB;
struct FlushChecksumPBDefaultTypeInternal;
extern FlushChecksumPBDefaultTypeInternal _FlushChecksumPB_default_instance_;
class IONicePB;
struct IONicePBDefaultTypeInternal;
extern IONicePBDefaultTypeInternal _IONicePB_default_instance_;
class MirrorArgsPB;
struct MirrorArgsPBDefaultTypeInternal;
extern MirrorArgsPBDefaultTypeInternal _MirrorArgsPB_default_instance_;
class PanguTraceSpanInfo;
struct PanguTraceSpanInfoDefaultTypeInternal;
extern PanguTraceSpanInfoDefaultTypeInternal _PanguTraceSpanInfo_default_instance_;
class QosOptionsPB;
struct QosOptionsPBDefaultTypeInternal;
extern QosOptionsPBDefaultTypeInternal _QosOptionsPB_default_instance_;
class ReplicaLocationPB;
struct ReplicaLocationPBDefaultTypeInternal;
extern ReplicaLocationPBDefaultTypeInternal _ReplicaLocationPB_default_instance_;
class RootServerIdPB;
struct RootServerIdPBDefaultTypeInternal;
extern RootServerIdPBDefaultTypeInternal _RootServerIdPB_default_instance_;
class UUIDInfoPB;
struct UUIDInfoPBDefaultTypeInternal;
extern UUIDInfoPBDefaultTypeInternal _UUIDInfoPB_default_instance_;
}  // namespace test
PROTOBUF_NAMESPACE_OPEN
template<> ::test::AccelerateOpenOptionsPB* Arena::CreateMaybeMessage<::test::AccelerateOpenOptionsPB>(Arena*);
template<> ::test::ChunkIdTypeCJPB* Arena::CreateMaybeMessage<::test::ChunkIdTypeCJPB>(Arena*);
template<> ::test::ChunkOptionsPB* Arena::CreateMaybeMessage<::test::ChunkOptionsPB>(Arena*);
template<> ::test::ChunkOrStreamIdInfoPB* Arena::CreateMaybeMessage<::test::ChunkOrStreamIdInfoPB>(Arena*);
template<> ::test::CsChooseDiskStrategyCJPB* Arena::CreateMaybeMessage<::test::CsChooseDiskStrategyCJPB>(Arena*);
template<> ::test::CsChooseDiskStrategySingleCJPB* Arena::CreateMaybeMessage<::test::CsChooseDiskStrategySingleCJPB>(Arena*);
template<> ::test::FixedUUIDInfoPB* Arena::CreateMaybeMessage<::test::FixedUUIDInfoPB>(Arena*);
template<> ::test::FlatLogFileFlushChunkRequestPB* Arena::CreateMaybeMessage<::test::FlatLogFileFlushChunkRequestPB>(Arena*);
template<> ::test::FlatLogFileFlushChunkResponsePB* Arena::CreateMaybeMessage<::test::FlatLogFileFlushChunkResponsePB>(Arena*);
template<> ::test::FlushChecksumPB* Arena::CreateMaybeMessage<::test::FlushChecksumPB>(Arena*);
template<> ::test::IONicePB* Arena::CreateMaybeMessage<::test::IONicePB>(Arena*);
template<> ::test::MirrorArgsPB* Arena::CreateMaybeMessage<::test::MirrorArgsPB>(Arena*);
template<> ::test::PanguTraceSpanInfo* Arena::CreateMaybeMessage<::test::PanguTraceSpanInfo>(Arena*);
template<> ::test::QosOptionsPB* Arena::CreateMaybeMessage<::test::QosOptionsPB>(Arena*);
template<> ::test::ReplicaLocationPB* Arena::CreateMaybeMessage<::test::ReplicaLocationPB>(Arena*);
template<> ::test::RootServerIdPB* Arena::CreateMaybeMessage<::test::RootServerIdPB>(Arena*);
template<> ::test::UUIDInfoPB* Arena::CreateMaybeMessage<::test::UUIDInfoPB>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace test {

enum QosOptionsPB_AdjustType : int {
  QosOptionsPB_AdjustType_KEEP = 0,
  QosOptionsPB_AdjustType_LOWER = -1,
  QosOptionsPB_AdjustType_HIGHER = 1
};
bool QosOptionsPB_AdjustType_IsValid(int value);
constexpr QosOptionsPB_AdjustType QosOptionsPB_AdjustType_AdjustType_MIN = QosOptionsPB_AdjustType_LOWER;
constexpr QosOptionsPB_AdjustType QosOptionsPB_AdjustType_AdjustType_MAX = QosOptionsPB_AdjustType_HIGHER;
constexpr int QosOptionsPB_AdjustType_AdjustType_ARRAYSIZE = QosOptionsPB_AdjustType_AdjustType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QosOptionsPB_AdjustType_descriptor();
template<typename T>
inline const std::string& QosOptionsPB_AdjustType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QosOptionsPB_AdjustType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QosOptionsPB_AdjustType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QosOptionsPB_AdjustType_descriptor(), enum_t_value);
}
inline bool QosOptionsPB_AdjustType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QosOptionsPB_AdjustType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QosOptionsPB_AdjustType>(
    QosOptionsPB_AdjustType_descriptor(), name, value);
}
enum QosOptionsPB_CacheGroupType : int {
  QosOptionsPB_CacheGroupType_NO_CACHE = -1,
  QosOptionsPB_CacheGroupType_DEFAULT = 0,
  QosOptionsPB_CacheGroupType_INTERNAL = 1,
  QosOptionsPB_CacheGroupType_USER_BASE = 100,
  QosOptionsPB_CacheGroupType_USER_0 = 101,
  QosOptionsPB_CacheGroupType_USER_1 = 102
};
bool QosOptionsPB_CacheGroupType_IsValid(int value);
constexpr QosOptionsPB_CacheGroupType QosOptionsPB_CacheGroupType_CacheGroupType_MIN = QosOptionsPB_CacheGroupType_NO_CACHE;
constexpr QosOptionsPB_CacheGroupType QosOptionsPB_CacheGroupType_CacheGroupType_MAX = QosOptionsPB_CacheGroupType_USER_1;
constexpr int QosOptionsPB_CacheGroupType_CacheGroupType_ARRAYSIZE = QosOptionsPB_CacheGroupType_CacheGroupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QosOptionsPB_CacheGroupType_descriptor();
template<typename T>
inline const std::string& QosOptionsPB_CacheGroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QosOptionsPB_CacheGroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QosOptionsPB_CacheGroupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QosOptionsPB_CacheGroupType_descriptor(), enum_t_value);
}
inline bool QosOptionsPB_CacheGroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QosOptionsPB_CacheGroupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QosOptionsPB_CacheGroupType>(
    QosOptionsPB_CacheGroupType_descriptor(), name, value);
}
// ===================================================================

class FixedUUIDInfoPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.FixedUUIDInfoPB) */ {
 public:
  inline FixedUUIDInfoPB() : FixedUUIDInfoPB(nullptr) {}
  ~FixedUUIDInfoPB() override;
  explicit PROTOBUF_CONSTEXPR FixedUUIDInfoPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FixedUUIDInfoPB(const FixedUUIDInfoPB& from);
  FixedUUIDInfoPB(FixedUUIDInfoPB&& from) noexcept
    : FixedUUIDInfoPB() {
    *this = ::std::move(from);
  }

  inline FixedUUIDInfoPB& operator=(const FixedUUIDInfoPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline FixedUUIDInfoPB& operator=(FixedUUIDInfoPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FixedUUIDInfoPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const FixedUUIDInfoPB* internal_default_instance() {
    return reinterpret_cast<const FixedUUIDInfoPB*>(
               &_FixedUUIDInfoPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FixedUUIDInfoPB& a, FixedUUIDInfoPB& b) {
    a.Swap(&b);
  }
  inline void Swap(FixedUUIDInfoPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FixedUUIDInfoPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FixedUUIDInfoPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FixedUUIDInfoPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FixedUUIDInfoPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FixedUUIDInfoPB& from) {
    FixedUUIDInfoPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixedUUIDInfoPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.FixedUUIDInfoPB";
  }
  protected:
  explicit FixedUUIDInfoPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowFieldNumber = 1,
    kHighFieldNumber = 2,
  };
  // optional fixed64 low = 1;
  bool has_low() const;
  private:
  bool _internal_has_low() const;
  public:
  void clear_low();
  uint64_t low() const;
  void set_low(uint64_t value);
  private:
  uint64_t _internal_low() const;
  void _internal_set_low(uint64_t value);
  public:

  // optional fixed64 high = 2;
  bool has_high() const;
  private:
  bool _internal_has_high() const;
  public:
  void clear_high();
  uint64_t high() const;
  void set_high(uint64_t value);
  private:
  uint64_t _internal_high() const;
  void _internal_set_high(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.FixedUUIDInfoPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t low_;
    uint64_t high_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class MirrorArgsPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.MirrorArgsPB) */ {
 public:
  inline MirrorArgsPB() : MirrorArgsPB(nullptr) {}
  ~MirrorArgsPB() override;
  explicit PROTOBUF_CONSTEXPR MirrorArgsPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MirrorArgsPB(const MirrorArgsPB& from);
  MirrorArgsPB(MirrorArgsPB&& from) noexcept
    : MirrorArgsPB() {
    *this = ::std::move(from);
  }

  inline MirrorArgsPB& operator=(const MirrorArgsPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline MirrorArgsPB& operator=(MirrorArgsPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MirrorArgsPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const MirrorArgsPB* internal_default_instance() {
    return reinterpret_cast<const MirrorArgsPB*>(
               &_MirrorArgsPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MirrorArgsPB& a, MirrorArgsPB& b) {
    a.Swap(&b);
  }
  inline void Swap(MirrorArgsPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MirrorArgsPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MirrorArgsPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MirrorArgsPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MirrorArgsPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MirrorArgsPB& from) {
    MirrorArgsPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MirrorArgsPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.MirrorArgsPB";
  }
  protected:
  explicit MirrorArgsPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCopyFieldNumber = 1,
    kFTTFieldNumber = 2,
  };
  // optional int32 Copy = 1;
  bool has_copy() const;
  private:
  bool _internal_has_copy() const;
  public:
  void clear_copy();
  int32_t copy() const;
  void set_copy(int32_t value);
  private:
  int32_t _internal_copy() const;
  void _internal_set_copy(int32_t value);
  public:

  // optional int32 FTT = 2;
  bool has_ftt() const;
  private:
  bool _internal_has_ftt() const;
  public:
  void clear_ftt();
  int32_t ftt() const;
  void set_ftt(int32_t value);
  private:
  int32_t _internal_ftt() const;
  void _internal_set_ftt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.MirrorArgsPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t copy_;
    int32_t ftt_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class ChunkOptionsPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.ChunkOptionsPB) */ {
 public:
  inline ChunkOptionsPB() : ChunkOptionsPB(nullptr) {}
  ~ChunkOptionsPB() override;
  explicit PROTOBUF_CONSTEXPR ChunkOptionsPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChunkOptionsPB(const ChunkOptionsPB& from);
  ChunkOptionsPB(ChunkOptionsPB&& from) noexcept
    : ChunkOptionsPB() {
    *this = ::std::move(from);
  }

  inline ChunkOptionsPB& operator=(const ChunkOptionsPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkOptionsPB& operator=(ChunkOptionsPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkOptionsPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkOptionsPB* internal_default_instance() {
    return reinterpret_cast<const ChunkOptionsPB*>(
               &_ChunkOptionsPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChunkOptionsPB& a, ChunkOptionsPB& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkOptionsPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkOptionsPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkOptionsPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChunkOptionsPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChunkOptionsPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChunkOptionsPB& from) {
    ChunkOptionsPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkOptionsPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.ChunkOptionsPB";
  }
  protected:
  explicit ChunkOptionsPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlacementFieldNumber = 3,
    kMirrorFieldNumber = 2,
    kFTTTypeFieldNumber = 1,
  };
  // optional bytes Placement = 3;
  bool has_placement() const;
  private:
  bool _internal_has_placement() const;
  public:
  void clear_placement();
  const std::string& placement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_placement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_placement();
  PROTOBUF_NODISCARD std::string* release_placement();
  void set_allocated_placement(std::string* placement);
  private:
  const std::string& _internal_placement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placement(const std::string& value);
  std::string* _internal_mutable_placement();
  public:

  // optional .test.MirrorArgsPB Mirror = 2;
  bool has_mirror() const;
  private:
  bool _internal_has_mirror() const;
  public:
  void clear_mirror();
  const ::test::MirrorArgsPB& mirror() const;
  PROTOBUF_NODISCARD ::test::MirrorArgsPB* release_mirror();
  ::test::MirrorArgsPB* mutable_mirror();
  void set_allocated_mirror(::test::MirrorArgsPB* mirror);
  private:
  const ::test::MirrorArgsPB& _internal_mirror() const;
  ::test::MirrorArgsPB* _internal_mutable_mirror();
  public:
  void unsafe_arena_set_allocated_mirror(
      ::test::MirrorArgsPB* mirror);
  ::test::MirrorArgsPB* unsafe_arena_release_mirror();

  // optional int32 FTTType = 1;
  bool has_ftttype() const;
  private:
  bool _internal_has_ftttype() const;
  public:
  void clear_ftttype();
  int32_t ftttype() const;
  void set_ftttype(int32_t value);
  private:
  int32_t _internal_ftttype() const;
  void _internal_set_ftttype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.ChunkOptionsPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placement_;
    ::test::MirrorArgsPB* mirror_;
    int32_t ftttype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class ReplicaLocationPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.ReplicaLocationPB) */ {
 public:
  inline ReplicaLocationPB() : ReplicaLocationPB(nullptr) {}
  ~ReplicaLocationPB() override;
  explicit PROTOBUF_CONSTEXPR ReplicaLocationPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplicaLocationPB(const ReplicaLocationPB& from);
  ReplicaLocationPB(ReplicaLocationPB&& from) noexcept
    : ReplicaLocationPB() {
    *this = ::std::move(from);
  }

  inline ReplicaLocationPB& operator=(const ReplicaLocationPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicaLocationPB& operator=(ReplicaLocationPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicaLocationPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicaLocationPB* internal_default_instance() {
    return reinterpret_cast<const ReplicaLocationPB*>(
               &_ReplicaLocationPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReplicaLocationPB& a, ReplicaLocationPB& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicaLocationPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicaLocationPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicaLocationPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplicaLocationPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplicaLocationPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplicaLocationPB& from) {
    ReplicaLocationPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicaLocationPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.ReplicaLocationPB";
  }
  protected:
  explicit ReplicaLocationPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCSLocationFieldNumber = 1,
    kDiskLocationFieldNumber = 2,
    kDiskTypeFieldNumber = 3,
  };
  // optional bytes CSLocation = 1;
  bool has_cslocation() const;
  private:
  bool _internal_has_cslocation() const;
  public:
  void clear_cslocation();
  const std::string& cslocation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cslocation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cslocation();
  PROTOBUF_NODISCARD std::string* release_cslocation();
  void set_allocated_cslocation(std::string* cslocation);
  private:
  const std::string& _internal_cslocation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cslocation(const std::string& value);
  std::string* _internal_mutable_cslocation();
  public:

  // optional int32 diskLocation = 2;
  bool has_disklocation() const;
  private:
  bool _internal_has_disklocation() const;
  public:
  void clear_disklocation();
  int32_t disklocation() const;
  void set_disklocation(int32_t value);
  private:
  int32_t _internal_disklocation() const;
  void _internal_set_disklocation(int32_t value);
  public:

  // optional uint32 diskType = 3;
  bool has_disktype() const;
  private:
  bool _internal_has_disktype() const;
  public:
  void clear_disktype();
  uint32_t disktype() const;
  void set_disktype(uint32_t value);
  private:
  uint32_t _internal_disktype() const;
  void _internal_set_disktype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.ReplicaLocationPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cslocation_;
    int32_t disklocation_;
    uint32_t disktype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class AccelerateOpenOptionsPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.AccelerateOpenOptionsPB) */ {
 public:
  inline AccelerateOpenOptionsPB() : AccelerateOpenOptionsPB(nullptr) {}
  ~AccelerateOpenOptionsPB() override;
  explicit PROTOBUF_CONSTEXPR AccelerateOpenOptionsPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccelerateOpenOptionsPB(const AccelerateOpenOptionsPB& from);
  AccelerateOpenOptionsPB(AccelerateOpenOptionsPB&& from) noexcept
    : AccelerateOpenOptionsPB() {
    *this = ::std::move(from);
  }

  inline AccelerateOpenOptionsPB& operator=(const AccelerateOpenOptionsPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelerateOpenOptionsPB& operator=(AccelerateOpenOptionsPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelerateOpenOptionsPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelerateOpenOptionsPB* internal_default_instance() {
    return reinterpret_cast<const AccelerateOpenOptionsPB*>(
               &_AccelerateOpenOptionsPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AccelerateOpenOptionsPB& a, AccelerateOpenOptionsPB& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelerateOpenOptionsPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelerateOpenOptionsPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccelerateOpenOptionsPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccelerateOpenOptionsPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccelerateOpenOptionsPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccelerateOpenOptionsPB& from) {
    AccelerateOpenOptionsPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerateOpenOptionsPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.AccelerateOpenOptionsPB";
  }
  protected:
  explicit AccelerateOpenOptionsPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkLocationFieldNumber = 2,
    kChunkOptionsFieldNumber = 1,
    kChunkSizeExponentFieldNumber = 3,
    kChecksumCategoryFieldNumber = 4,
  };
  // repeated .test.ReplicaLocationPB ChunkLocation = 2;
  int chunklocation_size() const;
  private:
  int _internal_chunklocation_size() const;
  public:
  void clear_chunklocation();
  ::test::ReplicaLocationPB* mutable_chunklocation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::ReplicaLocationPB >*
      mutable_chunklocation();
  private:
  const ::test::ReplicaLocationPB& _internal_chunklocation(int index) const;
  ::test::ReplicaLocationPB* _internal_add_chunklocation();
  public:
  const ::test::ReplicaLocationPB& chunklocation(int index) const;
  ::test::ReplicaLocationPB* add_chunklocation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::ReplicaLocationPB >&
      chunklocation() const;

  // optional .test.ChunkOptionsPB ChunkOptions = 1;
  bool has_chunkoptions() const;
  private:
  bool _internal_has_chunkoptions() const;
  public:
  void clear_chunkoptions();
  const ::test::ChunkOptionsPB& chunkoptions() const;
  PROTOBUF_NODISCARD ::test::ChunkOptionsPB* release_chunkoptions();
  ::test::ChunkOptionsPB* mutable_chunkoptions();
  void set_allocated_chunkoptions(::test::ChunkOptionsPB* chunkoptions);
  private:
  const ::test::ChunkOptionsPB& _internal_chunkoptions() const;
  ::test::ChunkOptionsPB* _internal_mutable_chunkoptions();
  public:
  void unsafe_arena_set_allocated_chunkoptions(
      ::test::ChunkOptionsPB* chunkoptions);
  ::test::ChunkOptionsPB* unsafe_arena_release_chunkoptions();

  // optional uint32 chunkSizeExponent = 3;
  bool has_chunksizeexponent() const;
  private:
  bool _internal_has_chunksizeexponent() const;
  public:
  void clear_chunksizeexponent();
  uint32_t chunksizeexponent() const;
  void set_chunksizeexponent(uint32_t value);
  private:
  uint32_t _internal_chunksizeexponent() const;
  void _internal_set_chunksizeexponent(uint32_t value);
  public:

  // optional uint32 checksumCategory = 4;
  bool has_checksumcategory() const;
  private:
  bool _internal_has_checksumcategory() const;
  public:
  void clear_checksumcategory();
  uint32_t checksumcategory() const;
  void set_checksumcategory(uint32_t value);
  private:
  uint32_t _internal_checksumcategory() const;
  void _internal_set_checksumcategory(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.AccelerateOpenOptionsPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::ReplicaLocationPB > chunklocation_;
    ::test::ChunkOptionsPB* chunkoptions_;
    uint32_t chunksizeexponent_;
    uint32_t checksumcategory_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class IONicePB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.IONicePB) */ {
 public:
  inline IONicePB() : IONicePB(nullptr) {}
  ~IONicePB() override;
  explicit PROTOBUF_CONSTEXPR IONicePB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IONicePB(const IONicePB& from);
  IONicePB(IONicePB&& from) noexcept
    : IONicePB() {
    *this = ::std::move(from);
  }

  inline IONicePB& operator=(const IONicePB& from) {
    CopyFrom(from);
    return *this;
  }
  inline IONicePB& operator=(IONicePB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IONicePB& default_instance() {
    return *internal_default_instance();
  }
  static inline const IONicePB* internal_default_instance() {
    return reinterpret_cast<const IONicePB*>(
               &_IONicePB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IONicePB& a, IONicePB& b) {
    a.Swap(&b);
  }
  inline void Swap(IONicePB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IONicePB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IONicePB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IONicePB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IONicePB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IONicePB& from) {
    IONicePB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IONicePB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.IONicePB";
  }
  protected:
  explicit IONicePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriorityFieldNumber = 1,
    kIOClassFieldNumber = 2,
  };
  // optional int32 Priority = 1;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // optional int32 IOClass = 2;
  bool has_ioclass() const;
  private:
  bool _internal_has_ioclass() const;
  public:
  void clear_ioclass();
  int32_t ioclass() const;
  void set_ioclass(int32_t value);
  private:
  int32_t _internal_ioclass() const;
  void _internal_set_ioclass(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.IONicePB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t priority_;
    int32_t ioclass_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class CsChooseDiskStrategyCJPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.CsChooseDiskStrategyCJPB) */ {
 public:
  inline CsChooseDiskStrategyCJPB() : CsChooseDiskStrategyCJPB(nullptr) {}
  ~CsChooseDiskStrategyCJPB() override;
  explicit PROTOBUF_CONSTEXPR CsChooseDiskStrategyCJPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CsChooseDiskStrategyCJPB(const CsChooseDiskStrategyCJPB& from);
  CsChooseDiskStrategyCJPB(CsChooseDiskStrategyCJPB&& from) noexcept
    : CsChooseDiskStrategyCJPB() {
    *this = ::std::move(from);
  }

  inline CsChooseDiskStrategyCJPB& operator=(const CsChooseDiskStrategyCJPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CsChooseDiskStrategyCJPB& operator=(CsChooseDiskStrategyCJPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CsChooseDiskStrategyCJPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CsChooseDiskStrategyCJPB* internal_default_instance() {
    return reinterpret_cast<const CsChooseDiskStrategyCJPB*>(
               &_CsChooseDiskStrategyCJPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CsChooseDiskStrategyCJPB& a, CsChooseDiskStrategyCJPB& b) {
    a.Swap(&b);
  }
  inline void Swap(CsChooseDiskStrategyCJPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CsChooseDiskStrategyCJPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CsChooseDiskStrategyCJPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CsChooseDiskStrategyCJPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CsChooseDiskStrategyCJPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CsChooseDiskStrategyCJPB& from) {
    CsChooseDiskStrategyCJPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CsChooseDiskStrategyCJPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.CsChooseDiskStrategyCJPB";
  }
  protected:
  explicit CsChooseDiskStrategyCJPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrategiesFieldNumber = 1,
    kDiskStorageTypeFieldNumber = 2,
    kTargetStorageTypeFieldNumber = 3,
  };
  // repeated .test.CsChooseDiskStrategySingleCJPB Strategies = 1;
  int strategies_size() const;
  private:
  int _internal_strategies_size() const;
  public:
  void clear_strategies();
  ::test::CsChooseDiskStrategySingleCJPB* mutable_strategies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::CsChooseDiskStrategySingleCJPB >*
      mutable_strategies();
  private:
  const ::test::CsChooseDiskStrategySingleCJPB& _internal_strategies(int index) const;
  ::test::CsChooseDiskStrategySingleCJPB* _internal_add_strategies();
  public:
  const ::test::CsChooseDiskStrategySingleCJPB& strategies(int index) const;
  ::test::CsChooseDiskStrategySingleCJPB* add_strategies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::CsChooseDiskStrategySingleCJPB >&
      strategies() const;

  // optional int32 DiskStorageType = 2;
  bool has_diskstoragetype() const;
  private:
  bool _internal_has_diskstoragetype() const;
  public:
  void clear_diskstoragetype();
  int32_t diskstoragetype() const;
  void set_diskstoragetype(int32_t value);
  private:
  int32_t _internal_diskstoragetype() const;
  void _internal_set_diskstoragetype(int32_t value);
  public:

  // optional int32 TargetStorageType = 3;
  bool has_targetstoragetype() const;
  private:
  bool _internal_has_targetstoragetype() const;
  public:
  void clear_targetstoragetype();
  int32_t targetstoragetype() const;
  void set_targetstoragetype(int32_t value);
  private:
  int32_t _internal_targetstoragetype() const;
  void _internal_set_targetstoragetype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.CsChooseDiskStrategyCJPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::CsChooseDiskStrategySingleCJPB > strategies_;
    int32_t diskstoragetype_;
    int32_t targetstoragetype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class ChunkOrStreamIdInfoPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.ChunkOrStreamIdInfoPB) */ {
 public:
  inline ChunkOrStreamIdInfoPB() : ChunkOrStreamIdInfoPB(nullptr) {}
  ~ChunkOrStreamIdInfoPB() override;
  explicit PROTOBUF_CONSTEXPR ChunkOrStreamIdInfoPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChunkOrStreamIdInfoPB(const ChunkOrStreamIdInfoPB& from);
  ChunkOrStreamIdInfoPB(ChunkOrStreamIdInfoPB&& from) noexcept
    : ChunkOrStreamIdInfoPB() {
    *this = ::std::move(from);
  }

  inline ChunkOrStreamIdInfoPB& operator=(const ChunkOrStreamIdInfoPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkOrStreamIdInfoPB& operator=(ChunkOrStreamIdInfoPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkOrStreamIdInfoPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkOrStreamIdInfoPB* internal_default_instance() {
    return reinterpret_cast<const ChunkOrStreamIdInfoPB*>(
               &_ChunkOrStreamIdInfoPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChunkOrStreamIdInfoPB& a, ChunkOrStreamIdInfoPB& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkOrStreamIdInfoPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkOrStreamIdInfoPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkOrStreamIdInfoPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChunkOrStreamIdInfoPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChunkOrStreamIdInfoPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChunkOrStreamIdInfoPB& from) {
    ChunkOrStreamIdInfoPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkOrStreamIdInfoPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.ChunkOrStreamIdInfoPB";
  }
  protected:
  explicit ChunkOrStreamIdInfoPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kPartitionIndexFieldNumber = 2,
    kPaddingFieldNumber = 3,
  };
  // optional .test.UUIDInfoPB uuid = 1;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::test::UUIDInfoPB& uuid() const;
  PROTOBUF_NODISCARD ::test::UUIDInfoPB* release_uuid();
  ::test::UUIDInfoPB* mutable_uuid();
  void set_allocated_uuid(::test::UUIDInfoPB* uuid);
  private:
  const ::test::UUIDInfoPB& _internal_uuid() const;
  ::test::UUIDInfoPB* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::test::UUIDInfoPB* uuid);
  ::test::UUIDInfoPB* unsafe_arena_release_uuid();

  // optional uint32 partition_index = 2;
  bool has_partition_index() const;
  private:
  bool _internal_has_partition_index() const;
  public:
  void clear_partition_index();
  uint32_t partition_index() const;
  void set_partition_index(uint32_t value);
  private:
  uint32_t _internal_partition_index() const;
  void _internal_set_partition_index(uint32_t value);
  public:

  // optional uint32 padding = 3;
  bool has_padding() const;
  private:
  bool _internal_has_padding() const;
  public:
  void clear_padding();
  uint32_t padding() const;
  void set_padding(uint32_t value);
  private:
  uint32_t _internal_padding() const;
  void _internal_set_padding(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.ChunkOrStreamIdInfoPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::test::UUIDInfoPB* uuid_;
    uint32_t partition_index_;
    uint32_t padding_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class QosOptionsPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.QosOptionsPB) */ {
 public:
  inline QosOptionsPB() : QosOptionsPB(nullptr) {}
  ~QosOptionsPB() override;
  explicit PROTOBUF_CONSTEXPR QosOptionsPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QosOptionsPB(const QosOptionsPB& from);
  QosOptionsPB(QosOptionsPB&& from) noexcept
    : QosOptionsPB() {
    *this = ::std::move(from);
  }

  inline QosOptionsPB& operator=(const QosOptionsPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline QosOptionsPB& operator=(QosOptionsPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QosOptionsPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const QosOptionsPB* internal_default_instance() {
    return reinterpret_cast<const QosOptionsPB*>(
               &_QosOptionsPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(QosOptionsPB& a, QosOptionsPB& b) {
    a.Swap(&b);
  }
  inline void Swap(QosOptionsPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QosOptionsPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QosOptionsPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QosOptionsPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QosOptionsPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QosOptionsPB& from) {
    QosOptionsPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QosOptionsPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.QosOptionsPB";
  }
  protected:
  explicit QosOptionsPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef QosOptionsPB_AdjustType AdjustType;
  static constexpr AdjustType KEEP =
    QosOptionsPB_AdjustType_KEEP;
  static constexpr AdjustType LOWER =
    QosOptionsPB_AdjustType_LOWER;
  static constexpr AdjustType HIGHER =
    QosOptionsPB_AdjustType_HIGHER;
  static inline bool AdjustType_IsValid(int value) {
    return QosOptionsPB_AdjustType_IsValid(value);
  }
  static constexpr AdjustType AdjustType_MIN =
    QosOptionsPB_AdjustType_AdjustType_MIN;
  static constexpr AdjustType AdjustType_MAX =
    QosOptionsPB_AdjustType_AdjustType_MAX;
  static constexpr int AdjustType_ARRAYSIZE =
    QosOptionsPB_AdjustType_AdjustType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AdjustType_descriptor() {
    return QosOptionsPB_AdjustType_descriptor();
  }
  template<typename T>
  static inline const std::string& AdjustType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AdjustType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AdjustType_Name.");
    return QosOptionsPB_AdjustType_Name(enum_t_value);
  }
  static inline bool AdjustType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AdjustType* value) {
    return QosOptionsPB_AdjustType_Parse(name, value);
  }

  typedef QosOptionsPB_CacheGroupType CacheGroupType;
  static constexpr CacheGroupType NO_CACHE =
    QosOptionsPB_CacheGroupType_NO_CACHE;
  static constexpr CacheGroupType DEFAULT =
    QosOptionsPB_CacheGroupType_DEFAULT;
  static constexpr CacheGroupType INTERNAL =
    QosOptionsPB_CacheGroupType_INTERNAL;
  static constexpr CacheGroupType USER_BASE =
    QosOptionsPB_CacheGroupType_USER_BASE;
  static constexpr CacheGroupType USER_0 =
    QosOptionsPB_CacheGroupType_USER_0;
  static constexpr CacheGroupType USER_1 =
    QosOptionsPB_CacheGroupType_USER_1;
  static inline bool CacheGroupType_IsValid(int value) {
    return QosOptionsPB_CacheGroupType_IsValid(value);
  }
  static constexpr CacheGroupType CacheGroupType_MIN =
    QosOptionsPB_CacheGroupType_CacheGroupType_MIN;
  static constexpr CacheGroupType CacheGroupType_MAX =
    QosOptionsPB_CacheGroupType_CacheGroupType_MAX;
  static constexpr int CacheGroupType_ARRAYSIZE =
    QosOptionsPB_CacheGroupType_CacheGroupType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CacheGroupType_descriptor() {
    return QosOptionsPB_CacheGroupType_descriptor();
  }
  template<typename T>
  static inline const std::string& CacheGroupType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CacheGroupType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CacheGroupType_Name.");
    return QosOptionsPB_CacheGroupType_Name(enum_t_value);
  }
  static inline bool CacheGroupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CacheGroupType* value) {
    return QosOptionsPB_CacheGroupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServiceIdFieldNumber = 1,
    kFlowIdFieldNumber = 2,
    kAdjustFieldNumber = 3,
    kCacheGroupIdFieldNumber = 4,
    kNetworkPriorityFieldNumber = 5,
  };
  // optional uint32 serviceId = 1;
  bool has_serviceid() const;
  private:
  bool _internal_has_serviceid() const;
  public:
  void clear_serviceid();
  uint32_t serviceid() const;
  void set_serviceid(uint32_t value);
  private:
  uint32_t _internal_serviceid() const;
  void _internal_set_serviceid(uint32_t value);
  public:

  // optional uint32 flowId = 2;
  bool has_flowid() const;
  private:
  bool _internal_has_flowid() const;
  public:
  void clear_flowid();
  uint32_t flowid() const;
  void set_flowid(uint32_t value);
  private:
  uint32_t _internal_flowid() const;
  void _internal_set_flowid(uint32_t value);
  public:

  // optional int32 adjust = 3;
  bool has_adjust() const;
  private:
  bool _internal_has_adjust() const;
  public:
  void clear_adjust();
  int32_t adjust() const;
  void set_adjust(int32_t value);
  private:
  int32_t _internal_adjust() const;
  void _internal_set_adjust(int32_t value);
  public:

  // optional uint32 cacheGroupId = 4 [default = 0];
  bool has_cachegroupid() const;
  private:
  bool _internal_has_cachegroupid() const;
  public:
  void clear_cachegroupid();
  uint32_t cachegroupid() const;
  void set_cachegroupid(uint32_t value);
  private:
  uint32_t _internal_cachegroupid() const;
  void _internal_set_cachegroupid(uint32_t value);
  public:

  // optional int32 networkPriority = 5;
  bool has_networkpriority() const;
  private:
  bool _internal_has_networkpriority() const;
  public:
  void clear_networkpriority();
  int32_t networkpriority() const;
  void set_networkpriority(int32_t value);
  private:
  int32_t _internal_networkpriority() const;
  void _internal_set_networkpriority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.QosOptionsPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t serviceid_;
    uint32_t flowid_;
    int32_t adjust_;
    uint32_t cachegroupid_;
    int32_t networkpriority_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class FlushChecksumPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.FlushChecksumPB) */ {
 public:
  inline FlushChecksumPB() : FlushChecksumPB(nullptr) {}
  ~FlushChecksumPB() override;
  explicit PROTOBUF_CONSTEXPR FlushChecksumPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushChecksumPB(const FlushChecksumPB& from);
  FlushChecksumPB(FlushChecksumPB&& from) noexcept
    : FlushChecksumPB() {
    *this = ::std::move(from);
  }

  inline FlushChecksumPB& operator=(const FlushChecksumPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushChecksumPB& operator=(FlushChecksumPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushChecksumPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushChecksumPB* internal_default_instance() {
    return reinterpret_cast<const FlushChecksumPB*>(
               &_FlushChecksumPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FlushChecksumPB& a, FlushChecksumPB& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushChecksumPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushChecksumPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushChecksumPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushChecksumPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushChecksumPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushChecksumPB& from) {
    FlushChecksumPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushChecksumPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.FlushChecksumPB";
  }
  protected:
  explicit FlushChecksumPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kCategoryFieldNumber = 1,
  };
  // optional int64 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // optional uint32 category = 1;
  bool has_category() const;
  private:
  bool _internal_has_category() const;
  public:
  void clear_category();
  uint32_t category() const;
  void set_category(uint32_t value);
  private:
  uint32_t _internal_category() const;
  void _internal_set_category(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.FlushChecksumPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t value_;
    uint32_t category_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class UUIDInfoPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.UUIDInfoPB) */ {
 public:
  inline UUIDInfoPB() : UUIDInfoPB(nullptr) {}
  ~UUIDInfoPB() override;
  explicit PROTOBUF_CONSTEXPR UUIDInfoPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UUIDInfoPB(const UUIDInfoPB& from);
  UUIDInfoPB(UUIDInfoPB&& from) noexcept
    : UUIDInfoPB() {
    *this = ::std::move(from);
  }

  inline UUIDInfoPB& operator=(const UUIDInfoPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline UUIDInfoPB& operator=(UUIDInfoPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UUIDInfoPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const UUIDInfoPB* internal_default_instance() {
    return reinterpret_cast<const UUIDInfoPB*>(
               &_UUIDInfoPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UUIDInfoPB& a, UUIDInfoPB& b) {
    a.Swap(&b);
  }
  inline void Swap(UUIDInfoPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UUIDInfoPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UUIDInfoPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UUIDInfoPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UUIDInfoPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UUIDInfoPB& from) {
    UUIDInfoPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UUIDInfoPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.UUIDInfoPB";
  }
  protected:
  explicit UUIDInfoPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowFieldNumber = 1,
    kHighFieldNumber = 2,
  };
  // optional uint64 low = 1;
  bool has_low() const;
  private:
  bool _internal_has_low() const;
  public:
  void clear_low();
  uint64_t low() const;
  void set_low(uint64_t value);
  private:
  uint64_t _internal_low() const;
  void _internal_set_low(uint64_t value);
  public:

  // optional uint64 high = 2;
  bool has_high() const;
  private:
  bool _internal_has_high() const;
  public:
  void clear_high();
  uint64_t high() const;
  void set_high(uint64_t value);
  private:
  uint64_t _internal_high() const;
  void _internal_set_high(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.UUIDInfoPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t low_;
    uint64_t high_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class RootServerIdPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.RootServerIdPB) */ {
 public:
  inline RootServerIdPB() : RootServerIdPB(nullptr) {}
  ~RootServerIdPB() override;
  explicit PROTOBUF_CONSTEXPR RootServerIdPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RootServerIdPB(const RootServerIdPB& from);
  RootServerIdPB(RootServerIdPB&& from) noexcept
    : RootServerIdPB() {
    *this = ::std::move(from);
  }

  inline RootServerIdPB& operator=(const RootServerIdPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline RootServerIdPB& operator=(RootServerIdPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RootServerIdPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const RootServerIdPB* internal_default_instance() {
    return reinterpret_cast<const RootServerIdPB*>(
               &_RootServerIdPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RootServerIdPB& a, RootServerIdPB& b) {
    a.Swap(&b);
  }
  inline void Swap(RootServerIdPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RootServerIdPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RootServerIdPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RootServerIdPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RootServerIdPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RootServerIdPB& from) {
    RootServerIdPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RootServerIdPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.RootServerIdPB";
  }
  protected:
  explicit RootServerIdPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kLeaderTermFieldNumber = 2,
  };
  // optional .test.UUIDInfoPB uuid = 1;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::test::UUIDInfoPB& uuid() const;
  PROTOBUF_NODISCARD ::test::UUIDInfoPB* release_uuid();
  ::test::UUIDInfoPB* mutable_uuid();
  void set_allocated_uuid(::test::UUIDInfoPB* uuid);
  private:
  const ::test::UUIDInfoPB& _internal_uuid() const;
  ::test::UUIDInfoPB* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::test::UUIDInfoPB* uuid);
  ::test::UUIDInfoPB* unsafe_arena_release_uuid();

  // optional int64 leader_term = 2;
  bool has_leader_term() const;
  private:
  bool _internal_has_leader_term() const;
  public:
  void clear_leader_term();
  int64_t leader_term() const;
  void set_leader_term(int64_t value);
  private:
  int64_t _internal_leader_term() const;
  void _internal_set_leader_term(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.RootServerIdPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::test::UUIDInfoPB* uuid_;
    int64_t leader_term_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class ChunkIdTypeCJPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.ChunkIdTypeCJPB) */ {
 public:
  inline ChunkIdTypeCJPB() : ChunkIdTypeCJPB(nullptr) {}
  ~ChunkIdTypeCJPB() override;
  explicit PROTOBUF_CONSTEXPR ChunkIdTypeCJPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChunkIdTypeCJPB(const ChunkIdTypeCJPB& from);
  ChunkIdTypeCJPB(ChunkIdTypeCJPB&& from) noexcept
    : ChunkIdTypeCJPB() {
    *this = ::std::move(from);
  }

  inline ChunkIdTypeCJPB& operator=(const ChunkIdTypeCJPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkIdTypeCJPB& operator=(ChunkIdTypeCJPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkIdTypeCJPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkIdTypeCJPB* internal_default_instance() {
    return reinterpret_cast<const ChunkIdTypeCJPB*>(
               &_ChunkIdTypeCJPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChunkIdTypeCJPB& a, ChunkIdTypeCJPB& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkIdTypeCJPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkIdTypeCJPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkIdTypeCJPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChunkIdTypeCJPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChunkIdTypeCJPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChunkIdTypeCJPB& from) {
    ChunkIdTypeCJPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkIdTypeCJPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.ChunkIdTypeCJPB";
  }
  protected:
  explicit ChunkIdTypeCJPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBelongedFileIdFieldNumber = 1,
    kChunkIndexFieldNumber = 2,
    kPaddingFieldNumber = 3,
  };
  // optional uint64 BelongedFileId = 1;
  bool has_belongedfileid() const;
  private:
  bool _internal_has_belongedfileid() const;
  public:
  void clear_belongedfileid();
  uint64_t belongedfileid() const;
  void set_belongedfileid(uint64_t value);
  private:
  uint64_t _internal_belongedfileid() const;
  void _internal_set_belongedfileid(uint64_t value);
  public:

  // optional uint32 ChunkIndex = 2;
  bool has_chunkindex() const;
  private:
  bool _internal_has_chunkindex() const;
  public:
  void clear_chunkindex();
  uint32_t chunkindex() const;
  void set_chunkindex(uint32_t value);
  private:
  uint32_t _internal_chunkindex() const;
  void _internal_set_chunkindex(uint32_t value);
  public:

  // optional uint32 Padding = 3 [default = 0];
  bool has_padding() const;
  private:
  bool _internal_has_padding() const;
  public:
  void clear_padding();
  uint32_t padding() const;
  void set_padding(uint32_t value);
  private:
  uint32_t _internal_padding() const;
  void _internal_set_padding(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.ChunkIdTypeCJPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t belongedfileid_;
    uint32_t chunkindex_;
    uint32_t padding_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class PanguTraceSpanInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.PanguTraceSpanInfo) */ {
 public:
  inline PanguTraceSpanInfo() : PanguTraceSpanInfo(nullptr) {}
  ~PanguTraceSpanInfo() override;
  explicit PROTOBUF_CONSTEXPR PanguTraceSpanInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PanguTraceSpanInfo(const PanguTraceSpanInfo& from);
  PanguTraceSpanInfo(PanguTraceSpanInfo&& from) noexcept
    : PanguTraceSpanInfo() {
    *this = ::std::move(from);
  }

  inline PanguTraceSpanInfo& operator=(const PanguTraceSpanInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PanguTraceSpanInfo& operator=(PanguTraceSpanInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PanguTraceSpanInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PanguTraceSpanInfo* internal_default_instance() {
    return reinterpret_cast<const PanguTraceSpanInfo*>(
               &_PanguTraceSpanInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PanguTraceSpanInfo& a, PanguTraceSpanInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PanguTraceSpanInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PanguTraceSpanInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PanguTraceSpanInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PanguTraceSpanInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PanguTraceSpanInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PanguTraceSpanInfo& from) {
    PanguTraceSpanInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PanguTraceSpanInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.PanguTraceSpanInfo";
  }
  protected:
  explicit PanguTraceSpanInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraceIdLowFieldNumber = 1,
    kTraceIdHighFieldNumber = 2,
    kSpanIdFieldNumber = 3,
  };
  // optional uint64 TraceIdLow = 1;
  bool has_traceidlow() const;
  private:
  bool _internal_has_traceidlow() const;
  public:
  void clear_traceidlow();
  uint64_t traceidlow() const;
  void set_traceidlow(uint64_t value);
  private:
  uint64_t _internal_traceidlow() const;
  void _internal_set_traceidlow(uint64_t value);
  public:

  // optional uint64 TraceIdHigh = 2;
  bool has_traceidhigh() const;
  private:
  bool _internal_has_traceidhigh() const;
  public:
  void clear_traceidhigh();
  uint64_t traceidhigh() const;
  void set_traceidhigh(uint64_t value);
  private:
  uint64_t _internal_traceidhigh() const;
  void _internal_set_traceidhigh(uint64_t value);
  public:

  // optional uint64 SpanId = 3;
  bool has_spanid() const;
  private:
  bool _internal_has_spanid() const;
  public:
  void clear_spanid();
  uint64_t spanid() const;
  void set_spanid(uint64_t value);
  private:
  uint64_t _internal_spanid() const;
  void _internal_set_spanid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.PanguTraceSpanInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t traceidlow_;
    uint64_t traceidhigh_;
    uint64_t spanid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class CsChooseDiskStrategySingleCJPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.CsChooseDiskStrategySingleCJPB) */ {
 public:
  inline CsChooseDiskStrategySingleCJPB() : CsChooseDiskStrategySingleCJPB(nullptr) {}
  ~CsChooseDiskStrategySingleCJPB() override;
  explicit PROTOBUF_CONSTEXPR CsChooseDiskStrategySingleCJPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CsChooseDiskStrategySingleCJPB(const CsChooseDiskStrategySingleCJPB& from);
  CsChooseDiskStrategySingleCJPB(CsChooseDiskStrategySingleCJPB&& from) noexcept
    : CsChooseDiskStrategySingleCJPB() {
    *this = ::std::move(from);
  }

  inline CsChooseDiskStrategySingleCJPB& operator=(const CsChooseDiskStrategySingleCJPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline CsChooseDiskStrategySingleCJPB& operator=(CsChooseDiskStrategySingleCJPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CsChooseDiskStrategySingleCJPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const CsChooseDiskStrategySingleCJPB* internal_default_instance() {
    return reinterpret_cast<const CsChooseDiskStrategySingleCJPB*>(
               &_CsChooseDiskStrategySingleCJPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CsChooseDiskStrategySingleCJPB& a, CsChooseDiskStrategySingleCJPB& b) {
    a.Swap(&b);
  }
  inline void Swap(CsChooseDiskStrategySingleCJPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CsChooseDiskStrategySingleCJPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CsChooseDiskStrategySingleCJPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CsChooseDiskStrategySingleCJPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CsChooseDiskStrategySingleCJPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CsChooseDiskStrategySingleCJPB& from) {
    CsChooseDiskStrategySingleCJPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CsChooseDiskStrategySingleCJPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.CsChooseDiskStrategySingleCJPB";
  }
  protected:
  explicit CsChooseDiskStrategySingleCJPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kWeightFieldNumber = 2,
    kParameterFieldNumber = 3,
  };
  // optional uint32 Method = 1;
  bool has_method() const;
  private:
  bool _internal_has_method() const;
  public:
  void clear_method();
  uint32_t method() const;
  void set_method(uint32_t value);
  private:
  uint32_t _internal_method() const;
  void _internal_set_method(uint32_t value);
  public:

  // optional uint32 Weight = 2;
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  uint32_t weight() const;
  void set_weight(uint32_t value);
  private:
  uint32_t _internal_weight() const;
  void _internal_set_weight(uint32_t value);
  public:

  // optional uint64 Parameter = 3 [default = 0];
  bool has_parameter() const;
  private:
  bool _internal_has_parameter() const;
  public:
  void clear_parameter();
  uint64_t parameter() const;
  void set_parameter(uint64_t value);
  private:
  uint64_t _internal_parameter() const;
  void _internal_set_parameter(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.CsChooseDiskStrategySingleCJPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t method_;
    uint32_t weight_;
    uint64_t parameter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class FlatLogFileFlushChunkRequestPB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.FlatLogFileFlushChunkRequestPB) */ {
 public:
  inline FlatLogFileFlushChunkRequestPB() : FlatLogFileFlushChunkRequestPB(nullptr) {}
  ~FlatLogFileFlushChunkRequestPB() override;
  explicit PROTOBUF_CONSTEXPR FlatLogFileFlushChunkRequestPB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlatLogFileFlushChunkRequestPB(const FlatLogFileFlushChunkRequestPB& from);
  FlatLogFileFlushChunkRequestPB(FlatLogFileFlushChunkRequestPB&& from) noexcept
    : FlatLogFileFlushChunkRequestPB() {
    *this = ::std::move(from);
  }

  inline FlatLogFileFlushChunkRequestPB& operator=(const FlatLogFileFlushChunkRequestPB& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlatLogFileFlushChunkRequestPB& operator=(FlatLogFileFlushChunkRequestPB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlatLogFileFlushChunkRequestPB& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlatLogFileFlushChunkRequestPB* internal_default_instance() {
    return reinterpret_cast<const FlatLogFileFlushChunkRequestPB*>(
               &_FlatLogFileFlushChunkRequestPB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FlatLogFileFlushChunkRequestPB& a, FlatLogFileFlushChunkRequestPB& b) {
    a.Swap(&b);
  }
  inline void Swap(FlatLogFileFlushChunkRequestPB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlatLogFileFlushChunkRequestPB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlatLogFileFlushChunkRequestPB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlatLogFileFlushChunkRequestPB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlatLogFileFlushChunkRequestPB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlatLogFileFlushChunkRequestPB& from) {
    FlatLogFileFlushChunkRequestPB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlatLogFileFlushChunkRequestPB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.FlatLogFileFlushChunkRequestPB";
  }
  protected:
  explicit FlatLogFileFlushChunkRequestPB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kHostNameFieldNumber = 22,
    kUserIdFieldNumber = 25,
    kChunkIdFieldNumber = 1,
    kIONiceFieldNumber = 9,
    kOpenChunkOptionsFieldNumber = 10,
    kTraceSpanFieldNumber = 14,
    kStrategyFieldNumber = 16,
    kChunkIdV2FieldNumber = 17,
    kQosOptionsFieldNumber = 18,
    kChecksumFieldNumber = 19,
    kVolumeUUIDFieldNumber = 20,
    kRootServerIdFieldNumber = 26,
    kOffsetFieldNumber = 2,
    kLengthFieldNumber = 3,
    kStorageIdFieldNumber = 4,
    kHintFieldNumber = 6,
    kIsReplicationFieldNumber = 7,
    kTraceOpenFieldNumber = 8,
    kCreateIfNotExistsFieldNumber = 15,
    kOpenModeFieldNumber = 11,
    kHandleFieldNumber = 12,
    kModuleVersionFieldNumber = 21,
    kDiskIdFieldNumber = 23,
    kRequestIdFieldNumber = 24,
    kRequiredMinCSVersionFieldNumber = 27,
    kFromTypeFieldNumber = 28,
    kOffset64FieldNumber = 29,
    kRecordSizeFieldNumber = 30,
    kPoolIdFieldNumber = 31,
    kStoragePoolConfVersionFieldNumber = 32,
    kAFieldNumber = 33,
    kDataSyncFieldNumber = 13,
  };
  // optional bytes Data = 5;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bytes HostName = 22;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // optional bytes UserId = 25;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // optional .test.ChunkIdTypeCJPB ChunkId = 1;
  bool has_chunkid() const;
  private:
  bool _internal_has_chunkid() const;
  public:
  void clear_chunkid();
  const ::test::ChunkIdTypeCJPB& chunkid() const;
  PROTOBUF_NODISCARD ::test::ChunkIdTypeCJPB* release_chunkid();
  ::test::ChunkIdTypeCJPB* mutable_chunkid();
  void set_allocated_chunkid(::test::ChunkIdTypeCJPB* chunkid);
  private:
  const ::test::ChunkIdTypeCJPB& _internal_chunkid() const;
  ::test::ChunkIdTypeCJPB* _internal_mutable_chunkid();
  public:
  void unsafe_arena_set_allocated_chunkid(
      ::test::ChunkIdTypeCJPB* chunkid);
  ::test::ChunkIdTypeCJPB* unsafe_arena_release_chunkid();

  // optional .test.IONicePB IONice = 9;
  bool has_ionice() const;
  private:
  bool _internal_has_ionice() const;
  public:
  void clear_ionice();
  const ::test::IONicePB& ionice() const;
  PROTOBUF_NODISCARD ::test::IONicePB* release_ionice();
  ::test::IONicePB* mutable_ionice();
  void set_allocated_ionice(::test::IONicePB* ionice);
  private:
  const ::test::IONicePB& _internal_ionice() const;
  ::test::IONicePB* _internal_mutable_ionice();
  public:
  void unsafe_arena_set_allocated_ionice(
      ::test::IONicePB* ionice);
  ::test::IONicePB* unsafe_arena_release_ionice();

  // optional .test.AccelerateOpenOptionsPB OpenChunkOptions = 10;
  bool has_openchunkoptions() const;
  private:
  bool _internal_has_openchunkoptions() const;
  public:
  void clear_openchunkoptions();
  const ::test::AccelerateOpenOptionsPB& openchunkoptions() const;
  PROTOBUF_NODISCARD ::test::AccelerateOpenOptionsPB* release_openchunkoptions();
  ::test::AccelerateOpenOptionsPB* mutable_openchunkoptions();
  void set_allocated_openchunkoptions(::test::AccelerateOpenOptionsPB* openchunkoptions);
  private:
  const ::test::AccelerateOpenOptionsPB& _internal_openchunkoptions() const;
  ::test::AccelerateOpenOptionsPB* _internal_mutable_openchunkoptions();
  public:
  void unsafe_arena_set_allocated_openchunkoptions(
      ::test::AccelerateOpenOptionsPB* openchunkoptions);
  ::test::AccelerateOpenOptionsPB* unsafe_arena_release_openchunkoptions();

  // optional .test.PanguTraceSpanInfo trace_span = 14;
  bool has_trace_span() const;
  private:
  bool _internal_has_trace_span() const;
  public:
  void clear_trace_span();
  const ::test::PanguTraceSpanInfo& trace_span() const;
  PROTOBUF_NODISCARD ::test::PanguTraceSpanInfo* release_trace_span();
  ::test::PanguTraceSpanInfo* mutable_trace_span();
  void set_allocated_trace_span(::test::PanguTraceSpanInfo* trace_span);
  private:
  const ::test::PanguTraceSpanInfo& _internal_trace_span() const;
  ::test::PanguTraceSpanInfo* _internal_mutable_trace_span();
  public:
  void unsafe_arena_set_allocated_trace_span(
      ::test::PanguTraceSpanInfo* trace_span);
  ::test::PanguTraceSpanInfo* unsafe_arena_release_trace_span();

  // optional .test.CsChooseDiskStrategyCJPB Strategy = 16;
  bool has_strategy() const;
  private:
  bool _internal_has_strategy() const;
  public:
  void clear_strategy();
  const ::test::CsChooseDiskStrategyCJPB& strategy() const;
  PROTOBUF_NODISCARD ::test::CsChooseDiskStrategyCJPB* release_strategy();
  ::test::CsChooseDiskStrategyCJPB* mutable_strategy();
  void set_allocated_strategy(::test::CsChooseDiskStrategyCJPB* strategy);
  private:
  const ::test::CsChooseDiskStrategyCJPB& _internal_strategy() const;
  ::test::CsChooseDiskStrategyCJPB* _internal_mutable_strategy();
  public:
  void unsafe_arena_set_allocated_strategy(
      ::test::CsChooseDiskStrategyCJPB* strategy);
  ::test::CsChooseDiskStrategyCJPB* unsafe_arena_release_strategy();

  // optional .test.ChunkOrStreamIdInfoPB ChunkIdV2 = 17;
  bool has_chunkidv2() const;
  private:
  bool _internal_has_chunkidv2() const;
  public:
  void clear_chunkidv2();
  const ::test::ChunkOrStreamIdInfoPB& chunkidv2() const;
  PROTOBUF_NODISCARD ::test::ChunkOrStreamIdInfoPB* release_chunkidv2();
  ::test::ChunkOrStreamIdInfoPB* mutable_chunkidv2();
  void set_allocated_chunkidv2(::test::ChunkOrStreamIdInfoPB* chunkidv2);
  private:
  const ::test::ChunkOrStreamIdInfoPB& _internal_chunkidv2() const;
  ::test::ChunkOrStreamIdInfoPB* _internal_mutable_chunkidv2();
  public:
  void unsafe_arena_set_allocated_chunkidv2(
      ::test::ChunkOrStreamIdInfoPB* chunkidv2);
  ::test::ChunkOrStreamIdInfoPB* unsafe_arena_release_chunkidv2();

  // optional .test.QosOptionsPB qosOptions = 18;
  bool has_qosoptions() const;
  private:
  bool _internal_has_qosoptions() const;
  public:
  void clear_qosoptions();
  const ::test::QosOptionsPB& qosoptions() const;
  PROTOBUF_NODISCARD ::test::QosOptionsPB* release_qosoptions();
  ::test::QosOptionsPB* mutable_qosoptions();
  void set_allocated_qosoptions(::test::QosOptionsPB* qosoptions);
  private:
  const ::test::QosOptionsPB& _internal_qosoptions() const;
  ::test::QosOptionsPB* _internal_mutable_qosoptions();
  public:
  void unsafe_arena_set_allocated_qosoptions(
      ::test::QosOptionsPB* qosoptions);
  ::test::QosOptionsPB* unsafe_arena_release_qosoptions();

  // optional .test.FlushChecksumPB Checksum = 19;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  const ::test::FlushChecksumPB& checksum() const;
  PROTOBUF_NODISCARD ::test::FlushChecksumPB* release_checksum();
  ::test::FlushChecksumPB* mutable_checksum();
  void set_allocated_checksum(::test::FlushChecksumPB* checksum);
  private:
  const ::test::FlushChecksumPB& _internal_checksum() const;
  ::test::FlushChecksumPB* _internal_mutable_checksum();
  public:
  void unsafe_arena_set_allocated_checksum(
      ::test::FlushChecksumPB* checksum);
  ::test::FlushChecksumPB* unsafe_arena_release_checksum();

  // optional .test.UUIDInfoPB volumeUUID = 20;
  bool has_volumeuuid() const;
  private:
  bool _internal_has_volumeuuid() const;
  public:
  void clear_volumeuuid();
  const ::test::UUIDInfoPB& volumeuuid() const;
  PROTOBUF_NODISCARD ::test::UUIDInfoPB* release_volumeuuid();
  ::test::UUIDInfoPB* mutable_volumeuuid();
  void set_allocated_volumeuuid(::test::UUIDInfoPB* volumeuuid);
  private:
  const ::test::UUIDInfoPB& _internal_volumeuuid() const;
  ::test::UUIDInfoPB* _internal_mutable_volumeuuid();
  public:
  void unsafe_arena_set_allocated_volumeuuid(
      ::test::UUIDInfoPB* volumeuuid);
  ::test::UUIDInfoPB* unsafe_arena_release_volumeuuid();

  // optional .test.RootServerIdPB root_server_id = 26;
  bool has_root_server_id() const;
  private:
  bool _internal_has_root_server_id() const;
  public:
  void clear_root_server_id();
  const ::test::RootServerIdPB& root_server_id() const;
  PROTOBUF_NODISCARD ::test::RootServerIdPB* release_root_server_id();
  ::test::RootServerIdPB* mutable_root_server_id();
  void set_allocated_root_server_id(::test::RootServerIdPB* root_server_id);
  private:
  const ::test::RootServerIdPB& _internal_root_server_id() const;
  ::test::RootServerIdPB* _internal_mutable_root_server_id();
  public:
  void unsafe_arena_set_allocated_root_server_id(
      ::test::RootServerIdPB* root_server_id);
  ::test::RootServerIdPB* unsafe_arena_release_root_server_id();

  // optional uint32 Offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // optional uint32 Length = 3;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // optional uint32 StorageId = 4;
  bool has_storageid() const;
  private:
  bool _internal_has_storageid() const;
  public:
  void clear_storageid();
  uint32_t storageid() const;
  void set_storageid(uint32_t value);
  private:
  uint32_t _internal_storageid() const;
  void _internal_set_storageid(uint32_t value);
  public:

  // optional uint32 Hint = 6;
  bool has_hint() const;
  private:
  bool _internal_has_hint() const;
  public:
  void clear_hint();
  uint32_t hint() const;
  void set_hint(uint32_t value);
  private:
  uint32_t _internal_hint() const;
  void _internal_set_hint(uint32_t value);
  public:

  // optional bool IsReplication = 7 [default = false];
  bool has_isreplication() const;
  private:
  bool _internal_has_isreplication() const;
  public:
  void clear_isreplication();
  bool isreplication() const;
  void set_isreplication(bool value);
  private:
  bool _internal_isreplication() const;
  void _internal_set_isreplication(bool value);
  public:

  // optional bool trace_open = 8 [default = false];
  bool has_trace_open() const;
  private:
  bool _internal_has_trace_open() const;
  public:
  void clear_trace_open();
  bool trace_open() const;
  void set_trace_open(bool value);
  private:
  bool _internal_trace_open() const;
  void _internal_set_trace_open(bool value);
  public:

  // optional bool CreateIfNotExists = 15;
  bool has_createifnotexists() const;
  private:
  bool _internal_has_createifnotexists() const;
  public:
  void clear_createifnotexists();
  bool createifnotexists() const;
  void set_createifnotexists(bool value);
  private:
  bool _internal_createifnotexists() const;
  void _internal_set_createifnotexists(bool value);
  public:

  // optional int32 OpenMode = 11;
  bool has_openmode() const;
  private:
  bool _internal_has_openmode() const;
  public:
  void clear_openmode();
  int32_t openmode() const;
  void set_openmode(int32_t value);
  private:
  int32_t _internal_openmode() const;
  void _internal_set_openmode(int32_t value);
  public:

  // optional int64 Handle = 12;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  int64_t handle() const;
  void set_handle(int64_t value);
  private:
  int64_t _internal_handle() const;
  void _internal_set_handle(int64_t value);
  public:

  // optional uint32 ModuleVersion = 21;
  bool has_moduleversion() const;
  private:
  bool _internal_has_moduleversion() const;
  public:
  void clear_moduleversion();
  uint32_t moduleversion() const;
  void set_moduleversion(uint32_t value);
  private:
  uint32_t _internal_moduleversion() const;
  void _internal_set_moduleversion(uint32_t value);
  public:

  // optional uint32 DiskId = 23;
  bool has_diskid() const;
  private:
  bool _internal_has_diskid() const;
  public:
  void clear_diskid();
  uint32_t diskid() const;
  void set_diskid(uint32_t value);
  private:
  uint32_t _internal_diskid() const;
  void _internal_set_diskid(uint32_t value);
  public:

  // optional uint64 RequestId = 24;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint64_t requestid() const;
  void set_requestid(uint64_t value);
  private:
  uint64_t _internal_requestid() const;
  void _internal_set_requestid(uint64_t value);
  public:

  // optional uint32 RequiredMinCSVersion = 27;
  bool has_requiredmincsversion() const;
  private:
  bool _internal_has_requiredmincsversion() const;
  public:
  void clear_requiredmincsversion();
  uint32_t requiredmincsversion() const;
  void set_requiredmincsversion(uint32_t value);
  private:
  uint32_t _internal_requiredmincsversion() const;
  void _internal_set_requiredmincsversion(uint32_t value);
  public:

  // optional int32 FromType = 28;
  bool has_fromtype() const;
  private:
  bool _internal_has_fromtype() const;
  public:
  void clear_fromtype();
  int32_t fromtype() const;
  void set_fromtype(int32_t value);
  private:
  int32_t _internal_fromtype() const;
  void _internal_set_fromtype(int32_t value);
  public:

  // optional uint64 Offset64 = 29;
  bool has_offset64() const;
  private:
  bool _internal_has_offset64() const;
  public:
  void clear_offset64();
  uint64_t offset64() const;
  void set_offset64(uint64_t value);
  private:
  uint64_t _internal_offset64() const;
  void _internal_set_offset64(uint64_t value);
  public:

  // optional uint32 RecordSize = 30;
  bool has_recordsize() const;
  private:
  bool _internal_has_recordsize() const;
  public:
  void clear_recordsize();
  uint32_t recordsize() const;
  void set_recordsize(uint32_t value);
  private:
  uint32_t _internal_recordsize() const;
  void _internal_set_recordsize(uint32_t value);
  public:

  // optional uint32 PoolId = 31;
  bool has_poolid() const;
  private:
  bool _internal_has_poolid() const;
  public:
  void clear_poolid();
  uint32_t poolid() const;
  void set_poolid(uint32_t value);
  private:
  uint32_t _internal_poolid() const;
  void _internal_set_poolid(uint32_t value);
  public:

  // optional uint64 StoragePoolConfVersion = 32;
  bool has_storagepoolconfversion() const;
  private:
  bool _internal_has_storagepoolconfversion() const;
  public:
  void clear_storagepoolconfversion();
  uint64_t storagepoolconfversion() const;
  void set_storagepoolconfversion(uint64_t value);
  private:
  uint64_t _internal_storagepoolconfversion() const;
  void _internal_set_storagepoolconfversion(uint64_t value);
  public:

  // optional int32 a = 33;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  int32_t a() const;
  void set_a(int32_t value);
  private:
  int32_t _internal_a() const;
  void _internal_set_a(int32_t value);
  public:

  // optional bool DataSync = 13 [default = true];
  bool has_datasync() const;
  private:
  bool _internal_has_datasync() const;
  public:
  void clear_datasync();
  bool datasync() const;
  void set_datasync(bool value);
  private:
  bool _internal_datasync() const;
  void _internal_set_datasync(bool value);
  public:

  // @@protoc_insertion_point(class_scope:test.FlatLogFileFlushChunkRequestPB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::test::ChunkIdTypeCJPB* chunkid_;
    ::test::IONicePB* ionice_;
    ::test::AccelerateOpenOptionsPB* openchunkoptions_;
    ::test::PanguTraceSpanInfo* trace_span_;
    ::test::CsChooseDiskStrategyCJPB* strategy_;
    ::test::ChunkOrStreamIdInfoPB* chunkidv2_;
    ::test::QosOptionsPB* qosoptions_;
    ::test::FlushChecksumPB* checksum_;
    ::test::UUIDInfoPB* volumeuuid_;
    ::test::RootServerIdPB* root_server_id_;
    uint32_t offset_;
    uint32_t length_;
    uint32_t storageid_;
    uint32_t hint_;
    bool isreplication_;
    bool trace_open_;
    bool createifnotexists_;
    int32_t openmode_;
    int64_t handle_;
    uint32_t moduleversion_;
    uint32_t diskid_;
    uint64_t requestid_;
    uint32_t requiredmincsversion_;
    int32_t fromtype_;
    uint64_t offset64_;
    uint32_t recordsize_;
    uint32_t poolid_;
    uint64_t storagepoolconfversion_;
    int32_t a_;
    bool datasync_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// -------------------------------------------------------------------

class FlatLogFileFlushChunkResponsePB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:test.FlatLogFileFlushChunkResponsePB) */ {
 public:
  inline FlatLogFileFlushChunkResponsePB() : FlatLogFileFlushChunkResponsePB(nullptr) {}
  ~FlatLogFileFlushChunkResponsePB() override;
  explicit PROTOBUF_CONSTEXPR FlatLogFileFlushChunkResponsePB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlatLogFileFlushChunkResponsePB(const FlatLogFileFlushChunkResponsePB& from);
  FlatLogFileFlushChunkResponsePB(FlatLogFileFlushChunkResponsePB&& from) noexcept
    : FlatLogFileFlushChunkResponsePB() {
    *this = ::std::move(from);
  }

  inline FlatLogFileFlushChunkResponsePB& operator=(const FlatLogFileFlushChunkResponsePB& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlatLogFileFlushChunkResponsePB& operator=(FlatLogFileFlushChunkResponsePB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlatLogFileFlushChunkResponsePB& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlatLogFileFlushChunkResponsePB* internal_default_instance() {
    return reinterpret_cast<const FlatLogFileFlushChunkResponsePB*>(
               &_FlatLogFileFlushChunkResponsePB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FlatLogFileFlushChunkResponsePB& a, FlatLogFileFlushChunkResponsePB& b) {
    a.Swap(&b);
  }
  inline void Swap(FlatLogFileFlushChunkResponsePB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlatLogFileFlushChunkResponsePB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlatLogFileFlushChunkResponsePB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlatLogFileFlushChunkResponsePB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlatLogFileFlushChunkResponsePB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlatLogFileFlushChunkResponsePB& from) {
    FlatLogFileFlushChunkResponsePB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlatLogFileFlushChunkResponsePB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "test.FlatLogFileFlushChunkResponsePB";
  }
  protected:
  explicit FlatLogFileFlushChunkResponsePB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraceDataFieldNumber = 6,
    kErrorcodeFieldNumber = 1,
    kChunkStatusFieldNumber = 2,
    kHintFieldNumber = 3,
    kAckLengthFieldNumber = 4,
    kTraceTypeFieldNumber = 5,
    kStorageIdFieldNumber = 8,
    kHandleFieldNumber = 7,
    kRequestIdFieldNumber = 10,
    kChecksumFieldNumber = 11,
    kDiskIdFieldNumber = 9,
    kAFieldNumber = 13,
    kLeftReplicaSizeFieldNumber = 12,
  };
  // optional bytes trace_data = 6;
  bool has_trace_data() const;
  private:
  bool _internal_has_trace_data() const;
  public:
  void clear_trace_data();
  const std::string& trace_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_data();
  PROTOBUF_NODISCARD std::string* release_trace_data();
  void set_allocated_trace_data(std::string* trace_data);
  private:
  const std::string& _internal_trace_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_data(const std::string& value);
  std::string* _internal_mutable_trace_data();
  public:

  // optional int32 Errorcode = 1;
  bool has_errorcode() const;
  private:
  bool _internal_has_errorcode() const;
  public:
  void clear_errorcode();
  int32_t errorcode() const;
  void set_errorcode(int32_t value);
  private:
  int32_t _internal_errorcode() const;
  void _internal_set_errorcode(int32_t value);
  public:

  // optional uint32 ChunkStatus = 2 [default = 0];
  bool has_chunkstatus() const;
  private:
  bool _internal_has_chunkstatus() const;
  public:
  void clear_chunkstatus();
  uint32_t chunkstatus() const;
  void set_chunkstatus(uint32_t value);
  private:
  uint32_t _internal_chunkstatus() const;
  void _internal_set_chunkstatus(uint32_t value);
  public:

  // optional uint32 Hint = 3;
  bool has_hint() const;
  private:
  bool _internal_has_hint() const;
  public:
  void clear_hint();
  uint32_t hint() const;
  void set_hint(uint32_t value);
  private:
  uint32_t _internal_hint() const;
  void _internal_set_hint(uint32_t value);
  public:

  // optional uint32 AckLength = 4;
  bool has_acklength() const;
  private:
  bool _internal_has_acklength() const;
  public:
  void clear_acklength();
  uint32_t acklength() const;
  void set_acklength(uint32_t value);
  private:
  uint32_t _internal_acklength() const;
  void _internal_set_acklength(uint32_t value);
  public:

  // optional uint32 trace_type = 5;
  bool has_trace_type() const;
  private:
  bool _internal_has_trace_type() const;
  public:
  void clear_trace_type();
  uint32_t trace_type() const;
  void set_trace_type(uint32_t value);
  private:
  uint32_t _internal_trace_type() const;
  void _internal_set_trace_type(uint32_t value);
  public:

  // optional uint32 StorageId = 8;
  bool has_storageid() const;
  private:
  bool _internal_has_storageid() const;
  public:
  void clear_storageid();
  uint32_t storageid() const;
  void set_storageid(uint32_t value);
  private:
  uint32_t _internal_storageid() const;
  void _internal_set_storageid(uint32_t value);
  public:

  // optional int64 Handle = 7;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  int64_t handle() const;
  void set_handle(int64_t value);
  private:
  int64_t _internal_handle() const;
  void _internal_set_handle(int64_t value);
  public:

  // optional uint64 RequestId = 10;
  bool has_requestid() const;
  private:
  bool _internal_has_requestid() const;
  public:
  void clear_requestid();
  uint64_t requestid() const;
  void set_requestid(uint64_t value);
  private:
  uint64_t _internal_requestid() const;
  void _internal_set_requestid(uint64_t value);
  public:

  // optional int64 Checksum = 11;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  int64_t checksum() const;
  void set_checksum(int64_t value);
  private:
  int64_t _internal_checksum() const;
  void _internal_set_checksum(int64_t value);
  public:

  // optional uint32 DiskId = 9;
  bool has_diskid() const;
  private:
  bool _internal_has_diskid() const;
  public:
  void clear_diskid();
  uint32_t diskid() const;
  void set_diskid(uint32_t value);
  private:
  uint32_t _internal_diskid() const;
  void _internal_set_diskid(uint32_t value);
  public:

  // optional int32 a = 13;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  int32_t a() const;
  void set_a(int32_t value);
  private:
  int32_t _internal_a() const;
  void _internal_set_a(int32_t value);
  public:

  // optional uint64 LeftReplicaSize = 12;
  bool has_leftreplicasize() const;
  private:
  bool _internal_has_leftreplicasize() const;
  public:
  void clear_leftreplicasize();
  uint64_t leftreplicasize() const;
  void set_leftreplicasize(uint64_t value);
  private:
  uint64_t _internal_leftreplicasize() const;
  void _internal_set_leftreplicasize(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:test.FlatLogFileFlushChunkResponsePB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_data_;
    int32_t errorcode_;
    uint32_t chunkstatus_;
    uint32_t hint_;
    uint32_t acklength_;
    uint32_t trace_type_;
    uint32_t storageid_;
    int64_t handle_;
    uint64_t requestid_;
    int64_t checksum_;
    uint32_t diskid_;
    int32_t a_;
    uint64_t leftreplicasize_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flat_2eproto;
};
// ===================================================================

class Test_Stub;

class Test : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline Test() {};
 public:
  virtual ~Test();

  typedef Test_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void Echo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::test::FlatLogFileFlushChunkRequestPB* request,
                       ::test::FlatLogFileFlushChunkResponsePB* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Test);
};

class Test_Stub : public Test {
 public:
  Test_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  Test_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~Test_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements Test ------------------------------------------

  void Echo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::test::FlatLogFileFlushChunkRequestPB* request,
                       ::test::FlatLogFileFlushChunkResponsePB* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Test_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FixedUUIDInfoPB

// optional fixed64 low = 1;
inline bool FixedUUIDInfoPB::_internal_has_low() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FixedUUIDInfoPB::has_low() const {
  return _internal_has_low();
}
inline void FixedUUIDInfoPB::clear_low() {
  _impl_.low_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t FixedUUIDInfoPB::_internal_low() const {
  return _impl_.low_;
}
inline uint64_t FixedUUIDInfoPB::low() const {
  // @@protoc_insertion_point(field_get:test.FixedUUIDInfoPB.low)
  return _internal_low();
}
inline void FixedUUIDInfoPB::_internal_set_low(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.low_ = value;
}
inline void FixedUUIDInfoPB::set_low(uint64_t value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:test.FixedUUIDInfoPB.low)
}

// optional fixed64 high = 2;
inline bool FixedUUIDInfoPB::_internal_has_high() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FixedUUIDInfoPB::has_high() const {
  return _internal_has_high();
}
inline void FixedUUIDInfoPB::clear_high() {
  _impl_.high_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t FixedUUIDInfoPB::_internal_high() const {
  return _impl_.high_;
}
inline uint64_t FixedUUIDInfoPB::high() const {
  // @@protoc_insertion_point(field_get:test.FixedUUIDInfoPB.high)
  return _internal_high();
}
inline void FixedUUIDInfoPB::_internal_set_high(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.high_ = value;
}
inline void FixedUUIDInfoPB::set_high(uint64_t value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:test.FixedUUIDInfoPB.high)
}

// -------------------------------------------------------------------

// MirrorArgsPB

// optional int32 Copy = 1;
inline bool MirrorArgsPB::_internal_has_copy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MirrorArgsPB::has_copy() const {
  return _internal_has_copy();
}
inline void MirrorArgsPB::clear_copy() {
  _impl_.copy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t MirrorArgsPB::_internal_copy() const {
  return _impl_.copy_;
}
inline int32_t MirrorArgsPB::copy() const {
  // @@protoc_insertion_point(field_get:test.MirrorArgsPB.Copy)
  return _internal_copy();
}
inline void MirrorArgsPB::_internal_set_copy(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.copy_ = value;
}
inline void MirrorArgsPB::set_copy(int32_t value) {
  _internal_set_copy(value);
  // @@protoc_insertion_point(field_set:test.MirrorArgsPB.Copy)
}

// optional int32 FTT = 2;
inline bool MirrorArgsPB::_internal_has_ftt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MirrorArgsPB::has_ftt() const {
  return _internal_has_ftt();
}
inline void MirrorArgsPB::clear_ftt() {
  _impl_.ftt_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t MirrorArgsPB::_internal_ftt() const {
  return _impl_.ftt_;
}
inline int32_t MirrorArgsPB::ftt() const {
  // @@protoc_insertion_point(field_get:test.MirrorArgsPB.FTT)
  return _internal_ftt();
}
inline void MirrorArgsPB::_internal_set_ftt(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ftt_ = value;
}
inline void MirrorArgsPB::set_ftt(int32_t value) {
  _internal_set_ftt(value);
  // @@protoc_insertion_point(field_set:test.MirrorArgsPB.FTT)
}

// -------------------------------------------------------------------

// ChunkOptionsPB

// optional int32 FTTType = 1;
inline bool ChunkOptionsPB::_internal_has_ftttype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChunkOptionsPB::has_ftttype() const {
  return _internal_has_ftttype();
}
inline void ChunkOptionsPB::clear_ftttype() {
  _impl_.ftttype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t ChunkOptionsPB::_internal_ftttype() const {
  return _impl_.ftttype_;
}
inline int32_t ChunkOptionsPB::ftttype() const {
  // @@protoc_insertion_point(field_get:test.ChunkOptionsPB.FTTType)
  return _internal_ftttype();
}
inline void ChunkOptionsPB::_internal_set_ftttype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ftttype_ = value;
}
inline void ChunkOptionsPB::set_ftttype(int32_t value) {
  _internal_set_ftttype(value);
  // @@protoc_insertion_point(field_set:test.ChunkOptionsPB.FTTType)
}

// optional .test.MirrorArgsPB Mirror = 2;
inline bool ChunkOptionsPB::_internal_has_mirror() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mirror_ != nullptr);
  return value;
}
inline bool ChunkOptionsPB::has_mirror() const {
  return _internal_has_mirror();
}
inline void ChunkOptionsPB::clear_mirror() {
  if (_impl_.mirror_ != nullptr) _impl_.mirror_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::test::MirrorArgsPB& ChunkOptionsPB::_internal_mirror() const {
  const ::test::MirrorArgsPB* p = _impl_.mirror_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::MirrorArgsPB&>(
      ::test::_MirrorArgsPB_default_instance_);
}
inline const ::test::MirrorArgsPB& ChunkOptionsPB::mirror() const {
  // @@protoc_insertion_point(field_get:test.ChunkOptionsPB.Mirror)
  return _internal_mirror();
}
inline void ChunkOptionsPB::unsafe_arena_set_allocated_mirror(
    ::test::MirrorArgsPB* mirror) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mirror_);
  }
  _impl_.mirror_ = mirror;
  if (mirror) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.ChunkOptionsPB.Mirror)
}
inline ::test::MirrorArgsPB* ChunkOptionsPB::release_mirror() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::test::MirrorArgsPB* temp = _impl_.mirror_;
  _impl_.mirror_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::MirrorArgsPB* ChunkOptionsPB::unsafe_arena_release_mirror() {
  // @@protoc_insertion_point(field_release:test.ChunkOptionsPB.Mirror)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::test::MirrorArgsPB* temp = _impl_.mirror_;
  _impl_.mirror_ = nullptr;
  return temp;
}
inline ::test::MirrorArgsPB* ChunkOptionsPB::_internal_mutable_mirror() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.mirror_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::MirrorArgsPB>(GetArenaForAllocation());
    _impl_.mirror_ = p;
  }
  return _impl_.mirror_;
}
inline ::test::MirrorArgsPB* ChunkOptionsPB::mutable_mirror() {
  ::test::MirrorArgsPB* _msg = _internal_mutable_mirror();
  // @@protoc_insertion_point(field_mutable:test.ChunkOptionsPB.Mirror)
  return _msg;
}
inline void ChunkOptionsPB::set_allocated_mirror(::test::MirrorArgsPB* mirror) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mirror_;
  }
  if (mirror) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mirror);
    if (message_arena != submessage_arena) {
      mirror = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mirror, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mirror_ = mirror;
  // @@protoc_insertion_point(field_set_allocated:test.ChunkOptionsPB.Mirror)
}

// optional bytes Placement = 3;
inline bool ChunkOptionsPB::_internal_has_placement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChunkOptionsPB::has_placement() const {
  return _internal_has_placement();
}
inline void ChunkOptionsPB::clear_placement() {
  _impl_.placement_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChunkOptionsPB::placement() const {
  // @@protoc_insertion_point(field_get:test.ChunkOptionsPB.Placement)
  return _internal_placement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChunkOptionsPB::set_placement(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.placement_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:test.ChunkOptionsPB.Placement)
}
inline std::string* ChunkOptionsPB::mutable_placement() {
  std::string* _s = _internal_mutable_placement();
  // @@protoc_insertion_point(field_mutable:test.ChunkOptionsPB.Placement)
  return _s;
}
inline const std::string& ChunkOptionsPB::_internal_placement() const {
  return _impl_.placement_.Get();
}
inline void ChunkOptionsPB::_internal_set_placement(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.placement_.Set(value, GetArenaForAllocation());
}
inline std::string* ChunkOptionsPB::_internal_mutable_placement() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.placement_.Mutable(GetArenaForAllocation());
}
inline std::string* ChunkOptionsPB::release_placement() {
  // @@protoc_insertion_point(field_release:test.ChunkOptionsPB.Placement)
  if (!_internal_has_placement()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.placement_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.placement_.IsDefault()) {
    _impl_.placement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChunkOptionsPB::set_allocated_placement(std::string* placement) {
  if (placement != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.placement_.SetAllocated(placement, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.placement_.IsDefault()) {
    _impl_.placement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:test.ChunkOptionsPB.Placement)
}

// -------------------------------------------------------------------

// ReplicaLocationPB

// optional bytes CSLocation = 1;
inline bool ReplicaLocationPB::_internal_has_cslocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReplicaLocationPB::has_cslocation() const {
  return _internal_has_cslocation();
}
inline void ReplicaLocationPB::clear_cslocation() {
  _impl_.cslocation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplicaLocationPB::cslocation() const {
  // @@protoc_insertion_point(field_get:test.ReplicaLocationPB.CSLocation)
  return _internal_cslocation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplicaLocationPB::set_cslocation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cslocation_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:test.ReplicaLocationPB.CSLocation)
}
inline std::string* ReplicaLocationPB::mutable_cslocation() {
  std::string* _s = _internal_mutable_cslocation();
  // @@protoc_insertion_point(field_mutable:test.ReplicaLocationPB.CSLocation)
  return _s;
}
inline const std::string& ReplicaLocationPB::_internal_cslocation() const {
  return _impl_.cslocation_.Get();
}
inline void ReplicaLocationPB::_internal_set_cslocation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cslocation_.Set(value, GetArenaForAllocation());
}
inline std::string* ReplicaLocationPB::_internal_mutable_cslocation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cslocation_.Mutable(GetArenaForAllocation());
}
inline std::string* ReplicaLocationPB::release_cslocation() {
  // @@protoc_insertion_point(field_release:test.ReplicaLocationPB.CSLocation)
  if (!_internal_has_cslocation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cslocation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cslocation_.IsDefault()) {
    _impl_.cslocation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReplicaLocationPB::set_allocated_cslocation(std::string* cslocation) {
  if (cslocation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cslocation_.SetAllocated(cslocation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cslocation_.IsDefault()) {
    _impl_.cslocation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:test.ReplicaLocationPB.CSLocation)
}

// optional int32 diskLocation = 2;
inline bool ReplicaLocationPB::_internal_has_disklocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReplicaLocationPB::has_disklocation() const {
  return _internal_has_disklocation();
}
inline void ReplicaLocationPB::clear_disklocation() {
  _impl_.disklocation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ReplicaLocationPB::_internal_disklocation() const {
  return _impl_.disklocation_;
}
inline int32_t ReplicaLocationPB::disklocation() const {
  // @@protoc_insertion_point(field_get:test.ReplicaLocationPB.diskLocation)
  return _internal_disklocation();
}
inline void ReplicaLocationPB::_internal_set_disklocation(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.disklocation_ = value;
}
inline void ReplicaLocationPB::set_disklocation(int32_t value) {
  _internal_set_disklocation(value);
  // @@protoc_insertion_point(field_set:test.ReplicaLocationPB.diskLocation)
}

// optional uint32 diskType = 3;
inline bool ReplicaLocationPB::_internal_has_disktype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReplicaLocationPB::has_disktype() const {
  return _internal_has_disktype();
}
inline void ReplicaLocationPB::clear_disktype() {
  _impl_.disktype_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ReplicaLocationPB::_internal_disktype() const {
  return _impl_.disktype_;
}
inline uint32_t ReplicaLocationPB::disktype() const {
  // @@protoc_insertion_point(field_get:test.ReplicaLocationPB.diskType)
  return _internal_disktype();
}
inline void ReplicaLocationPB::_internal_set_disktype(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.disktype_ = value;
}
inline void ReplicaLocationPB::set_disktype(uint32_t value) {
  _internal_set_disktype(value);
  // @@protoc_insertion_point(field_set:test.ReplicaLocationPB.diskType)
}

// -------------------------------------------------------------------

// AccelerateOpenOptionsPB

// optional .test.ChunkOptionsPB ChunkOptions = 1;
inline bool AccelerateOpenOptionsPB::_internal_has_chunkoptions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chunkoptions_ != nullptr);
  return value;
}
inline bool AccelerateOpenOptionsPB::has_chunkoptions() const {
  return _internal_has_chunkoptions();
}
inline void AccelerateOpenOptionsPB::clear_chunkoptions() {
  if (_impl_.chunkoptions_ != nullptr) _impl_.chunkoptions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::test::ChunkOptionsPB& AccelerateOpenOptionsPB::_internal_chunkoptions() const {
  const ::test::ChunkOptionsPB* p = _impl_.chunkoptions_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::ChunkOptionsPB&>(
      ::test::_ChunkOptionsPB_default_instance_);
}
inline const ::test::ChunkOptionsPB& AccelerateOpenOptionsPB::chunkoptions() const {
  // @@protoc_insertion_point(field_get:test.AccelerateOpenOptionsPB.ChunkOptions)
  return _internal_chunkoptions();
}
inline void AccelerateOpenOptionsPB::unsafe_arena_set_allocated_chunkoptions(
    ::test::ChunkOptionsPB* chunkoptions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunkoptions_);
  }
  _impl_.chunkoptions_ = chunkoptions;
  if (chunkoptions) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.AccelerateOpenOptionsPB.ChunkOptions)
}
inline ::test::ChunkOptionsPB* AccelerateOpenOptionsPB::release_chunkoptions() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::test::ChunkOptionsPB* temp = _impl_.chunkoptions_;
  _impl_.chunkoptions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::ChunkOptionsPB* AccelerateOpenOptionsPB::unsafe_arena_release_chunkoptions() {
  // @@protoc_insertion_point(field_release:test.AccelerateOpenOptionsPB.ChunkOptions)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::test::ChunkOptionsPB* temp = _impl_.chunkoptions_;
  _impl_.chunkoptions_ = nullptr;
  return temp;
}
inline ::test::ChunkOptionsPB* AccelerateOpenOptionsPB::_internal_mutable_chunkoptions() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.chunkoptions_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::ChunkOptionsPB>(GetArenaForAllocation());
    _impl_.chunkoptions_ = p;
  }
  return _impl_.chunkoptions_;
}
inline ::test::ChunkOptionsPB* AccelerateOpenOptionsPB::mutable_chunkoptions() {
  ::test::ChunkOptionsPB* _msg = _internal_mutable_chunkoptions();
  // @@protoc_insertion_point(field_mutable:test.AccelerateOpenOptionsPB.ChunkOptions)
  return _msg;
}
inline void AccelerateOpenOptionsPB::set_allocated_chunkoptions(::test::ChunkOptionsPB* chunkoptions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chunkoptions_;
  }
  if (chunkoptions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chunkoptions);
    if (message_arena != submessage_arena) {
      chunkoptions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunkoptions, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chunkoptions_ = chunkoptions;
  // @@protoc_insertion_point(field_set_allocated:test.AccelerateOpenOptionsPB.ChunkOptions)
}

// repeated .test.ReplicaLocationPB ChunkLocation = 2;
inline int AccelerateOpenOptionsPB::_internal_chunklocation_size() const {
  return _impl_.chunklocation_.size();
}
inline int AccelerateOpenOptionsPB::chunklocation_size() const {
  return _internal_chunklocation_size();
}
inline void AccelerateOpenOptionsPB::clear_chunklocation() {
  _impl_.chunklocation_.Clear();
}
inline ::test::ReplicaLocationPB* AccelerateOpenOptionsPB::mutable_chunklocation(int index) {
  // @@protoc_insertion_point(field_mutable:test.AccelerateOpenOptionsPB.ChunkLocation)
  return _impl_.chunklocation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::ReplicaLocationPB >*
AccelerateOpenOptionsPB::mutable_chunklocation() {
  // @@protoc_insertion_point(field_mutable_list:test.AccelerateOpenOptionsPB.ChunkLocation)
  return &_impl_.chunklocation_;
}
inline const ::test::ReplicaLocationPB& AccelerateOpenOptionsPB::_internal_chunklocation(int index) const {
  return _impl_.chunklocation_.Get(index);
}
inline const ::test::ReplicaLocationPB& AccelerateOpenOptionsPB::chunklocation(int index) const {
  // @@protoc_insertion_point(field_get:test.AccelerateOpenOptionsPB.ChunkLocation)
  return _internal_chunklocation(index);
}
inline ::test::ReplicaLocationPB* AccelerateOpenOptionsPB::_internal_add_chunklocation() {
  return _impl_.chunklocation_.Add();
}
inline ::test::ReplicaLocationPB* AccelerateOpenOptionsPB::add_chunklocation() {
  ::test::ReplicaLocationPB* _add = _internal_add_chunklocation();
  // @@protoc_insertion_point(field_add:test.AccelerateOpenOptionsPB.ChunkLocation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::ReplicaLocationPB >&
AccelerateOpenOptionsPB::chunklocation() const {
  // @@protoc_insertion_point(field_list:test.AccelerateOpenOptionsPB.ChunkLocation)
  return _impl_.chunklocation_;
}

// optional uint32 chunkSizeExponent = 3;
inline bool AccelerateOpenOptionsPB::_internal_has_chunksizeexponent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AccelerateOpenOptionsPB::has_chunksizeexponent() const {
  return _internal_has_chunksizeexponent();
}
inline void AccelerateOpenOptionsPB::clear_chunksizeexponent() {
  _impl_.chunksizeexponent_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AccelerateOpenOptionsPB::_internal_chunksizeexponent() const {
  return _impl_.chunksizeexponent_;
}
inline uint32_t AccelerateOpenOptionsPB::chunksizeexponent() const {
  // @@protoc_insertion_point(field_get:test.AccelerateOpenOptionsPB.chunkSizeExponent)
  return _internal_chunksizeexponent();
}
inline void AccelerateOpenOptionsPB::_internal_set_chunksizeexponent(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chunksizeexponent_ = value;
}
inline void AccelerateOpenOptionsPB::set_chunksizeexponent(uint32_t value) {
  _internal_set_chunksizeexponent(value);
  // @@protoc_insertion_point(field_set:test.AccelerateOpenOptionsPB.chunkSizeExponent)
}

// optional uint32 checksumCategory = 4;
inline bool AccelerateOpenOptionsPB::_internal_has_checksumcategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AccelerateOpenOptionsPB::has_checksumcategory() const {
  return _internal_has_checksumcategory();
}
inline void AccelerateOpenOptionsPB::clear_checksumcategory() {
  _impl_.checksumcategory_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AccelerateOpenOptionsPB::_internal_checksumcategory() const {
  return _impl_.checksumcategory_;
}
inline uint32_t AccelerateOpenOptionsPB::checksumcategory() const {
  // @@protoc_insertion_point(field_get:test.AccelerateOpenOptionsPB.checksumCategory)
  return _internal_checksumcategory();
}
inline void AccelerateOpenOptionsPB::_internal_set_checksumcategory(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.checksumcategory_ = value;
}
inline void AccelerateOpenOptionsPB::set_checksumcategory(uint32_t value) {
  _internal_set_checksumcategory(value);
  // @@protoc_insertion_point(field_set:test.AccelerateOpenOptionsPB.checksumCategory)
}

// -------------------------------------------------------------------

// IONicePB

// optional int32 Priority = 1;
inline bool IONicePB::_internal_has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IONicePB::has_priority() const {
  return _internal_has_priority();
}
inline void IONicePB::clear_priority() {
  _impl_.priority_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t IONicePB::_internal_priority() const {
  return _impl_.priority_;
}
inline int32_t IONicePB::priority() const {
  // @@protoc_insertion_point(field_get:test.IONicePB.Priority)
  return _internal_priority();
}
inline void IONicePB::_internal_set_priority(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.priority_ = value;
}
inline void IONicePB::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:test.IONicePB.Priority)
}

// optional int32 IOClass = 2;
inline bool IONicePB::_internal_has_ioclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IONicePB::has_ioclass() const {
  return _internal_has_ioclass();
}
inline void IONicePB::clear_ioclass() {
  _impl_.ioclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t IONicePB::_internal_ioclass() const {
  return _impl_.ioclass_;
}
inline int32_t IONicePB::ioclass() const {
  // @@protoc_insertion_point(field_get:test.IONicePB.IOClass)
  return _internal_ioclass();
}
inline void IONicePB::_internal_set_ioclass(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ioclass_ = value;
}
inline void IONicePB::set_ioclass(int32_t value) {
  _internal_set_ioclass(value);
  // @@protoc_insertion_point(field_set:test.IONicePB.IOClass)
}

// -------------------------------------------------------------------

// CsChooseDiskStrategyCJPB

// repeated .test.CsChooseDiskStrategySingleCJPB Strategies = 1;
inline int CsChooseDiskStrategyCJPB::_internal_strategies_size() const {
  return _impl_.strategies_.size();
}
inline int CsChooseDiskStrategyCJPB::strategies_size() const {
  return _internal_strategies_size();
}
inline void CsChooseDiskStrategyCJPB::clear_strategies() {
  _impl_.strategies_.Clear();
}
inline ::test::CsChooseDiskStrategySingleCJPB* CsChooseDiskStrategyCJPB::mutable_strategies(int index) {
  // @@protoc_insertion_point(field_mutable:test.CsChooseDiskStrategyCJPB.Strategies)
  return _impl_.strategies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::CsChooseDiskStrategySingleCJPB >*
CsChooseDiskStrategyCJPB::mutable_strategies() {
  // @@protoc_insertion_point(field_mutable_list:test.CsChooseDiskStrategyCJPB.Strategies)
  return &_impl_.strategies_;
}
inline const ::test::CsChooseDiskStrategySingleCJPB& CsChooseDiskStrategyCJPB::_internal_strategies(int index) const {
  return _impl_.strategies_.Get(index);
}
inline const ::test::CsChooseDiskStrategySingleCJPB& CsChooseDiskStrategyCJPB::strategies(int index) const {
  // @@protoc_insertion_point(field_get:test.CsChooseDiskStrategyCJPB.Strategies)
  return _internal_strategies(index);
}
inline ::test::CsChooseDiskStrategySingleCJPB* CsChooseDiskStrategyCJPB::_internal_add_strategies() {
  return _impl_.strategies_.Add();
}
inline ::test::CsChooseDiskStrategySingleCJPB* CsChooseDiskStrategyCJPB::add_strategies() {
  ::test::CsChooseDiskStrategySingleCJPB* _add = _internal_add_strategies();
  // @@protoc_insertion_point(field_add:test.CsChooseDiskStrategyCJPB.Strategies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::test::CsChooseDiskStrategySingleCJPB >&
CsChooseDiskStrategyCJPB::strategies() const {
  // @@protoc_insertion_point(field_list:test.CsChooseDiskStrategyCJPB.Strategies)
  return _impl_.strategies_;
}

// optional int32 DiskStorageType = 2;
inline bool CsChooseDiskStrategyCJPB::_internal_has_diskstoragetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CsChooseDiskStrategyCJPB::has_diskstoragetype() const {
  return _internal_has_diskstoragetype();
}
inline void CsChooseDiskStrategyCJPB::clear_diskstoragetype() {
  _impl_.diskstoragetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CsChooseDiskStrategyCJPB::_internal_diskstoragetype() const {
  return _impl_.diskstoragetype_;
}
inline int32_t CsChooseDiskStrategyCJPB::diskstoragetype() const {
  // @@protoc_insertion_point(field_get:test.CsChooseDiskStrategyCJPB.DiskStorageType)
  return _internal_diskstoragetype();
}
inline void CsChooseDiskStrategyCJPB::_internal_set_diskstoragetype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.diskstoragetype_ = value;
}
inline void CsChooseDiskStrategyCJPB::set_diskstoragetype(int32_t value) {
  _internal_set_diskstoragetype(value);
  // @@protoc_insertion_point(field_set:test.CsChooseDiskStrategyCJPB.DiskStorageType)
}

// optional int32 TargetStorageType = 3;
inline bool CsChooseDiskStrategyCJPB::_internal_has_targetstoragetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CsChooseDiskStrategyCJPB::has_targetstoragetype() const {
  return _internal_has_targetstoragetype();
}
inline void CsChooseDiskStrategyCJPB::clear_targetstoragetype() {
  _impl_.targetstoragetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CsChooseDiskStrategyCJPB::_internal_targetstoragetype() const {
  return _impl_.targetstoragetype_;
}
inline int32_t CsChooseDiskStrategyCJPB::targetstoragetype() const {
  // @@protoc_insertion_point(field_get:test.CsChooseDiskStrategyCJPB.TargetStorageType)
  return _internal_targetstoragetype();
}
inline void CsChooseDiskStrategyCJPB::_internal_set_targetstoragetype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.targetstoragetype_ = value;
}
inline void CsChooseDiskStrategyCJPB::set_targetstoragetype(int32_t value) {
  _internal_set_targetstoragetype(value);
  // @@protoc_insertion_point(field_set:test.CsChooseDiskStrategyCJPB.TargetStorageType)
}

// -------------------------------------------------------------------

// ChunkOrStreamIdInfoPB

// optional .test.UUIDInfoPB uuid = 1;
inline bool ChunkOrStreamIdInfoPB::_internal_has_uuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.uuid_ != nullptr);
  return value;
}
inline bool ChunkOrStreamIdInfoPB::has_uuid() const {
  return _internal_has_uuid();
}
inline void ChunkOrStreamIdInfoPB::clear_uuid() {
  if (_impl_.uuid_ != nullptr) _impl_.uuid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::test::UUIDInfoPB& ChunkOrStreamIdInfoPB::_internal_uuid() const {
  const ::test::UUIDInfoPB* p = _impl_.uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::UUIDInfoPB&>(
      ::test::_UUIDInfoPB_default_instance_);
}
inline const ::test::UUIDInfoPB& ChunkOrStreamIdInfoPB::uuid() const {
  // @@protoc_insertion_point(field_get:test.ChunkOrStreamIdInfoPB.uuid)
  return _internal_uuid();
}
inline void ChunkOrStreamIdInfoPB::unsafe_arena_set_allocated_uuid(
    ::test::UUIDInfoPB* uuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uuid_);
  }
  _impl_.uuid_ = uuid;
  if (uuid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.ChunkOrStreamIdInfoPB.uuid)
}
inline ::test::UUIDInfoPB* ChunkOrStreamIdInfoPB::release_uuid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::test::UUIDInfoPB* temp = _impl_.uuid_;
  _impl_.uuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::UUIDInfoPB* ChunkOrStreamIdInfoPB::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_release:test.ChunkOrStreamIdInfoPB.uuid)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::test::UUIDInfoPB* temp = _impl_.uuid_;
  _impl_.uuid_ = nullptr;
  return temp;
}
inline ::test::UUIDInfoPB* ChunkOrStreamIdInfoPB::_internal_mutable_uuid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::UUIDInfoPB>(GetArenaForAllocation());
    _impl_.uuid_ = p;
  }
  return _impl_.uuid_;
}
inline ::test::UUIDInfoPB* ChunkOrStreamIdInfoPB::mutable_uuid() {
  ::test::UUIDInfoPB* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:test.ChunkOrStreamIdInfoPB.uuid)
  return _msg;
}
inline void ChunkOrStreamIdInfoPB::set_allocated_uuid(::test::UUIDInfoPB* uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uuid_;
  }
  if (uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uuid);
    if (message_arena != submessage_arena) {
      uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:test.ChunkOrStreamIdInfoPB.uuid)
}

// optional uint32 partition_index = 2;
inline bool ChunkOrStreamIdInfoPB::_internal_has_partition_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChunkOrStreamIdInfoPB::has_partition_index() const {
  return _internal_has_partition_index();
}
inline void ChunkOrStreamIdInfoPB::clear_partition_index() {
  _impl_.partition_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ChunkOrStreamIdInfoPB::_internal_partition_index() const {
  return _impl_.partition_index_;
}
inline uint32_t ChunkOrStreamIdInfoPB::partition_index() const {
  // @@protoc_insertion_point(field_get:test.ChunkOrStreamIdInfoPB.partition_index)
  return _internal_partition_index();
}
inline void ChunkOrStreamIdInfoPB::_internal_set_partition_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.partition_index_ = value;
}
inline void ChunkOrStreamIdInfoPB::set_partition_index(uint32_t value) {
  _internal_set_partition_index(value);
  // @@protoc_insertion_point(field_set:test.ChunkOrStreamIdInfoPB.partition_index)
}

// optional uint32 padding = 3;
inline bool ChunkOrStreamIdInfoPB::_internal_has_padding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChunkOrStreamIdInfoPB::has_padding() const {
  return _internal_has_padding();
}
inline void ChunkOrStreamIdInfoPB::clear_padding() {
  _impl_.padding_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ChunkOrStreamIdInfoPB::_internal_padding() const {
  return _impl_.padding_;
}
inline uint32_t ChunkOrStreamIdInfoPB::padding() const {
  // @@protoc_insertion_point(field_get:test.ChunkOrStreamIdInfoPB.padding)
  return _internal_padding();
}
inline void ChunkOrStreamIdInfoPB::_internal_set_padding(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.padding_ = value;
}
inline void ChunkOrStreamIdInfoPB::set_padding(uint32_t value) {
  _internal_set_padding(value);
  // @@protoc_insertion_point(field_set:test.ChunkOrStreamIdInfoPB.padding)
}

// -------------------------------------------------------------------

// QosOptionsPB

// optional uint32 serviceId = 1;
inline bool QosOptionsPB::_internal_has_serviceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QosOptionsPB::has_serviceid() const {
  return _internal_has_serviceid();
}
inline void QosOptionsPB::clear_serviceid() {
  _impl_.serviceid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t QosOptionsPB::_internal_serviceid() const {
  return _impl_.serviceid_;
}
inline uint32_t QosOptionsPB::serviceid() const {
  // @@protoc_insertion_point(field_get:test.QosOptionsPB.serviceId)
  return _internal_serviceid();
}
inline void QosOptionsPB::_internal_set_serviceid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serviceid_ = value;
}
inline void QosOptionsPB::set_serviceid(uint32_t value) {
  _internal_set_serviceid(value);
  // @@protoc_insertion_point(field_set:test.QosOptionsPB.serviceId)
}

// optional uint32 flowId = 2;
inline bool QosOptionsPB::_internal_has_flowid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QosOptionsPB::has_flowid() const {
  return _internal_has_flowid();
}
inline void QosOptionsPB::clear_flowid() {
  _impl_.flowid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t QosOptionsPB::_internal_flowid() const {
  return _impl_.flowid_;
}
inline uint32_t QosOptionsPB::flowid() const {
  // @@protoc_insertion_point(field_get:test.QosOptionsPB.flowId)
  return _internal_flowid();
}
inline void QosOptionsPB::_internal_set_flowid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.flowid_ = value;
}
inline void QosOptionsPB::set_flowid(uint32_t value) {
  _internal_set_flowid(value);
  // @@protoc_insertion_point(field_set:test.QosOptionsPB.flowId)
}

// optional int32 adjust = 3;
inline bool QosOptionsPB::_internal_has_adjust() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QosOptionsPB::has_adjust() const {
  return _internal_has_adjust();
}
inline void QosOptionsPB::clear_adjust() {
  _impl_.adjust_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t QosOptionsPB::_internal_adjust() const {
  return _impl_.adjust_;
}
inline int32_t QosOptionsPB::adjust() const {
  // @@protoc_insertion_point(field_get:test.QosOptionsPB.adjust)
  return _internal_adjust();
}
inline void QosOptionsPB::_internal_set_adjust(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.adjust_ = value;
}
inline void QosOptionsPB::set_adjust(int32_t value) {
  _internal_set_adjust(value);
  // @@protoc_insertion_point(field_set:test.QosOptionsPB.adjust)
}

// optional uint32 cacheGroupId = 4 [default = 0];
inline bool QosOptionsPB::_internal_has_cachegroupid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QosOptionsPB::has_cachegroupid() const {
  return _internal_has_cachegroupid();
}
inline void QosOptionsPB::clear_cachegroupid() {
  _impl_.cachegroupid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t QosOptionsPB::_internal_cachegroupid() const {
  return _impl_.cachegroupid_;
}
inline uint32_t QosOptionsPB::cachegroupid() const {
  // @@protoc_insertion_point(field_get:test.QosOptionsPB.cacheGroupId)
  return _internal_cachegroupid();
}
inline void QosOptionsPB::_internal_set_cachegroupid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cachegroupid_ = value;
}
inline void QosOptionsPB::set_cachegroupid(uint32_t value) {
  _internal_set_cachegroupid(value);
  // @@protoc_insertion_point(field_set:test.QosOptionsPB.cacheGroupId)
}

// optional int32 networkPriority = 5;
inline bool QosOptionsPB::_internal_has_networkpriority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QosOptionsPB::has_networkpriority() const {
  return _internal_has_networkpriority();
}
inline void QosOptionsPB::clear_networkpriority() {
  _impl_.networkpriority_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t QosOptionsPB::_internal_networkpriority() const {
  return _impl_.networkpriority_;
}
inline int32_t QosOptionsPB::networkpriority() const {
  // @@protoc_insertion_point(field_get:test.QosOptionsPB.networkPriority)
  return _internal_networkpriority();
}
inline void QosOptionsPB::_internal_set_networkpriority(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.networkpriority_ = value;
}
inline void QosOptionsPB::set_networkpriority(int32_t value) {
  _internal_set_networkpriority(value);
  // @@protoc_insertion_point(field_set:test.QosOptionsPB.networkPriority)
}

// -------------------------------------------------------------------

// FlushChecksumPB

// optional uint32 category = 1;
inline bool FlushChecksumPB::_internal_has_category() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FlushChecksumPB::has_category() const {
  return _internal_has_category();
}
inline void FlushChecksumPB::clear_category() {
  _impl_.category_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t FlushChecksumPB::_internal_category() const {
  return _impl_.category_;
}
inline uint32_t FlushChecksumPB::category() const {
  // @@protoc_insertion_point(field_get:test.FlushChecksumPB.category)
  return _internal_category();
}
inline void FlushChecksumPB::_internal_set_category(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.category_ = value;
}
inline void FlushChecksumPB::set_category(uint32_t value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:test.FlushChecksumPB.category)
}

// optional int64 value = 2;
inline bool FlushChecksumPB::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FlushChecksumPB::has_value() const {
  return _internal_has_value();
}
inline void FlushChecksumPB::clear_value() {
  _impl_.value_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t FlushChecksumPB::_internal_value() const {
  return _impl_.value_;
}
inline int64_t FlushChecksumPB::value() const {
  // @@protoc_insertion_point(field_get:test.FlushChecksumPB.value)
  return _internal_value();
}
inline void FlushChecksumPB::_internal_set_value(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_ = value;
}
inline void FlushChecksumPB::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:test.FlushChecksumPB.value)
}

// -------------------------------------------------------------------

// UUIDInfoPB

// optional uint64 low = 1;
inline bool UUIDInfoPB::_internal_has_low() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UUIDInfoPB::has_low() const {
  return _internal_has_low();
}
inline void UUIDInfoPB::clear_low() {
  _impl_.low_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t UUIDInfoPB::_internal_low() const {
  return _impl_.low_;
}
inline uint64_t UUIDInfoPB::low() const {
  // @@protoc_insertion_point(field_get:test.UUIDInfoPB.low)
  return _internal_low();
}
inline void UUIDInfoPB::_internal_set_low(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.low_ = value;
}
inline void UUIDInfoPB::set_low(uint64_t value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:test.UUIDInfoPB.low)
}

// optional uint64 high = 2;
inline bool UUIDInfoPB::_internal_has_high() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UUIDInfoPB::has_high() const {
  return _internal_has_high();
}
inline void UUIDInfoPB::clear_high() {
  _impl_.high_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UUIDInfoPB::_internal_high() const {
  return _impl_.high_;
}
inline uint64_t UUIDInfoPB::high() const {
  // @@protoc_insertion_point(field_get:test.UUIDInfoPB.high)
  return _internal_high();
}
inline void UUIDInfoPB::_internal_set_high(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.high_ = value;
}
inline void UUIDInfoPB::set_high(uint64_t value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:test.UUIDInfoPB.high)
}

// -------------------------------------------------------------------

// RootServerIdPB

// optional .test.UUIDInfoPB uuid = 1;
inline bool RootServerIdPB::_internal_has_uuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.uuid_ != nullptr);
  return value;
}
inline bool RootServerIdPB::has_uuid() const {
  return _internal_has_uuid();
}
inline void RootServerIdPB::clear_uuid() {
  if (_impl_.uuid_ != nullptr) _impl_.uuid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::test::UUIDInfoPB& RootServerIdPB::_internal_uuid() const {
  const ::test::UUIDInfoPB* p = _impl_.uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::UUIDInfoPB&>(
      ::test::_UUIDInfoPB_default_instance_);
}
inline const ::test::UUIDInfoPB& RootServerIdPB::uuid() const {
  // @@protoc_insertion_point(field_get:test.RootServerIdPB.uuid)
  return _internal_uuid();
}
inline void RootServerIdPB::unsafe_arena_set_allocated_uuid(
    ::test::UUIDInfoPB* uuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uuid_);
  }
  _impl_.uuid_ = uuid;
  if (uuid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.RootServerIdPB.uuid)
}
inline ::test::UUIDInfoPB* RootServerIdPB::release_uuid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::test::UUIDInfoPB* temp = _impl_.uuid_;
  _impl_.uuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::UUIDInfoPB* RootServerIdPB::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_release:test.RootServerIdPB.uuid)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::test::UUIDInfoPB* temp = _impl_.uuid_;
  _impl_.uuid_ = nullptr;
  return temp;
}
inline ::test::UUIDInfoPB* RootServerIdPB::_internal_mutable_uuid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::UUIDInfoPB>(GetArenaForAllocation());
    _impl_.uuid_ = p;
  }
  return _impl_.uuid_;
}
inline ::test::UUIDInfoPB* RootServerIdPB::mutable_uuid() {
  ::test::UUIDInfoPB* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:test.RootServerIdPB.uuid)
  return _msg;
}
inline void RootServerIdPB::set_allocated_uuid(::test::UUIDInfoPB* uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uuid_;
  }
  if (uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uuid);
    if (message_arena != submessage_arena) {
      uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:test.RootServerIdPB.uuid)
}

// optional int64 leader_term = 2;
inline bool RootServerIdPB::_internal_has_leader_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RootServerIdPB::has_leader_term() const {
  return _internal_has_leader_term();
}
inline void RootServerIdPB::clear_leader_term() {
  _impl_.leader_term_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t RootServerIdPB::_internal_leader_term() const {
  return _impl_.leader_term_;
}
inline int64_t RootServerIdPB::leader_term() const {
  // @@protoc_insertion_point(field_get:test.RootServerIdPB.leader_term)
  return _internal_leader_term();
}
inline void RootServerIdPB::_internal_set_leader_term(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.leader_term_ = value;
}
inline void RootServerIdPB::set_leader_term(int64_t value) {
  _internal_set_leader_term(value);
  // @@protoc_insertion_point(field_set:test.RootServerIdPB.leader_term)
}

// -------------------------------------------------------------------

// ChunkIdTypeCJPB

// optional uint64 BelongedFileId = 1;
inline bool ChunkIdTypeCJPB::_internal_has_belongedfileid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChunkIdTypeCJPB::has_belongedfileid() const {
  return _internal_has_belongedfileid();
}
inline void ChunkIdTypeCJPB::clear_belongedfileid() {
  _impl_.belongedfileid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ChunkIdTypeCJPB::_internal_belongedfileid() const {
  return _impl_.belongedfileid_;
}
inline uint64_t ChunkIdTypeCJPB::belongedfileid() const {
  // @@protoc_insertion_point(field_get:test.ChunkIdTypeCJPB.BelongedFileId)
  return _internal_belongedfileid();
}
inline void ChunkIdTypeCJPB::_internal_set_belongedfileid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.belongedfileid_ = value;
}
inline void ChunkIdTypeCJPB::set_belongedfileid(uint64_t value) {
  _internal_set_belongedfileid(value);
  // @@protoc_insertion_point(field_set:test.ChunkIdTypeCJPB.BelongedFileId)
}

// optional uint32 ChunkIndex = 2;
inline bool ChunkIdTypeCJPB::_internal_has_chunkindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChunkIdTypeCJPB::has_chunkindex() const {
  return _internal_has_chunkindex();
}
inline void ChunkIdTypeCJPB::clear_chunkindex() {
  _impl_.chunkindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ChunkIdTypeCJPB::_internal_chunkindex() const {
  return _impl_.chunkindex_;
}
inline uint32_t ChunkIdTypeCJPB::chunkindex() const {
  // @@protoc_insertion_point(field_get:test.ChunkIdTypeCJPB.ChunkIndex)
  return _internal_chunkindex();
}
inline void ChunkIdTypeCJPB::_internal_set_chunkindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chunkindex_ = value;
}
inline void ChunkIdTypeCJPB::set_chunkindex(uint32_t value) {
  _internal_set_chunkindex(value);
  // @@protoc_insertion_point(field_set:test.ChunkIdTypeCJPB.ChunkIndex)
}

// optional uint32 Padding = 3 [default = 0];
inline bool ChunkIdTypeCJPB::_internal_has_padding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChunkIdTypeCJPB::has_padding() const {
  return _internal_has_padding();
}
inline void ChunkIdTypeCJPB::clear_padding() {
  _impl_.padding_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ChunkIdTypeCJPB::_internal_padding() const {
  return _impl_.padding_;
}
inline uint32_t ChunkIdTypeCJPB::padding() const {
  // @@protoc_insertion_point(field_get:test.ChunkIdTypeCJPB.Padding)
  return _internal_padding();
}
inline void ChunkIdTypeCJPB::_internal_set_padding(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.padding_ = value;
}
inline void ChunkIdTypeCJPB::set_padding(uint32_t value) {
  _internal_set_padding(value);
  // @@protoc_insertion_point(field_set:test.ChunkIdTypeCJPB.Padding)
}

// -------------------------------------------------------------------

// PanguTraceSpanInfo

// optional uint64 TraceIdLow = 1;
inline bool PanguTraceSpanInfo::_internal_has_traceidlow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PanguTraceSpanInfo::has_traceidlow() const {
  return _internal_has_traceidlow();
}
inline void PanguTraceSpanInfo::clear_traceidlow() {
  _impl_.traceidlow_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PanguTraceSpanInfo::_internal_traceidlow() const {
  return _impl_.traceidlow_;
}
inline uint64_t PanguTraceSpanInfo::traceidlow() const {
  // @@protoc_insertion_point(field_get:test.PanguTraceSpanInfo.TraceIdLow)
  return _internal_traceidlow();
}
inline void PanguTraceSpanInfo::_internal_set_traceidlow(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.traceidlow_ = value;
}
inline void PanguTraceSpanInfo::set_traceidlow(uint64_t value) {
  _internal_set_traceidlow(value);
  // @@protoc_insertion_point(field_set:test.PanguTraceSpanInfo.TraceIdLow)
}

// optional uint64 TraceIdHigh = 2;
inline bool PanguTraceSpanInfo::_internal_has_traceidhigh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PanguTraceSpanInfo::has_traceidhigh() const {
  return _internal_has_traceidhigh();
}
inline void PanguTraceSpanInfo::clear_traceidhigh() {
  _impl_.traceidhigh_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PanguTraceSpanInfo::_internal_traceidhigh() const {
  return _impl_.traceidhigh_;
}
inline uint64_t PanguTraceSpanInfo::traceidhigh() const {
  // @@protoc_insertion_point(field_get:test.PanguTraceSpanInfo.TraceIdHigh)
  return _internal_traceidhigh();
}
inline void PanguTraceSpanInfo::_internal_set_traceidhigh(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.traceidhigh_ = value;
}
inline void PanguTraceSpanInfo::set_traceidhigh(uint64_t value) {
  _internal_set_traceidhigh(value);
  // @@protoc_insertion_point(field_set:test.PanguTraceSpanInfo.TraceIdHigh)
}

// optional uint64 SpanId = 3;
inline bool PanguTraceSpanInfo::_internal_has_spanid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PanguTraceSpanInfo::has_spanid() const {
  return _internal_has_spanid();
}
inline void PanguTraceSpanInfo::clear_spanid() {
  _impl_.spanid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PanguTraceSpanInfo::_internal_spanid() const {
  return _impl_.spanid_;
}
inline uint64_t PanguTraceSpanInfo::spanid() const {
  // @@protoc_insertion_point(field_get:test.PanguTraceSpanInfo.SpanId)
  return _internal_spanid();
}
inline void PanguTraceSpanInfo::_internal_set_spanid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.spanid_ = value;
}
inline void PanguTraceSpanInfo::set_spanid(uint64_t value) {
  _internal_set_spanid(value);
  // @@protoc_insertion_point(field_set:test.PanguTraceSpanInfo.SpanId)
}

// -------------------------------------------------------------------

// CsChooseDiskStrategySingleCJPB

// optional uint32 Method = 1;
inline bool CsChooseDiskStrategySingleCJPB::_internal_has_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CsChooseDiskStrategySingleCJPB::has_method() const {
  return _internal_has_method();
}
inline void CsChooseDiskStrategySingleCJPB::clear_method() {
  _impl_.method_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CsChooseDiskStrategySingleCJPB::_internal_method() const {
  return _impl_.method_;
}
inline uint32_t CsChooseDiskStrategySingleCJPB::method() const {
  // @@protoc_insertion_point(field_get:test.CsChooseDiskStrategySingleCJPB.Method)
  return _internal_method();
}
inline void CsChooseDiskStrategySingleCJPB::_internal_set_method(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.method_ = value;
}
inline void CsChooseDiskStrategySingleCJPB::set_method(uint32_t value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:test.CsChooseDiskStrategySingleCJPB.Method)
}

// optional uint32 Weight = 2;
inline bool CsChooseDiskStrategySingleCJPB::_internal_has_weight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CsChooseDiskStrategySingleCJPB::has_weight() const {
  return _internal_has_weight();
}
inline void CsChooseDiskStrategySingleCJPB::clear_weight() {
  _impl_.weight_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CsChooseDiskStrategySingleCJPB::_internal_weight() const {
  return _impl_.weight_;
}
inline uint32_t CsChooseDiskStrategySingleCJPB::weight() const {
  // @@protoc_insertion_point(field_get:test.CsChooseDiskStrategySingleCJPB.Weight)
  return _internal_weight();
}
inline void CsChooseDiskStrategySingleCJPB::_internal_set_weight(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.weight_ = value;
}
inline void CsChooseDiskStrategySingleCJPB::set_weight(uint32_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:test.CsChooseDiskStrategySingleCJPB.Weight)
}

// optional uint64 Parameter = 3 [default = 0];
inline bool CsChooseDiskStrategySingleCJPB::_internal_has_parameter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CsChooseDiskStrategySingleCJPB::has_parameter() const {
  return _internal_has_parameter();
}
inline void CsChooseDiskStrategySingleCJPB::clear_parameter() {
  _impl_.parameter_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CsChooseDiskStrategySingleCJPB::_internal_parameter() const {
  return _impl_.parameter_;
}
inline uint64_t CsChooseDiskStrategySingleCJPB::parameter() const {
  // @@protoc_insertion_point(field_get:test.CsChooseDiskStrategySingleCJPB.Parameter)
  return _internal_parameter();
}
inline void CsChooseDiskStrategySingleCJPB::_internal_set_parameter(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parameter_ = value;
}
inline void CsChooseDiskStrategySingleCJPB::set_parameter(uint64_t value) {
  _internal_set_parameter(value);
  // @@protoc_insertion_point(field_set:test.CsChooseDiskStrategySingleCJPB.Parameter)
}

// -------------------------------------------------------------------

// FlatLogFileFlushChunkRequestPB

// optional .test.ChunkIdTypeCJPB ChunkId = 1;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_chunkid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chunkid_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_chunkid() const {
  return _internal_has_chunkid();
}
inline void FlatLogFileFlushChunkRequestPB::clear_chunkid() {
  if (_impl_.chunkid_ != nullptr) _impl_.chunkid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::test::ChunkIdTypeCJPB& FlatLogFileFlushChunkRequestPB::_internal_chunkid() const {
  const ::test::ChunkIdTypeCJPB* p = _impl_.chunkid_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::ChunkIdTypeCJPB&>(
      ::test::_ChunkIdTypeCJPB_default_instance_);
}
inline const ::test::ChunkIdTypeCJPB& FlatLogFileFlushChunkRequestPB::chunkid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.ChunkId)
  return _internal_chunkid();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_chunkid(
    ::test::ChunkIdTypeCJPB* chunkid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunkid_);
  }
  _impl_.chunkid_ = chunkid;
  if (chunkid) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.ChunkId)
}
inline ::test::ChunkIdTypeCJPB* FlatLogFileFlushChunkRequestPB::release_chunkid() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::test::ChunkIdTypeCJPB* temp = _impl_.chunkid_;
  _impl_.chunkid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::ChunkIdTypeCJPB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_chunkid() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.ChunkId)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::test::ChunkIdTypeCJPB* temp = _impl_.chunkid_;
  _impl_.chunkid_ = nullptr;
  return temp;
}
inline ::test::ChunkIdTypeCJPB* FlatLogFileFlushChunkRequestPB::_internal_mutable_chunkid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.chunkid_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::ChunkIdTypeCJPB>(GetArenaForAllocation());
    _impl_.chunkid_ = p;
  }
  return _impl_.chunkid_;
}
inline ::test::ChunkIdTypeCJPB* FlatLogFileFlushChunkRequestPB::mutable_chunkid() {
  ::test::ChunkIdTypeCJPB* _msg = _internal_mutable_chunkid();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.ChunkId)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_chunkid(::test::ChunkIdTypeCJPB* chunkid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chunkid_;
  }
  if (chunkid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chunkid);
    if (message_arena != submessage_arena) {
      chunkid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunkid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.chunkid_ = chunkid;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.ChunkId)
}

// optional uint32 Offset = 2;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_offset() const {
  return _internal_has_offset();
}
inline void FlatLogFileFlushChunkRequestPB::clear_offset() {
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::offset() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.Offset)
  return _internal_offset();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_offset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.offset_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.Offset)
}

// optional uint32 Length = 3;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_length() const {
  return _internal_has_length();
}
inline void FlatLogFileFlushChunkRequestPB::clear_length() {
  _impl_.length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_length() const {
  return _impl_.length_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::length() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.Length)
  return _internal_length();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.length_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.Length)
}

// optional uint32 StorageId = 4;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_storageid() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_storageid() const {
  return _internal_has_storageid();
}
inline void FlatLogFileFlushChunkRequestPB::clear_storageid() {
  _impl_.storageid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_storageid() const {
  return _impl_.storageid_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::storageid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.StorageId)
  return _internal_storageid();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_storageid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.storageid_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_storageid(uint32_t value) {
  _internal_set_storageid(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.StorageId)
}

// optional bytes Data = 5;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_data() const {
  return _internal_has_data();
}
inline void FlatLogFileFlushChunkRequestPB::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlatLogFileFlushChunkRequestPB::data() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.Data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlatLogFileFlushChunkRequestPB::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.Data)
}
inline std::string* FlatLogFileFlushChunkRequestPB::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.Data)
  return _s;
}
inline const std::string& FlatLogFileFlushChunkRequestPB::_internal_data() const {
  return _impl_.data_.Get();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* FlatLogFileFlushChunkRequestPB::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* FlatLogFileFlushChunkRequestPB::release_data() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.Data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.Data)
}

// optional uint32 Hint = 6;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_hint() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_hint() const {
  return _internal_has_hint();
}
inline void FlatLogFileFlushChunkRequestPB::clear_hint() {
  _impl_.hint_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_hint() const {
  return _impl_.hint_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::hint() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.Hint)
  return _internal_hint();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_hint(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.hint_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_hint(uint32_t value) {
  _internal_set_hint(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.Hint)
}

// optional bool IsReplication = 7 [default = false];
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_isreplication() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_isreplication() const {
  return _internal_has_isreplication();
}
inline void FlatLogFileFlushChunkRequestPB::clear_isreplication() {
  _impl_.isreplication_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool FlatLogFileFlushChunkRequestPB::_internal_isreplication() const {
  return _impl_.isreplication_;
}
inline bool FlatLogFileFlushChunkRequestPB::isreplication() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.IsReplication)
  return _internal_isreplication();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_isreplication(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.isreplication_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_isreplication(bool value) {
  _internal_set_isreplication(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.IsReplication)
}

// optional bool trace_open = 8 [default = false];
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_trace_open() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_trace_open() const {
  return _internal_has_trace_open();
}
inline void FlatLogFileFlushChunkRequestPB::clear_trace_open() {
  _impl_.trace_open_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool FlatLogFileFlushChunkRequestPB::_internal_trace_open() const {
  return _impl_.trace_open_;
}
inline bool FlatLogFileFlushChunkRequestPB::trace_open() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.trace_open)
  return _internal_trace_open();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_trace_open(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.trace_open_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_trace_open(bool value) {
  _internal_set_trace_open(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.trace_open)
}

// optional .test.IONicePB IONice = 9;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_ionice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ionice_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_ionice() const {
  return _internal_has_ionice();
}
inline void FlatLogFileFlushChunkRequestPB::clear_ionice() {
  if (_impl_.ionice_ != nullptr) _impl_.ionice_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::test::IONicePB& FlatLogFileFlushChunkRequestPB::_internal_ionice() const {
  const ::test::IONicePB* p = _impl_.ionice_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::IONicePB&>(
      ::test::_IONicePB_default_instance_);
}
inline const ::test::IONicePB& FlatLogFileFlushChunkRequestPB::ionice() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.IONice)
  return _internal_ionice();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_ionice(
    ::test::IONicePB* ionice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ionice_);
  }
  _impl_.ionice_ = ionice;
  if (ionice) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.IONice)
}
inline ::test::IONicePB* FlatLogFileFlushChunkRequestPB::release_ionice() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::test::IONicePB* temp = _impl_.ionice_;
  _impl_.ionice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::IONicePB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_ionice() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.IONice)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::test::IONicePB* temp = _impl_.ionice_;
  _impl_.ionice_ = nullptr;
  return temp;
}
inline ::test::IONicePB* FlatLogFileFlushChunkRequestPB::_internal_mutable_ionice() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.ionice_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::IONicePB>(GetArenaForAllocation());
    _impl_.ionice_ = p;
  }
  return _impl_.ionice_;
}
inline ::test::IONicePB* FlatLogFileFlushChunkRequestPB::mutable_ionice() {
  ::test::IONicePB* _msg = _internal_mutable_ionice();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.IONice)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_ionice(::test::IONicePB* ionice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ionice_;
  }
  if (ionice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ionice);
    if (message_arena != submessage_arena) {
      ionice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ionice, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.ionice_ = ionice;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.IONice)
}

// optional .test.AccelerateOpenOptionsPB OpenChunkOptions = 10;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_openchunkoptions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.openchunkoptions_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_openchunkoptions() const {
  return _internal_has_openchunkoptions();
}
inline void FlatLogFileFlushChunkRequestPB::clear_openchunkoptions() {
  if (_impl_.openchunkoptions_ != nullptr) _impl_.openchunkoptions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::test::AccelerateOpenOptionsPB& FlatLogFileFlushChunkRequestPB::_internal_openchunkoptions() const {
  const ::test::AccelerateOpenOptionsPB* p = _impl_.openchunkoptions_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::AccelerateOpenOptionsPB&>(
      ::test::_AccelerateOpenOptionsPB_default_instance_);
}
inline const ::test::AccelerateOpenOptionsPB& FlatLogFileFlushChunkRequestPB::openchunkoptions() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.OpenChunkOptions)
  return _internal_openchunkoptions();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_openchunkoptions(
    ::test::AccelerateOpenOptionsPB* openchunkoptions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.openchunkoptions_);
  }
  _impl_.openchunkoptions_ = openchunkoptions;
  if (openchunkoptions) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.OpenChunkOptions)
}
inline ::test::AccelerateOpenOptionsPB* FlatLogFileFlushChunkRequestPB::release_openchunkoptions() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::test::AccelerateOpenOptionsPB* temp = _impl_.openchunkoptions_;
  _impl_.openchunkoptions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::AccelerateOpenOptionsPB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_openchunkoptions() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.OpenChunkOptions)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::test::AccelerateOpenOptionsPB* temp = _impl_.openchunkoptions_;
  _impl_.openchunkoptions_ = nullptr;
  return temp;
}
inline ::test::AccelerateOpenOptionsPB* FlatLogFileFlushChunkRequestPB::_internal_mutable_openchunkoptions() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.openchunkoptions_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::AccelerateOpenOptionsPB>(GetArenaForAllocation());
    _impl_.openchunkoptions_ = p;
  }
  return _impl_.openchunkoptions_;
}
inline ::test::AccelerateOpenOptionsPB* FlatLogFileFlushChunkRequestPB::mutable_openchunkoptions() {
  ::test::AccelerateOpenOptionsPB* _msg = _internal_mutable_openchunkoptions();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.OpenChunkOptions)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_openchunkoptions(::test::AccelerateOpenOptionsPB* openchunkoptions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.openchunkoptions_;
  }
  if (openchunkoptions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(openchunkoptions);
    if (message_arena != submessage_arena) {
      openchunkoptions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, openchunkoptions, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.openchunkoptions_ = openchunkoptions;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.OpenChunkOptions)
}

// optional int32 OpenMode = 11;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_openmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_openmode() const {
  return _internal_has_openmode();
}
inline void FlatLogFileFlushChunkRequestPB::clear_openmode() {
  _impl_.openmode_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline int32_t FlatLogFileFlushChunkRequestPB::_internal_openmode() const {
  return _impl_.openmode_;
}
inline int32_t FlatLogFileFlushChunkRequestPB::openmode() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.OpenMode)
  return _internal_openmode();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_openmode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.openmode_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_openmode(int32_t value) {
  _internal_set_openmode(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.OpenMode)
}

// optional int64 Handle = 12;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_handle() const {
  return _internal_has_handle();
}
inline void FlatLogFileFlushChunkRequestPB::clear_handle() {
  _impl_.handle_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int64_t FlatLogFileFlushChunkRequestPB::_internal_handle() const {
  return _impl_.handle_;
}
inline int64_t FlatLogFileFlushChunkRequestPB::handle() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.Handle)
  return _internal_handle();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_handle(int64_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.handle_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_handle(int64_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.Handle)
}

// optional bool DataSync = 13 [default = true];
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_datasync() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_datasync() const {
  return _internal_has_datasync();
}
inline void FlatLogFileFlushChunkRequestPB::clear_datasync() {
  _impl_.datasync_ = true;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline bool FlatLogFileFlushChunkRequestPB::_internal_datasync() const {
  return _impl_.datasync_;
}
inline bool FlatLogFileFlushChunkRequestPB::datasync() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.DataSync)
  return _internal_datasync();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_datasync(bool value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.datasync_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_datasync(bool value) {
  _internal_set_datasync(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.DataSync)
}

// optional .test.PanguTraceSpanInfo trace_span = 14;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_trace_span() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trace_span_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_trace_span() const {
  return _internal_has_trace_span();
}
inline void FlatLogFileFlushChunkRequestPB::clear_trace_span() {
  if (_impl_.trace_span_ != nullptr) _impl_.trace_span_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::test::PanguTraceSpanInfo& FlatLogFileFlushChunkRequestPB::_internal_trace_span() const {
  const ::test::PanguTraceSpanInfo* p = _impl_.trace_span_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::PanguTraceSpanInfo&>(
      ::test::_PanguTraceSpanInfo_default_instance_);
}
inline const ::test::PanguTraceSpanInfo& FlatLogFileFlushChunkRequestPB::trace_span() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.trace_span)
  return _internal_trace_span();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_trace_span(
    ::test::PanguTraceSpanInfo* trace_span) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_span_);
  }
  _impl_.trace_span_ = trace_span;
  if (trace_span) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.trace_span)
}
inline ::test::PanguTraceSpanInfo* FlatLogFileFlushChunkRequestPB::release_trace_span() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::test::PanguTraceSpanInfo* temp = _impl_.trace_span_;
  _impl_.trace_span_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::PanguTraceSpanInfo* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_trace_span() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.trace_span)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::test::PanguTraceSpanInfo* temp = _impl_.trace_span_;
  _impl_.trace_span_ = nullptr;
  return temp;
}
inline ::test::PanguTraceSpanInfo* FlatLogFileFlushChunkRequestPB::_internal_mutable_trace_span() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.trace_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::PanguTraceSpanInfo>(GetArenaForAllocation());
    _impl_.trace_span_ = p;
  }
  return _impl_.trace_span_;
}
inline ::test::PanguTraceSpanInfo* FlatLogFileFlushChunkRequestPB::mutable_trace_span() {
  ::test::PanguTraceSpanInfo* _msg = _internal_mutable_trace_span();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.trace_span)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_trace_span(::test::PanguTraceSpanInfo* trace_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_span_;
  }
  if (trace_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_span);
    if (message_arena != submessage_arena) {
      trace_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_span, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.trace_span_ = trace_span;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.trace_span)
}

// optional bool CreateIfNotExists = 15;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_createifnotexists() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_createifnotexists() const {
  return _internal_has_createifnotexists();
}
inline void FlatLogFileFlushChunkRequestPB::clear_createifnotexists() {
  _impl_.createifnotexists_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool FlatLogFileFlushChunkRequestPB::_internal_createifnotexists() const {
  return _impl_.createifnotexists_;
}
inline bool FlatLogFileFlushChunkRequestPB::createifnotexists() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.CreateIfNotExists)
  return _internal_createifnotexists();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_createifnotexists(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.createifnotexists_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_createifnotexists(bool value) {
  _internal_set_createifnotexists(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.CreateIfNotExists)
}

// optional .test.CsChooseDiskStrategyCJPB Strategy = 16;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_strategy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.strategy_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_strategy() const {
  return _internal_has_strategy();
}
inline void FlatLogFileFlushChunkRequestPB::clear_strategy() {
  if (_impl_.strategy_ != nullptr) _impl_.strategy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::test::CsChooseDiskStrategyCJPB& FlatLogFileFlushChunkRequestPB::_internal_strategy() const {
  const ::test::CsChooseDiskStrategyCJPB* p = _impl_.strategy_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::CsChooseDiskStrategyCJPB&>(
      ::test::_CsChooseDiskStrategyCJPB_default_instance_);
}
inline const ::test::CsChooseDiskStrategyCJPB& FlatLogFileFlushChunkRequestPB::strategy() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.Strategy)
  return _internal_strategy();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_strategy(
    ::test::CsChooseDiskStrategyCJPB* strategy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.strategy_);
  }
  _impl_.strategy_ = strategy;
  if (strategy) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.Strategy)
}
inline ::test::CsChooseDiskStrategyCJPB* FlatLogFileFlushChunkRequestPB::release_strategy() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::test::CsChooseDiskStrategyCJPB* temp = _impl_.strategy_;
  _impl_.strategy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::CsChooseDiskStrategyCJPB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_strategy() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.Strategy)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::test::CsChooseDiskStrategyCJPB* temp = _impl_.strategy_;
  _impl_.strategy_ = nullptr;
  return temp;
}
inline ::test::CsChooseDiskStrategyCJPB* FlatLogFileFlushChunkRequestPB::_internal_mutable_strategy() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::CsChooseDiskStrategyCJPB>(GetArenaForAllocation());
    _impl_.strategy_ = p;
  }
  return _impl_.strategy_;
}
inline ::test::CsChooseDiskStrategyCJPB* FlatLogFileFlushChunkRequestPB::mutable_strategy() {
  ::test::CsChooseDiskStrategyCJPB* _msg = _internal_mutable_strategy();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.Strategy)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_strategy(::test::CsChooseDiskStrategyCJPB* strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.strategy_;
  }
  if (strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(strategy);
    if (message_arena != submessage_arena) {
      strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.strategy_ = strategy;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.Strategy)
}

// optional .test.ChunkOrStreamIdInfoPB ChunkIdV2 = 17;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_chunkidv2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chunkidv2_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_chunkidv2() const {
  return _internal_has_chunkidv2();
}
inline void FlatLogFileFlushChunkRequestPB::clear_chunkidv2() {
  if (_impl_.chunkidv2_ != nullptr) _impl_.chunkidv2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::test::ChunkOrStreamIdInfoPB& FlatLogFileFlushChunkRequestPB::_internal_chunkidv2() const {
  const ::test::ChunkOrStreamIdInfoPB* p = _impl_.chunkidv2_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::ChunkOrStreamIdInfoPB&>(
      ::test::_ChunkOrStreamIdInfoPB_default_instance_);
}
inline const ::test::ChunkOrStreamIdInfoPB& FlatLogFileFlushChunkRequestPB::chunkidv2() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.ChunkIdV2)
  return _internal_chunkidv2();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_chunkidv2(
    ::test::ChunkOrStreamIdInfoPB* chunkidv2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunkidv2_);
  }
  _impl_.chunkidv2_ = chunkidv2;
  if (chunkidv2) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.ChunkIdV2)
}
inline ::test::ChunkOrStreamIdInfoPB* FlatLogFileFlushChunkRequestPB::release_chunkidv2() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::test::ChunkOrStreamIdInfoPB* temp = _impl_.chunkidv2_;
  _impl_.chunkidv2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::ChunkOrStreamIdInfoPB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_chunkidv2() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.ChunkIdV2)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::test::ChunkOrStreamIdInfoPB* temp = _impl_.chunkidv2_;
  _impl_.chunkidv2_ = nullptr;
  return temp;
}
inline ::test::ChunkOrStreamIdInfoPB* FlatLogFileFlushChunkRequestPB::_internal_mutable_chunkidv2() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.chunkidv2_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::ChunkOrStreamIdInfoPB>(GetArenaForAllocation());
    _impl_.chunkidv2_ = p;
  }
  return _impl_.chunkidv2_;
}
inline ::test::ChunkOrStreamIdInfoPB* FlatLogFileFlushChunkRequestPB::mutable_chunkidv2() {
  ::test::ChunkOrStreamIdInfoPB* _msg = _internal_mutable_chunkidv2();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.ChunkIdV2)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_chunkidv2(::test::ChunkOrStreamIdInfoPB* chunkidv2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chunkidv2_;
  }
  if (chunkidv2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chunkidv2);
    if (message_arena != submessage_arena) {
      chunkidv2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunkidv2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.chunkidv2_ = chunkidv2;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.ChunkIdV2)
}

// optional .test.QosOptionsPB qosOptions = 18;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_qosoptions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.qosoptions_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_qosoptions() const {
  return _internal_has_qosoptions();
}
inline void FlatLogFileFlushChunkRequestPB::clear_qosoptions() {
  if (_impl_.qosoptions_ != nullptr) _impl_.qosoptions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::test::QosOptionsPB& FlatLogFileFlushChunkRequestPB::_internal_qosoptions() const {
  const ::test::QosOptionsPB* p = _impl_.qosoptions_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::QosOptionsPB&>(
      ::test::_QosOptionsPB_default_instance_);
}
inline const ::test::QosOptionsPB& FlatLogFileFlushChunkRequestPB::qosoptions() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.qosOptions)
  return _internal_qosoptions();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_qosoptions(
    ::test::QosOptionsPB* qosoptions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.qosoptions_);
  }
  _impl_.qosoptions_ = qosoptions;
  if (qosoptions) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.qosOptions)
}
inline ::test::QosOptionsPB* FlatLogFileFlushChunkRequestPB::release_qosoptions() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::test::QosOptionsPB* temp = _impl_.qosoptions_;
  _impl_.qosoptions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::QosOptionsPB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_qosoptions() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.qosOptions)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::test::QosOptionsPB* temp = _impl_.qosoptions_;
  _impl_.qosoptions_ = nullptr;
  return temp;
}
inline ::test::QosOptionsPB* FlatLogFileFlushChunkRequestPB::_internal_mutable_qosoptions() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.qosoptions_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::QosOptionsPB>(GetArenaForAllocation());
    _impl_.qosoptions_ = p;
  }
  return _impl_.qosoptions_;
}
inline ::test::QosOptionsPB* FlatLogFileFlushChunkRequestPB::mutable_qosoptions() {
  ::test::QosOptionsPB* _msg = _internal_mutable_qosoptions();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.qosOptions)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_qosoptions(::test::QosOptionsPB* qosoptions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.qosoptions_;
  }
  if (qosoptions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qosoptions);
    if (message_arena != submessage_arena) {
      qosoptions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qosoptions, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.qosoptions_ = qosoptions;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.qosOptions)
}

// optional .test.FlushChecksumPB Checksum = 19;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_checksum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.checksum_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_checksum() const {
  return _internal_has_checksum();
}
inline void FlatLogFileFlushChunkRequestPB::clear_checksum() {
  if (_impl_.checksum_ != nullptr) _impl_.checksum_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::test::FlushChecksumPB& FlatLogFileFlushChunkRequestPB::_internal_checksum() const {
  const ::test::FlushChecksumPB* p = _impl_.checksum_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::FlushChecksumPB&>(
      ::test::_FlushChecksumPB_default_instance_);
}
inline const ::test::FlushChecksumPB& FlatLogFileFlushChunkRequestPB::checksum() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.Checksum)
  return _internal_checksum();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_checksum(
    ::test::FlushChecksumPB* checksum) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.checksum_);
  }
  _impl_.checksum_ = checksum;
  if (checksum) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.Checksum)
}
inline ::test::FlushChecksumPB* FlatLogFileFlushChunkRequestPB::release_checksum() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::test::FlushChecksumPB* temp = _impl_.checksum_;
  _impl_.checksum_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::FlushChecksumPB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_checksum() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.Checksum)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::test::FlushChecksumPB* temp = _impl_.checksum_;
  _impl_.checksum_ = nullptr;
  return temp;
}
inline ::test::FlushChecksumPB* FlatLogFileFlushChunkRequestPB::_internal_mutable_checksum() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.checksum_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::FlushChecksumPB>(GetArenaForAllocation());
    _impl_.checksum_ = p;
  }
  return _impl_.checksum_;
}
inline ::test::FlushChecksumPB* FlatLogFileFlushChunkRequestPB::mutable_checksum() {
  ::test::FlushChecksumPB* _msg = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.Checksum)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_checksum(::test::FlushChecksumPB* checksum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.checksum_;
  }
  if (checksum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(checksum);
    if (message_arena != submessage_arena) {
      checksum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checksum, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.checksum_ = checksum;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.Checksum)
}

// optional .test.UUIDInfoPB volumeUUID = 20;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_volumeuuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volumeuuid_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_volumeuuid() const {
  return _internal_has_volumeuuid();
}
inline void FlatLogFileFlushChunkRequestPB::clear_volumeuuid() {
  if (_impl_.volumeuuid_ != nullptr) _impl_.volumeuuid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::test::UUIDInfoPB& FlatLogFileFlushChunkRequestPB::_internal_volumeuuid() const {
  const ::test::UUIDInfoPB* p = _impl_.volumeuuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::UUIDInfoPB&>(
      ::test::_UUIDInfoPB_default_instance_);
}
inline const ::test::UUIDInfoPB& FlatLogFileFlushChunkRequestPB::volumeuuid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.volumeUUID)
  return _internal_volumeuuid();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_volumeuuid(
    ::test::UUIDInfoPB* volumeuuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.volumeuuid_);
  }
  _impl_.volumeuuid_ = volumeuuid;
  if (volumeuuid) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.volumeUUID)
}
inline ::test::UUIDInfoPB* FlatLogFileFlushChunkRequestPB::release_volumeuuid() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::test::UUIDInfoPB* temp = _impl_.volumeuuid_;
  _impl_.volumeuuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::UUIDInfoPB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_volumeuuid() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.volumeUUID)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::test::UUIDInfoPB* temp = _impl_.volumeuuid_;
  _impl_.volumeuuid_ = nullptr;
  return temp;
}
inline ::test::UUIDInfoPB* FlatLogFileFlushChunkRequestPB::_internal_mutable_volumeuuid() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.volumeuuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::UUIDInfoPB>(GetArenaForAllocation());
    _impl_.volumeuuid_ = p;
  }
  return _impl_.volumeuuid_;
}
inline ::test::UUIDInfoPB* FlatLogFileFlushChunkRequestPB::mutable_volumeuuid() {
  ::test::UUIDInfoPB* _msg = _internal_mutable_volumeuuid();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.volumeUUID)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_volumeuuid(::test::UUIDInfoPB* volumeuuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.volumeuuid_;
  }
  if (volumeuuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(volumeuuid);
    if (message_arena != submessage_arena) {
      volumeuuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volumeuuid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.volumeuuid_ = volumeuuid;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.volumeUUID)
}

// optional uint32 ModuleVersion = 21;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_moduleversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_moduleversion() const {
  return _internal_has_moduleversion();
}
inline void FlatLogFileFlushChunkRequestPB::clear_moduleversion() {
  _impl_.moduleversion_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_moduleversion() const {
  return _impl_.moduleversion_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::moduleversion() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.ModuleVersion)
  return _internal_moduleversion();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_moduleversion(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.moduleversion_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_moduleversion(uint32_t value) {
  _internal_set_moduleversion(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.ModuleVersion)
}

// optional bytes HostName = 22;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_hostname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_hostname() const {
  return _internal_has_hostname();
}
inline void FlatLogFileFlushChunkRequestPB::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FlatLogFileFlushChunkRequestPB::hostname() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.HostName)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlatLogFileFlushChunkRequestPB::set_hostname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.hostname_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.HostName)
}
inline std::string* FlatLogFileFlushChunkRequestPB::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.HostName)
  return _s;
}
inline const std::string& FlatLogFileFlushChunkRequestPB::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_hostname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* FlatLogFileFlushChunkRequestPB::_internal_mutable_hostname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* FlatLogFileFlushChunkRequestPB::release_hostname() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.HostName)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.hostname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.HostName)
}

// optional uint32 DiskId = 23;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_diskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_diskid() const {
  return _internal_has_diskid();
}
inline void FlatLogFileFlushChunkRequestPB::clear_diskid() {
  _impl_.diskid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_diskid() const {
  return _impl_.diskid_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::diskid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.DiskId)
  return _internal_diskid();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_diskid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.diskid_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_diskid(uint32_t value) {
  _internal_set_diskid(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.DiskId)
}

// optional uint64 RequestId = 24;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_requestid() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_requestid() const {
  return _internal_has_requestid();
}
inline void FlatLogFileFlushChunkRequestPB::clear_requestid() {
  _impl_.requestid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline uint64_t FlatLogFileFlushChunkRequestPB::_internal_requestid() const {
  return _impl_.requestid_;
}
inline uint64_t FlatLogFileFlushChunkRequestPB::requestid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.RequestId)
  return _internal_requestid();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_requestid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.requestid_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_requestid(uint64_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.RequestId)
}

// optional bytes UserId = 25;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_userid() const {
  return _internal_has_userid();
}
inline void FlatLogFileFlushChunkRequestPB::clear_userid() {
  _impl_.userid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FlatLogFileFlushChunkRequestPB::userid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.UserId)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlatLogFileFlushChunkRequestPB::set_userid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.userid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.UserId)
}
inline std::string* FlatLogFileFlushChunkRequestPB::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.UserId)
  return _s;
}
inline const std::string& FlatLogFileFlushChunkRequestPB::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_userid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* FlatLogFileFlushChunkRequestPB::_internal_mutable_userid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* FlatLogFileFlushChunkRequestPB::release_userid() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.UserId)
  if (!_internal_has_userid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.userid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.UserId)
}

// optional .test.RootServerIdPB root_server_id = 26;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_root_server_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.root_server_id_ != nullptr);
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_root_server_id() const {
  return _internal_has_root_server_id();
}
inline void FlatLogFileFlushChunkRequestPB::clear_root_server_id() {
  if (_impl_.root_server_id_ != nullptr) _impl_.root_server_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::test::RootServerIdPB& FlatLogFileFlushChunkRequestPB::_internal_root_server_id() const {
  const ::test::RootServerIdPB* p = _impl_.root_server_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::test::RootServerIdPB&>(
      ::test::_RootServerIdPB_default_instance_);
}
inline const ::test::RootServerIdPB& FlatLogFileFlushChunkRequestPB::root_server_id() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.root_server_id)
  return _internal_root_server_id();
}
inline void FlatLogFileFlushChunkRequestPB::unsafe_arena_set_allocated_root_server_id(
    ::test::RootServerIdPB* root_server_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_server_id_);
  }
  _impl_.root_server_id_ = root_server_id;
  if (root_server_id) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:test.FlatLogFileFlushChunkRequestPB.root_server_id)
}
inline ::test::RootServerIdPB* FlatLogFileFlushChunkRequestPB::release_root_server_id() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::test::RootServerIdPB* temp = _impl_.root_server_id_;
  _impl_.root_server_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::test::RootServerIdPB* FlatLogFileFlushChunkRequestPB::unsafe_arena_release_root_server_id() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkRequestPB.root_server_id)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::test::RootServerIdPB* temp = _impl_.root_server_id_;
  _impl_.root_server_id_ = nullptr;
  return temp;
}
inline ::test::RootServerIdPB* FlatLogFileFlushChunkRequestPB::_internal_mutable_root_server_id() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.root_server_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::test::RootServerIdPB>(GetArenaForAllocation());
    _impl_.root_server_id_ = p;
  }
  return _impl_.root_server_id_;
}
inline ::test::RootServerIdPB* FlatLogFileFlushChunkRequestPB::mutable_root_server_id() {
  ::test::RootServerIdPB* _msg = _internal_mutable_root_server_id();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkRequestPB.root_server_id)
  return _msg;
}
inline void FlatLogFileFlushChunkRequestPB::set_allocated_root_server_id(::test::RootServerIdPB* root_server_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_server_id_;
  }
  if (root_server_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root_server_id);
    if (message_arena != submessage_arena) {
      root_server_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root_server_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.root_server_id_ = root_server_id;
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkRequestPB.root_server_id)
}

// optional uint32 RequiredMinCSVersion = 27;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_requiredmincsversion() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_requiredmincsversion() const {
  return _internal_has_requiredmincsversion();
}
inline void FlatLogFileFlushChunkRequestPB::clear_requiredmincsversion() {
  _impl_.requiredmincsversion_ = 0u;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_requiredmincsversion() const {
  return _impl_.requiredmincsversion_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::requiredmincsversion() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.RequiredMinCSVersion)
  return _internal_requiredmincsversion();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_requiredmincsversion(uint32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.requiredmincsversion_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_requiredmincsversion(uint32_t value) {
  _internal_set_requiredmincsversion(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.RequiredMinCSVersion)
}

// optional int32 FromType = 28;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_fromtype() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_fromtype() const {
  return _internal_has_fromtype();
}
inline void FlatLogFileFlushChunkRequestPB::clear_fromtype() {
  _impl_.fromtype_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline int32_t FlatLogFileFlushChunkRequestPB::_internal_fromtype() const {
  return _impl_.fromtype_;
}
inline int32_t FlatLogFileFlushChunkRequestPB::fromtype() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.FromType)
  return _internal_fromtype();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_fromtype(int32_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.fromtype_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_fromtype(int32_t value) {
  _internal_set_fromtype(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.FromType)
}

// optional uint64 Offset64 = 29;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_offset64() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_offset64() const {
  return _internal_has_offset64();
}
inline void FlatLogFileFlushChunkRequestPB::clear_offset64() {
  _impl_.offset64_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline uint64_t FlatLogFileFlushChunkRequestPB::_internal_offset64() const {
  return _impl_.offset64_;
}
inline uint64_t FlatLogFileFlushChunkRequestPB::offset64() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.Offset64)
  return _internal_offset64();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_offset64(uint64_t value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.offset64_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_offset64(uint64_t value) {
  _internal_set_offset64(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.Offset64)
}

// optional uint32 RecordSize = 30;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_recordsize() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_recordsize() const {
  return _internal_has_recordsize();
}
inline void FlatLogFileFlushChunkRequestPB::clear_recordsize() {
  _impl_.recordsize_ = 0u;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_recordsize() const {
  return _impl_.recordsize_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::recordsize() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.RecordSize)
  return _internal_recordsize();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_recordsize(uint32_t value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.recordsize_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_recordsize(uint32_t value) {
  _internal_set_recordsize(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.RecordSize)
}

// optional uint32 PoolId = 31;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_poolid() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_poolid() const {
  return _internal_has_poolid();
}
inline void FlatLogFileFlushChunkRequestPB::clear_poolid() {
  _impl_.poolid_ = 0u;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::_internal_poolid() const {
  return _impl_.poolid_;
}
inline uint32_t FlatLogFileFlushChunkRequestPB::poolid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.PoolId)
  return _internal_poolid();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_poolid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.poolid_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_poolid(uint32_t value) {
  _internal_set_poolid(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.PoolId)
}

// optional uint64 StoragePoolConfVersion = 32;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_storagepoolconfversion() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_storagepoolconfversion() const {
  return _internal_has_storagepoolconfversion();
}
inline void FlatLogFileFlushChunkRequestPB::clear_storagepoolconfversion() {
  _impl_.storagepoolconfversion_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline uint64_t FlatLogFileFlushChunkRequestPB::_internal_storagepoolconfversion() const {
  return _impl_.storagepoolconfversion_;
}
inline uint64_t FlatLogFileFlushChunkRequestPB::storagepoolconfversion() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.StoragePoolConfVersion)
  return _internal_storagepoolconfversion();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_storagepoolconfversion(uint64_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.storagepoolconfversion_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_storagepoolconfversion(uint64_t value) {
  _internal_set_storagepoolconfversion(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.StoragePoolConfVersion)
}

// optional int32 a = 33;
inline bool FlatLogFileFlushChunkRequestPB::_internal_has_a() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkRequestPB::has_a() const {
  return _internal_has_a();
}
inline void FlatLogFileFlushChunkRequestPB::clear_a() {
  _impl_.a_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline int32_t FlatLogFileFlushChunkRequestPB::_internal_a() const {
  return _impl_.a_;
}
inline int32_t FlatLogFileFlushChunkRequestPB::a() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkRequestPB.a)
  return _internal_a();
}
inline void FlatLogFileFlushChunkRequestPB::_internal_set_a(int32_t value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.a_ = value;
}
inline void FlatLogFileFlushChunkRequestPB::set_a(int32_t value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkRequestPB.a)
}

// -------------------------------------------------------------------

// FlatLogFileFlushChunkResponsePB

// optional int32 Errorcode = 1;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_errorcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_errorcode() const {
  return _internal_has_errorcode();
}
inline void FlatLogFileFlushChunkResponsePB::clear_errorcode() {
  _impl_.errorcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t FlatLogFileFlushChunkResponsePB::_internal_errorcode() const {
  return _impl_.errorcode_;
}
inline int32_t FlatLogFileFlushChunkResponsePB::errorcode() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.Errorcode)
  return _internal_errorcode();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_errorcode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.errorcode_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_errorcode(int32_t value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.Errorcode)
}

// optional uint32 ChunkStatus = 2 [default = 0];
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_chunkstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_chunkstatus() const {
  return _internal_has_chunkstatus();
}
inline void FlatLogFileFlushChunkResponsePB::clear_chunkstatus() {
  _impl_.chunkstatus_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::_internal_chunkstatus() const {
  return _impl_.chunkstatus_;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::chunkstatus() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.ChunkStatus)
  return _internal_chunkstatus();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_chunkstatus(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.chunkstatus_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_chunkstatus(uint32_t value) {
  _internal_set_chunkstatus(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.ChunkStatus)
}

// optional uint32 Hint = 3;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_hint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_hint() const {
  return _internal_has_hint();
}
inline void FlatLogFileFlushChunkResponsePB::clear_hint() {
  _impl_.hint_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::_internal_hint() const {
  return _impl_.hint_;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::hint() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.Hint)
  return _internal_hint();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_hint(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hint_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_hint(uint32_t value) {
  _internal_set_hint(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.Hint)
}

// optional uint32 AckLength = 4;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_acklength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_acklength() const {
  return _internal_has_acklength();
}
inline void FlatLogFileFlushChunkResponsePB::clear_acklength() {
  _impl_.acklength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::_internal_acklength() const {
  return _impl_.acklength_;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::acklength() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.AckLength)
  return _internal_acklength();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_acklength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.acklength_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_acklength(uint32_t value) {
  _internal_set_acklength(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.AckLength)
}

// optional uint32 trace_type = 5;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_trace_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_trace_type() const {
  return _internal_has_trace_type();
}
inline void FlatLogFileFlushChunkResponsePB::clear_trace_type() {
  _impl_.trace_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::_internal_trace_type() const {
  return _impl_.trace_type_;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::trace_type() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.trace_type)
  return _internal_trace_type();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_trace_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.trace_type_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_trace_type(uint32_t value) {
  _internal_set_trace_type(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.trace_type)
}

// optional bytes trace_data = 6;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_trace_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_trace_data() const {
  return _internal_has_trace_data();
}
inline void FlatLogFileFlushChunkResponsePB::clear_trace_data() {
  _impl_.trace_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlatLogFileFlushChunkResponsePB::trace_data() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.trace_data)
  return _internal_trace_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlatLogFileFlushChunkResponsePB::set_trace_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.trace_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.trace_data)
}
inline std::string* FlatLogFileFlushChunkResponsePB::mutable_trace_data() {
  std::string* _s = _internal_mutable_trace_data();
  // @@protoc_insertion_point(field_mutable:test.FlatLogFileFlushChunkResponsePB.trace_data)
  return _s;
}
inline const std::string& FlatLogFileFlushChunkResponsePB::_internal_trace_data() const {
  return _impl_.trace_data_.Get();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_trace_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trace_data_.Set(value, GetArenaForAllocation());
}
inline std::string* FlatLogFileFlushChunkResponsePB::_internal_mutable_trace_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.trace_data_.Mutable(GetArenaForAllocation());
}
inline std::string* FlatLogFileFlushChunkResponsePB::release_trace_data() {
  // @@protoc_insertion_point(field_release:test.FlatLogFileFlushChunkResponsePB.trace_data)
  if (!_internal_has_trace_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.trace_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_data_.IsDefault()) {
    _impl_.trace_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FlatLogFileFlushChunkResponsePB::set_allocated_trace_data(std::string* trace_data) {
  if (trace_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trace_data_.SetAllocated(trace_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_data_.IsDefault()) {
    _impl_.trace_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:test.FlatLogFileFlushChunkResponsePB.trace_data)
}

// optional int64 Handle = 7;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_handle() const {
  return _internal_has_handle();
}
inline void FlatLogFileFlushChunkResponsePB::clear_handle() {
  _impl_.handle_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t FlatLogFileFlushChunkResponsePB::_internal_handle() const {
  return _impl_.handle_;
}
inline int64_t FlatLogFileFlushChunkResponsePB::handle() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.Handle)
  return _internal_handle();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_handle(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.handle_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_handle(int64_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.Handle)
}

// optional uint32 StorageId = 8;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_storageid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_storageid() const {
  return _internal_has_storageid();
}
inline void FlatLogFileFlushChunkResponsePB::clear_storageid() {
  _impl_.storageid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::_internal_storageid() const {
  return _impl_.storageid_;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::storageid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.StorageId)
  return _internal_storageid();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_storageid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.storageid_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_storageid(uint32_t value) {
  _internal_set_storageid(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.StorageId)
}

// optional uint32 DiskId = 9;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_diskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_diskid() const {
  return _internal_has_diskid();
}
inline void FlatLogFileFlushChunkResponsePB::clear_diskid() {
  _impl_.diskid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::_internal_diskid() const {
  return _impl_.diskid_;
}
inline uint32_t FlatLogFileFlushChunkResponsePB::diskid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.DiskId)
  return _internal_diskid();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_diskid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.diskid_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_diskid(uint32_t value) {
  _internal_set_diskid(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.DiskId)
}

// optional uint64 RequestId = 10;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_requestid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_requestid() const {
  return _internal_has_requestid();
}
inline void FlatLogFileFlushChunkResponsePB::clear_requestid() {
  _impl_.requestid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint64_t FlatLogFileFlushChunkResponsePB::_internal_requestid() const {
  return _impl_.requestid_;
}
inline uint64_t FlatLogFileFlushChunkResponsePB::requestid() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.RequestId)
  return _internal_requestid();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_requestid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.requestid_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_requestid(uint64_t value) {
  _internal_set_requestid(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.RequestId)
}

// optional int64 Checksum = 11;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_checksum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_checksum() const {
  return _internal_has_checksum();
}
inline void FlatLogFileFlushChunkResponsePB::clear_checksum() {
  _impl_.checksum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t FlatLogFileFlushChunkResponsePB::_internal_checksum() const {
  return _impl_.checksum_;
}
inline int64_t FlatLogFileFlushChunkResponsePB::checksum() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.Checksum)
  return _internal_checksum();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_checksum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.checksum_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_checksum(int64_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.Checksum)
}

// optional uint64 LeftReplicaSize = 12;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_leftreplicasize() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_leftreplicasize() const {
  return _internal_has_leftreplicasize();
}
inline void FlatLogFileFlushChunkResponsePB::clear_leftreplicasize() {
  _impl_.leftreplicasize_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint64_t FlatLogFileFlushChunkResponsePB::_internal_leftreplicasize() const {
  return _impl_.leftreplicasize_;
}
inline uint64_t FlatLogFileFlushChunkResponsePB::leftreplicasize() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.LeftReplicaSize)
  return _internal_leftreplicasize();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_leftreplicasize(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.leftreplicasize_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_leftreplicasize(uint64_t value) {
  _internal_set_leftreplicasize(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.LeftReplicaSize)
}

// optional int32 a = 13;
inline bool FlatLogFileFlushChunkResponsePB::_internal_has_a() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool FlatLogFileFlushChunkResponsePB::has_a() const {
  return _internal_has_a();
}
inline void FlatLogFileFlushChunkResponsePB::clear_a() {
  _impl_.a_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t FlatLogFileFlushChunkResponsePB::_internal_a() const {
  return _impl_.a_;
}
inline int32_t FlatLogFileFlushChunkResponsePB::a() const {
  // @@protoc_insertion_point(field_get:test.FlatLogFileFlushChunkResponsePB.a)
  return _internal_a();
}
inline void FlatLogFileFlushChunkResponsePB::_internal_set_a(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.a_ = value;
}
inline void FlatLogFileFlushChunkResponsePB::set_a(int32_t value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:test.FlatLogFileFlushChunkResponsePB.a)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace test

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::test::QosOptionsPB_AdjustType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::test::QosOptionsPB_AdjustType>() {
  return ::test::QosOptionsPB_AdjustType_descriptor();
}
template <> struct is_proto_enum< ::test::QosOptionsPB_CacheGroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::test::QosOptionsPB_CacheGroupType>() {
  return ::test::QosOptionsPB_CacheGroupType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flat_2eproto
