// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLAT_H_
#define FLATBUFFERS_GENERATED_FLAT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct FixedUUIDInfoFB;
struct FixedUUIDInfoFBBuilder;
struct FixedUUIDInfoFBT;

struct MirrorArgsFB;
struct MirrorArgsFBBuilder;
struct MirrorArgsFBT;

struct ChunkOptionsFB;
struct ChunkOptionsFBBuilder;
struct ChunkOptionsFBT;

struct ReplicaLocationFB;
struct ReplicaLocationFBBuilder;
struct ReplicaLocationFBT;

struct AccelerateOpenOptionsFB;
struct AccelerateOpenOptionsFBBuilder;
struct AccelerateOpenOptionsFBT;

struct IONiceFB;
struct IONiceFBBuilder;
struct IONiceFBT;

struct CsChooseDiskStrategyCJFB;
struct CsChooseDiskStrategyCJFBBuilder;
struct CsChooseDiskStrategyCJFBT;

struct ChunkOrStreamIdInfoFB;
struct ChunkOrStreamIdInfoFBBuilder;
struct ChunkOrStreamIdInfoFBT;

struct QosOptionsFB;
struct QosOptionsFBBuilder;
struct QosOptionsFBT;

struct FlushChecksumFB;
struct FlushChecksumFBBuilder;
struct FlushChecksumFBT;

struct UUIDInfoFB;
struct UUIDInfoFBBuilder;
struct UUIDInfoFBT;

struct RootServerIdFB;
struct RootServerIdFBBuilder;
struct RootServerIdFBT;

struct ChunkIdTypeCJFB;
struct ChunkIdTypeCJFBBuilder;
struct ChunkIdTypeCJFBT;

struct PanguTraceSpanInfoFB;
struct PanguTraceSpanInfoFBBuilder;
struct PanguTraceSpanInfoFBT;

struct CsChooseDiskStrategySingleCJFB;
struct CsChooseDiskStrategySingleCJFBBuilder;
struct CsChooseDiskStrategySingleCJFBT;

struct FlatLogFileFlushChunkRequestFB;
struct FlatLogFileFlushChunkRequestFBBuilder;
struct FlatLogFileFlushChunkRequestFBT;

struct FlatLogFileFlushChunkResponseFB;
struct FlatLogFileFlushChunkResponseFBBuilder;
struct FlatLogFileFlushChunkResponseFBT;

bool operator==(const FixedUUIDInfoFBT &lhs, const FixedUUIDInfoFBT &rhs);
bool operator!=(const FixedUUIDInfoFBT &lhs, const FixedUUIDInfoFBT &rhs);
bool operator==(const MirrorArgsFBT &lhs, const MirrorArgsFBT &rhs);
bool operator!=(const MirrorArgsFBT &lhs, const MirrorArgsFBT &rhs);
bool operator==(const ChunkOptionsFBT &lhs, const ChunkOptionsFBT &rhs);
bool operator!=(const ChunkOptionsFBT &lhs, const ChunkOptionsFBT &rhs);
bool operator==(const ReplicaLocationFBT &lhs, const ReplicaLocationFBT &rhs);
bool operator!=(const ReplicaLocationFBT &lhs, const ReplicaLocationFBT &rhs);
bool operator==(const AccelerateOpenOptionsFBT &lhs, const AccelerateOpenOptionsFBT &rhs);
bool operator!=(const AccelerateOpenOptionsFBT &lhs, const AccelerateOpenOptionsFBT &rhs);
bool operator==(const IONiceFBT &lhs, const IONiceFBT &rhs);
bool operator!=(const IONiceFBT &lhs, const IONiceFBT &rhs);
bool operator==(const CsChooseDiskStrategyCJFBT &lhs, const CsChooseDiskStrategyCJFBT &rhs);
bool operator!=(const CsChooseDiskStrategyCJFBT &lhs, const CsChooseDiskStrategyCJFBT &rhs);
bool operator==(const ChunkOrStreamIdInfoFBT &lhs, const ChunkOrStreamIdInfoFBT &rhs);
bool operator!=(const ChunkOrStreamIdInfoFBT &lhs, const ChunkOrStreamIdInfoFBT &rhs);
bool operator==(const QosOptionsFBT &lhs, const QosOptionsFBT &rhs);
bool operator!=(const QosOptionsFBT &lhs, const QosOptionsFBT &rhs);
bool operator==(const FlushChecksumFBT &lhs, const FlushChecksumFBT &rhs);
bool operator!=(const FlushChecksumFBT &lhs, const FlushChecksumFBT &rhs);
bool operator==(const UUIDInfoFBT &lhs, const UUIDInfoFBT &rhs);
bool operator!=(const UUIDInfoFBT &lhs, const UUIDInfoFBT &rhs);
bool operator==(const RootServerIdFBT &lhs, const RootServerIdFBT &rhs);
bool operator!=(const RootServerIdFBT &lhs, const RootServerIdFBT &rhs);
bool operator==(const ChunkIdTypeCJFBT &lhs, const ChunkIdTypeCJFBT &rhs);
bool operator!=(const ChunkIdTypeCJFBT &lhs, const ChunkIdTypeCJFBT &rhs);
bool operator==(const PanguTraceSpanInfoFBT &lhs, const PanguTraceSpanInfoFBT &rhs);
bool operator!=(const PanguTraceSpanInfoFBT &lhs, const PanguTraceSpanInfoFBT &rhs);
bool operator==(const CsChooseDiskStrategySingleCJFBT &lhs, const CsChooseDiskStrategySingleCJFBT &rhs);
bool operator!=(const CsChooseDiskStrategySingleCJFBT &lhs, const CsChooseDiskStrategySingleCJFBT &rhs);
bool operator==(const FlatLogFileFlushChunkRequestFBT &lhs, const FlatLogFileFlushChunkRequestFBT &rhs);
bool operator!=(const FlatLogFileFlushChunkRequestFBT &lhs, const FlatLogFileFlushChunkRequestFBT &rhs);
bool operator==(const FlatLogFileFlushChunkResponseFBT &lhs, const FlatLogFileFlushChunkResponseFBT &rhs);
bool operator!=(const FlatLogFileFlushChunkResponseFBT &lhs, const FlatLogFileFlushChunkResponseFBT &rhs);

inline const ::flatbuffers::TypeTable *FixedUUIDInfoFBTypeTable();

inline const ::flatbuffers::TypeTable *MirrorArgsFBTypeTable();

inline const ::flatbuffers::TypeTable *ChunkOptionsFBTypeTable();

inline const ::flatbuffers::TypeTable *ReplicaLocationFBTypeTable();

inline const ::flatbuffers::TypeTable *AccelerateOpenOptionsFBTypeTable();

inline const ::flatbuffers::TypeTable *IONiceFBTypeTable();

inline const ::flatbuffers::TypeTable *CsChooseDiskStrategyCJFBTypeTable();

inline const ::flatbuffers::TypeTable *ChunkOrStreamIdInfoFBTypeTable();

inline const ::flatbuffers::TypeTable *QosOptionsFBTypeTable();

inline const ::flatbuffers::TypeTable *FlushChecksumFBTypeTable();

inline const ::flatbuffers::TypeTable *UUIDInfoFBTypeTable();

inline const ::flatbuffers::TypeTable *RootServerIdFBTypeTable();

inline const ::flatbuffers::TypeTable *ChunkIdTypeCJFBTypeTable();

inline const ::flatbuffers::TypeTable *PanguTraceSpanInfoFBTypeTable();

inline const ::flatbuffers::TypeTable *CsChooseDiskStrategySingleCJFBTypeTable();

inline const ::flatbuffers::TypeTable *FlatLogFileFlushChunkRequestFBTypeTable();

inline const ::flatbuffers::TypeTable *FlatLogFileFlushChunkResponseFBTypeTable();

enum AdjustType : int16_t {
  AdjustType_LOWER = -1,
  AdjustType_KEEP = 0,
  AdjustType_HIGHER = 1,
  AdjustType_MIN = AdjustType_LOWER,
  AdjustType_MAX = AdjustType_HIGHER
};

inline const AdjustType (&EnumValuesAdjustType())[3] {
  static const AdjustType values[] = {
    AdjustType_LOWER,
    AdjustType_KEEP,
    AdjustType_HIGHER
  };
  return values;
}

inline const char * const *EnumNamesAdjustType() {
  static const char * const names[4] = {
    "LOWER",
    "KEEP",
    "HIGHER",
    nullptr
  };
  return names;
}

inline const char *EnumNameAdjustType(AdjustType e) {
  if (::flatbuffers::IsOutRange(e, AdjustType_LOWER, AdjustType_HIGHER)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AdjustType_LOWER);
  return EnumNamesAdjustType()[index];
}

enum CacheGroupType : uint32_t {
  CacheGroupType_DEFAULT = 0,
  CacheGroupType_INTERNAL = 1,
  CacheGroupType_USER_BASE = 100,
  CacheGroupType_USER_0 = 101,
  CacheGroupType_USER_1 = 102,
  CacheGroupType_NO_CACHE = 4294967295,
  CacheGroupType_MIN = CacheGroupType_DEFAULT,
  CacheGroupType_MAX = CacheGroupType_NO_CACHE
};

inline const CacheGroupType (&EnumValuesCacheGroupType())[6] {
  static const CacheGroupType values[] = {
    CacheGroupType_DEFAULT,
    CacheGroupType_INTERNAL,
    CacheGroupType_USER_BASE,
    CacheGroupType_USER_0,
    CacheGroupType_USER_1,
    CacheGroupType_NO_CACHE
  };
  return values;
}

inline const char *EnumNameCacheGroupType(CacheGroupType e) {
  switch (e) {
    case CacheGroupType_DEFAULT: return "DEFAULT";
    case CacheGroupType_INTERNAL: return "INTERNAL";
    case CacheGroupType_USER_BASE: return "USER_BASE";
    case CacheGroupType_USER_0: return "USER_0";
    case CacheGroupType_USER_1: return "USER_1";
    case CacheGroupType_NO_CACHE: return "NO_CACHE";
    default: return "";
  }
}

struct FixedUUIDInfoFBT : public ::flatbuffers::NativeTable {
  typedef FixedUUIDInfoFB TableType;
  uint64_t low = 0;
  uint64_t high = 0;
};

struct FixedUUIDInfoFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FixedUUIDInfoFBT NativeTableType;
  typedef FixedUUIDInfoFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FixedUUIDInfoFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW = 4,
    VT_HIGH = 6
  };
  uint64_t low() const {
    return GetField<uint64_t>(VT_LOW, 0);
  }
  uint64_t high() const {
    return GetField<uint64_t>(VT_HIGH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOW, 8) &&
           VerifyField<uint64_t>(verifier, VT_HIGH, 8) &&
           verifier.EndTable();
  }
  FixedUUIDInfoFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FixedUUIDInfoFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FixedUUIDInfoFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FixedUUIDInfoFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FixedUUIDInfoFBBuilder {
  typedef FixedUUIDInfoFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_low(uint64_t low) {
    fbb_.AddElement<uint64_t>(FixedUUIDInfoFB::VT_LOW, low, 0);
  }
  void add_high(uint64_t high) {
    fbb_.AddElement<uint64_t>(FixedUUIDInfoFB::VT_HIGH, high, 0);
  }
  explicit FixedUUIDInfoFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FixedUUIDInfoFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FixedUUIDInfoFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FixedUUIDInfoFB> CreateFixedUUIDInfoFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t low = 0,
    uint64_t high = 0) {
  FixedUUIDInfoFBBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  return builder_.Finish();
}

::flatbuffers::Offset<FixedUUIDInfoFB> CreateFixedUUIDInfoFB(::flatbuffers::FlatBufferBuilder &_fbb, const FixedUUIDInfoFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MirrorArgsFBT : public ::flatbuffers::NativeTable {
  typedef MirrorArgsFB TableType;
  int32_t copy = 0;
  int32_t ftt = 0;
};

struct MirrorArgsFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MirrorArgsFBT NativeTableType;
  typedef MirrorArgsFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MirrorArgsFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COPY = 4,
    VT_FTT = 6
  };
  int32_t copy() const {
    return GetField<int32_t>(VT_COPY, 0);
  }
  int32_t ftt() const {
    return GetField<int32_t>(VT_FTT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COPY, 4) &&
           VerifyField<int32_t>(verifier, VT_FTT, 4) &&
           verifier.EndTable();
  }
  MirrorArgsFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MirrorArgsFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MirrorArgsFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorArgsFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MirrorArgsFBBuilder {
  typedef MirrorArgsFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_copy(int32_t copy) {
    fbb_.AddElement<int32_t>(MirrorArgsFB::VT_COPY, copy, 0);
  }
  void add_ftt(int32_t ftt) {
    fbb_.AddElement<int32_t>(MirrorArgsFB::VT_FTT, ftt, 0);
  }
  explicit MirrorArgsFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MirrorArgsFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MirrorArgsFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MirrorArgsFB> CreateMirrorArgsFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t copy = 0,
    int32_t ftt = 0) {
  MirrorArgsFBBuilder builder_(_fbb);
  builder_.add_ftt(ftt);
  builder_.add_copy(copy);
  return builder_.Finish();
}

::flatbuffers::Offset<MirrorArgsFB> CreateMirrorArgsFB(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorArgsFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChunkOptionsFBT : public ::flatbuffers::NativeTable {
  typedef ChunkOptionsFB TableType;
  int32_t ftt_type = 0;
  std::unique_ptr<MirrorArgsFBT> mirror{};
  std::string placement{};
  ChunkOptionsFBT() = default;
  ChunkOptionsFBT(const ChunkOptionsFBT &o);
  ChunkOptionsFBT(ChunkOptionsFBT&&) FLATBUFFERS_NOEXCEPT = default;
  ChunkOptionsFBT &operator=(ChunkOptionsFBT o) FLATBUFFERS_NOEXCEPT;
};

struct ChunkOptionsFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkOptionsFBT NativeTableType;
  typedef ChunkOptionsFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChunkOptionsFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FTT_TYPE = 4,
    VT_MIRROR = 6,
    VT_PLACEMENT = 8
  };
  int32_t ftt_type() const {
    return GetField<int32_t>(VT_FTT_TYPE, 0);
  }
  const MirrorArgsFB *mirror() const {
    return GetPointer<const MirrorArgsFB *>(VT_MIRROR);
  }
  const ::flatbuffers::String *placement() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLACEMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FTT_TYPE, 4) &&
           VerifyOffset(verifier, VT_MIRROR) &&
           verifier.VerifyTable(mirror()) &&
           VerifyOffset(verifier, VT_PLACEMENT) &&
           verifier.VerifyString(placement()) &&
           verifier.EndTable();
  }
  ChunkOptionsFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChunkOptionsFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ChunkOptionsFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkOptionsFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChunkOptionsFBBuilder {
  typedef ChunkOptionsFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ftt_type(int32_t ftt_type) {
    fbb_.AddElement<int32_t>(ChunkOptionsFB::VT_FTT_TYPE, ftt_type, 0);
  }
  void add_mirror(::flatbuffers::Offset<MirrorArgsFB> mirror) {
    fbb_.AddOffset(ChunkOptionsFB::VT_MIRROR, mirror);
  }
  void add_placement(::flatbuffers::Offset<::flatbuffers::String> placement) {
    fbb_.AddOffset(ChunkOptionsFB::VT_PLACEMENT, placement);
  }
  explicit ChunkOptionsFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChunkOptionsFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChunkOptionsFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChunkOptionsFB> CreateChunkOptionsFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ftt_type = 0,
    ::flatbuffers::Offset<MirrorArgsFB> mirror = 0,
    ::flatbuffers::Offset<::flatbuffers::String> placement = 0) {
  ChunkOptionsFBBuilder builder_(_fbb);
  builder_.add_placement(placement);
  builder_.add_mirror(mirror);
  builder_.add_ftt_type(ftt_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ChunkOptionsFB> CreateChunkOptionsFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ftt_type = 0,
    ::flatbuffers::Offset<MirrorArgsFB> mirror = 0,
    const char *placement = nullptr) {
  auto placement__ = placement ? _fbb.CreateString(placement) : 0;
  return CreateChunkOptionsFB(
      _fbb,
      ftt_type,
      mirror,
      placement__);
}

::flatbuffers::Offset<ChunkOptionsFB> CreateChunkOptionsFB(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkOptionsFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReplicaLocationFBT : public ::flatbuffers::NativeTable {
  typedef ReplicaLocationFB TableType;
  std::string cs_location{};
  int32_t disk_location = 0;
  uint32_t disk_type = 0;
};

struct ReplicaLocationFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReplicaLocationFBT NativeTableType;
  typedef ReplicaLocationFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReplicaLocationFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CS_LOCATION = 4,
    VT_DISK_LOCATION = 6,
    VT_DISK_TYPE = 8
  };
  const ::flatbuffers::String *cs_location() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CS_LOCATION);
  }
  int32_t disk_location() const {
    return GetField<int32_t>(VT_DISK_LOCATION, 0);
  }
  uint32_t disk_type() const {
    return GetField<uint32_t>(VT_DISK_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CS_LOCATION) &&
           verifier.VerifyString(cs_location()) &&
           VerifyField<int32_t>(verifier, VT_DISK_LOCATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_DISK_TYPE, 4) &&
           verifier.EndTable();
  }
  ReplicaLocationFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReplicaLocationFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReplicaLocationFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReplicaLocationFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReplicaLocationFBBuilder {
  typedef ReplicaLocationFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cs_location(::flatbuffers::Offset<::flatbuffers::String> cs_location) {
    fbb_.AddOffset(ReplicaLocationFB::VT_CS_LOCATION, cs_location);
  }
  void add_disk_location(int32_t disk_location) {
    fbb_.AddElement<int32_t>(ReplicaLocationFB::VT_DISK_LOCATION, disk_location, 0);
  }
  void add_disk_type(uint32_t disk_type) {
    fbb_.AddElement<uint32_t>(ReplicaLocationFB::VT_DISK_TYPE, disk_type, 0);
  }
  explicit ReplicaLocationFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReplicaLocationFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReplicaLocationFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReplicaLocationFB> CreateReplicaLocationFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> cs_location = 0,
    int32_t disk_location = 0,
    uint32_t disk_type = 0) {
  ReplicaLocationFBBuilder builder_(_fbb);
  builder_.add_disk_type(disk_type);
  builder_.add_disk_location(disk_location);
  builder_.add_cs_location(cs_location);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReplicaLocationFB> CreateReplicaLocationFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *cs_location = nullptr,
    int32_t disk_location = 0,
    uint32_t disk_type = 0) {
  auto cs_location__ = cs_location ? _fbb.CreateString(cs_location) : 0;
  return CreateReplicaLocationFB(
      _fbb,
      cs_location__,
      disk_location,
      disk_type);
}

::flatbuffers::Offset<ReplicaLocationFB> CreateReplicaLocationFB(::flatbuffers::FlatBufferBuilder &_fbb, const ReplicaLocationFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AccelerateOpenOptionsFBT : public ::flatbuffers::NativeTable {
  typedef AccelerateOpenOptionsFB TableType;
  std::unique_ptr<ChunkOptionsFBT> chunk_options{};
  std::vector<std::unique_ptr<ReplicaLocationFBT>> chunk_location{};
  uint32_t chunk_sizeexponent = 0;
  uint32_t check_sumcategory = 0;
  AccelerateOpenOptionsFBT() = default;
  AccelerateOpenOptionsFBT(const AccelerateOpenOptionsFBT &o);
  AccelerateOpenOptionsFBT(AccelerateOpenOptionsFBT&&) FLATBUFFERS_NOEXCEPT = default;
  AccelerateOpenOptionsFBT &operator=(AccelerateOpenOptionsFBT o) FLATBUFFERS_NOEXCEPT;
};

struct AccelerateOpenOptionsFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelerateOpenOptionsFBT NativeTableType;
  typedef AccelerateOpenOptionsFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AccelerateOpenOptionsFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNK_OPTIONS = 4,
    VT_CHUNK_LOCATION = 6,
    VT_CHUNK_SIZEEXPONENT = 8,
    VT_CHECK_SUMCATEGORY = 10
  };
  const ChunkOptionsFB *chunk_options() const {
    return GetPointer<const ChunkOptionsFB *>(VT_CHUNK_OPTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ReplicaLocationFB>> *chunk_location() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ReplicaLocationFB>> *>(VT_CHUNK_LOCATION);
  }
  uint32_t chunk_sizeexponent() const {
    return GetField<uint32_t>(VT_CHUNK_SIZEEXPONENT, 0);
  }
  uint32_t check_sumcategory() const {
    return GetField<uint32_t>(VT_CHECK_SUMCATEGORY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNK_OPTIONS) &&
           verifier.VerifyTable(chunk_options()) &&
           VerifyOffset(verifier, VT_CHUNK_LOCATION) &&
           verifier.VerifyVector(chunk_location()) &&
           verifier.VerifyVectorOfTables(chunk_location()) &&
           VerifyField<uint32_t>(verifier, VT_CHUNK_SIZEEXPONENT, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHECK_SUMCATEGORY, 4) &&
           verifier.EndTable();
  }
  AccelerateOpenOptionsFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AccelerateOpenOptionsFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AccelerateOpenOptionsFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelerateOpenOptionsFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AccelerateOpenOptionsFBBuilder {
  typedef AccelerateOpenOptionsFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chunk_options(::flatbuffers::Offset<ChunkOptionsFB> chunk_options) {
    fbb_.AddOffset(AccelerateOpenOptionsFB::VT_CHUNK_OPTIONS, chunk_options);
  }
  void add_chunk_location(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ReplicaLocationFB>>> chunk_location) {
    fbb_.AddOffset(AccelerateOpenOptionsFB::VT_CHUNK_LOCATION, chunk_location);
  }
  void add_chunk_sizeexponent(uint32_t chunk_sizeexponent) {
    fbb_.AddElement<uint32_t>(AccelerateOpenOptionsFB::VT_CHUNK_SIZEEXPONENT, chunk_sizeexponent, 0);
  }
  void add_check_sumcategory(uint32_t check_sumcategory) {
    fbb_.AddElement<uint32_t>(AccelerateOpenOptionsFB::VT_CHECK_SUMCATEGORY, check_sumcategory, 0);
  }
  explicit AccelerateOpenOptionsFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelerateOpenOptionsFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelerateOpenOptionsFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelerateOpenOptionsFB> CreateAccelerateOpenOptionsFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChunkOptionsFB> chunk_options = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ReplicaLocationFB>>> chunk_location = 0,
    uint32_t chunk_sizeexponent = 0,
    uint32_t check_sumcategory = 0) {
  AccelerateOpenOptionsFBBuilder builder_(_fbb);
  builder_.add_check_sumcategory(check_sumcategory);
  builder_.add_chunk_sizeexponent(chunk_sizeexponent);
  builder_.add_chunk_location(chunk_location);
  builder_.add_chunk_options(chunk_options);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AccelerateOpenOptionsFB> CreateAccelerateOpenOptionsFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChunkOptionsFB> chunk_options = 0,
    const std::vector<::flatbuffers::Offset<ReplicaLocationFB>> *chunk_location = nullptr,
    uint32_t chunk_sizeexponent = 0,
    uint32_t check_sumcategory = 0) {
  auto chunk_location__ = chunk_location ? _fbb.CreateVector<::flatbuffers::Offset<ReplicaLocationFB>>(*chunk_location) : 0;
  return CreateAccelerateOpenOptionsFB(
      _fbb,
      chunk_options,
      chunk_location__,
      chunk_sizeexponent,
      check_sumcategory);
}

::flatbuffers::Offset<AccelerateOpenOptionsFB> CreateAccelerateOpenOptionsFB(::flatbuffers::FlatBufferBuilder &_fbb, const AccelerateOpenOptionsFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IONiceFBT : public ::flatbuffers::NativeTable {
  typedef IONiceFB TableType;
  int32_t priority = 0;
  int32_t io_class = 0;
};

struct IONiceFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IONiceFBT NativeTableType;
  typedef IONiceFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IONiceFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRIORITY = 4,
    VT_IO_CLASS = 6
  };
  int32_t priority() const {
    return GetField<int32_t>(VT_PRIORITY, 0);
  }
  int32_t io_class() const {
    return GetField<int32_t>(VT_IO_CLASS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<int32_t>(verifier, VT_IO_CLASS, 4) &&
           verifier.EndTable();
  }
  IONiceFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IONiceFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IONiceFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IONiceFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IONiceFBBuilder {
  typedef IONiceFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_priority(int32_t priority) {
    fbb_.AddElement<int32_t>(IONiceFB::VT_PRIORITY, priority, 0);
  }
  void add_io_class(int32_t io_class) {
    fbb_.AddElement<int32_t>(IONiceFB::VT_IO_CLASS, io_class, 0);
  }
  explicit IONiceFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IONiceFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IONiceFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IONiceFB> CreateIONiceFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t priority = 0,
    int32_t io_class = 0) {
  IONiceFBBuilder builder_(_fbb);
  builder_.add_io_class(io_class);
  builder_.add_priority(priority);
  return builder_.Finish();
}

::flatbuffers::Offset<IONiceFB> CreateIONiceFB(::flatbuffers::FlatBufferBuilder &_fbb, const IONiceFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CsChooseDiskStrategyCJFBT : public ::flatbuffers::NativeTable {
  typedef CsChooseDiskStrategyCJFB TableType;
  std::vector<std::unique_ptr<CsChooseDiskStrategySingleCJFBT>> strategies{};
  int32_t disk_storage_type = 0;
  int32_t target_storage_type = 0;
  CsChooseDiskStrategyCJFBT() = default;
  CsChooseDiskStrategyCJFBT(const CsChooseDiskStrategyCJFBT &o);
  CsChooseDiskStrategyCJFBT(CsChooseDiskStrategyCJFBT&&) FLATBUFFERS_NOEXCEPT = default;
  CsChooseDiskStrategyCJFBT &operator=(CsChooseDiskStrategyCJFBT o) FLATBUFFERS_NOEXCEPT;
};

struct CsChooseDiskStrategyCJFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CsChooseDiskStrategyCJFBT NativeTableType;
  typedef CsChooseDiskStrategyCJFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CsChooseDiskStrategyCJFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRATEGIES = 4,
    VT_DISK_STORAGE_TYPE = 6,
    VT_TARGET_STORAGE_TYPE = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>> *strategies() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>> *>(VT_STRATEGIES);
  }
  int32_t disk_storage_type() const {
    return GetField<int32_t>(VT_DISK_STORAGE_TYPE, 0);
  }
  int32_t target_storage_type() const {
    return GetField<int32_t>(VT_TARGET_STORAGE_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRATEGIES) &&
           verifier.VerifyVector(strategies()) &&
           verifier.VerifyVectorOfTables(strategies()) &&
           VerifyField<int32_t>(verifier, VT_DISK_STORAGE_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGET_STORAGE_TYPE, 4) &&
           verifier.EndTable();
  }
  CsChooseDiskStrategyCJFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CsChooseDiskStrategyCJFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CsChooseDiskStrategyCJFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CsChooseDiskStrategyCJFBBuilder {
  typedef CsChooseDiskStrategyCJFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_strategies(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>>> strategies) {
    fbb_.AddOffset(CsChooseDiskStrategyCJFB::VT_STRATEGIES, strategies);
  }
  void add_disk_storage_type(int32_t disk_storage_type) {
    fbb_.AddElement<int32_t>(CsChooseDiskStrategyCJFB::VT_DISK_STORAGE_TYPE, disk_storage_type, 0);
  }
  void add_target_storage_type(int32_t target_storage_type) {
    fbb_.AddElement<int32_t>(CsChooseDiskStrategyCJFB::VT_TARGET_STORAGE_TYPE, target_storage_type, 0);
  }
  explicit CsChooseDiskStrategyCJFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CsChooseDiskStrategyCJFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> CreateCsChooseDiskStrategyCJFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>>> strategies = 0,
    int32_t disk_storage_type = 0,
    int32_t target_storage_type = 0) {
  CsChooseDiskStrategyCJFBBuilder builder_(_fbb);
  builder_.add_target_storage_type(target_storage_type);
  builder_.add_disk_storage_type(disk_storage_type);
  builder_.add_strategies(strategies);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> CreateCsChooseDiskStrategyCJFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>> *strategies = nullptr,
    int32_t disk_storage_type = 0,
    int32_t target_storage_type = 0) {
  auto strategies__ = strategies ? _fbb.CreateVector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>>(*strategies) : 0;
  return CreateCsChooseDiskStrategyCJFB(
      _fbb,
      strategies__,
      disk_storage_type,
      target_storage_type);
}

::flatbuffers::Offset<CsChooseDiskStrategyCJFB> CreateCsChooseDiskStrategyCJFB(::flatbuffers::FlatBufferBuilder &_fbb, const CsChooseDiskStrategyCJFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChunkOrStreamIdInfoFBT : public ::flatbuffers::NativeTable {
  typedef ChunkOrStreamIdInfoFB TableType;
  std::unique_ptr<UUIDInfoFBT> uuid{};
  uint32_t partition_index = 0;
  uint32_t padding = 0;
  ChunkOrStreamIdInfoFBT() = default;
  ChunkOrStreamIdInfoFBT(const ChunkOrStreamIdInfoFBT &o);
  ChunkOrStreamIdInfoFBT(ChunkOrStreamIdInfoFBT&&) FLATBUFFERS_NOEXCEPT = default;
  ChunkOrStreamIdInfoFBT &operator=(ChunkOrStreamIdInfoFBT o) FLATBUFFERS_NOEXCEPT;
};

struct ChunkOrStreamIdInfoFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkOrStreamIdInfoFBT NativeTableType;
  typedef ChunkOrStreamIdInfoFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChunkOrStreamIdInfoFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_PARTITION_INDEX = 6,
    VT_PADDING = 8
  };
  const UUIDInfoFB *uuid() const {
    return GetPointer<const UUIDInfoFB *>(VT_UUID);
  }
  uint32_t partition_index() const {
    return GetField<uint32_t>(VT_PARTITION_INDEX, 0);
  }
  uint32_t padding() const {
    return GetField<uint32_t>(VT_PADDING, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyTable(uuid()) &&
           VerifyField<uint32_t>(verifier, VT_PARTITION_INDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
  ChunkOrStreamIdInfoFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChunkOrStreamIdInfoFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkOrStreamIdInfoFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChunkOrStreamIdInfoFBBuilder {
  typedef ChunkOrStreamIdInfoFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(::flatbuffers::Offset<UUIDInfoFB> uuid) {
    fbb_.AddOffset(ChunkOrStreamIdInfoFB::VT_UUID, uuid);
  }
  void add_partition_index(uint32_t partition_index) {
    fbb_.AddElement<uint32_t>(ChunkOrStreamIdInfoFB::VT_PARTITION_INDEX, partition_index, 0);
  }
  void add_padding(uint32_t padding) {
    fbb_.AddElement<uint32_t>(ChunkOrStreamIdInfoFB::VT_PADDING, padding, 0);
  }
  explicit ChunkOrStreamIdInfoFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChunkOrStreamIdInfoFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> CreateChunkOrStreamIdInfoFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UUIDInfoFB> uuid = 0,
    uint32_t partition_index = 0,
    uint32_t padding = 0) {
  ChunkOrStreamIdInfoFBBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_partition_index(partition_index);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

::flatbuffers::Offset<ChunkOrStreamIdInfoFB> CreateChunkOrStreamIdInfoFB(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkOrStreamIdInfoFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QosOptionsFBT : public ::flatbuffers::NativeTable {
  typedef QosOptionsFB TableType;
  uint32_t service_id = 0;
  uint32_t flow_id = 0;
  int32_t adjust = 0;
  uint32_t cache_groupid = 0;
  int32_t network_priority = 0;
};

struct QosOptionsFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QosOptionsFBT NativeTableType;
  typedef QosOptionsFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QosOptionsFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVICE_ID = 4,
    VT_FLOW_ID = 6,
    VT_ADJUST = 8,
    VT_CACHE_GROUPID = 10,
    VT_NETWORK_PRIORITY = 12
  };
  uint32_t service_id() const {
    return GetField<uint32_t>(VT_SERVICE_ID, 0);
  }
  uint32_t flow_id() const {
    return GetField<uint32_t>(VT_FLOW_ID, 0);
  }
  int32_t adjust() const {
    return GetField<int32_t>(VT_ADJUST, 0);
  }
  uint32_t cache_groupid() const {
    return GetField<uint32_t>(VT_CACHE_GROUPID, 0);
  }
  int32_t network_priority() const {
    return GetField<int32_t>(VT_NETWORK_PRIORITY, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SERVICE_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_FLOW_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_ADJUST, 4) &&
           VerifyField<uint32_t>(verifier, VT_CACHE_GROUPID, 4) &&
           VerifyField<int32_t>(verifier, VT_NETWORK_PRIORITY, 4) &&
           verifier.EndTable();
  }
  QosOptionsFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QosOptionsFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<QosOptionsFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QosOptionsFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QosOptionsFBBuilder {
  typedef QosOptionsFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_service_id(uint32_t service_id) {
    fbb_.AddElement<uint32_t>(QosOptionsFB::VT_SERVICE_ID, service_id, 0);
  }
  void add_flow_id(uint32_t flow_id) {
    fbb_.AddElement<uint32_t>(QosOptionsFB::VT_FLOW_ID, flow_id, 0);
  }
  void add_adjust(int32_t adjust) {
    fbb_.AddElement<int32_t>(QosOptionsFB::VT_ADJUST, adjust, 0);
  }
  void add_cache_groupid(uint32_t cache_groupid) {
    fbb_.AddElement<uint32_t>(QosOptionsFB::VT_CACHE_GROUPID, cache_groupid, 0);
  }
  void add_network_priority(int32_t network_priority) {
    fbb_.AddElement<int32_t>(QosOptionsFB::VT_NETWORK_PRIORITY, network_priority, 0);
  }
  explicit QosOptionsFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QosOptionsFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QosOptionsFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QosOptionsFB> CreateQosOptionsFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t service_id = 0,
    uint32_t flow_id = 0,
    int32_t adjust = 0,
    uint32_t cache_groupid = 0,
    int32_t network_priority = 0) {
  QosOptionsFBBuilder builder_(_fbb);
  builder_.add_network_priority(network_priority);
  builder_.add_cache_groupid(cache_groupid);
  builder_.add_adjust(adjust);
  builder_.add_flow_id(flow_id);
  builder_.add_service_id(service_id);
  return builder_.Finish();
}

::flatbuffers::Offset<QosOptionsFB> CreateQosOptionsFB(::flatbuffers::FlatBufferBuilder &_fbb, const QosOptionsFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlushChecksumFBT : public ::flatbuffers::NativeTable {
  typedef FlushChecksumFB TableType;
  uint32_t category = 0;
  int64_t value = 0;
};

struct FlushChecksumFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlushChecksumFBT NativeTableType;
  typedef FlushChecksumFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlushChecksumFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CATEGORY = 4,
    VT_VALUE = 6
  };
  uint32_t category() const {
    return GetField<uint32_t>(VT_CATEGORY, 0);
  }
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CATEGORY, 4) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
  FlushChecksumFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlushChecksumFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlushChecksumFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlushChecksumFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlushChecksumFBBuilder {
  typedef FlushChecksumFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_category(uint32_t category) {
    fbb_.AddElement<uint32_t>(FlushChecksumFB::VT_CATEGORY, category, 0);
  }
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(FlushChecksumFB::VT_VALUE, value, 0);
  }
  explicit FlushChecksumFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlushChecksumFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlushChecksumFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlushChecksumFB> CreateFlushChecksumFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t category = 0,
    int64_t value = 0) {
  FlushChecksumFBBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_category(category);
  return builder_.Finish();
}

::flatbuffers::Offset<FlushChecksumFB> CreateFlushChecksumFB(::flatbuffers::FlatBufferBuilder &_fbb, const FlushChecksumFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UUIDInfoFBT : public ::flatbuffers::NativeTable {
  typedef UUIDInfoFB TableType;
  uint64_t low = 0;
  uint64_t high = 0;
};

struct UUIDInfoFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UUIDInfoFBT NativeTableType;
  typedef UUIDInfoFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UUIDInfoFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW = 4,
    VT_HIGH = 6
  };
  uint64_t low() const {
    return GetField<uint64_t>(VT_LOW, 0);
  }
  uint64_t high() const {
    return GetField<uint64_t>(VT_HIGH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOW, 8) &&
           VerifyField<uint64_t>(verifier, VT_HIGH, 8) &&
           verifier.EndTable();
  }
  UUIDInfoFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UUIDInfoFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UUIDInfoFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UUIDInfoFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UUIDInfoFBBuilder {
  typedef UUIDInfoFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_low(uint64_t low) {
    fbb_.AddElement<uint64_t>(UUIDInfoFB::VT_LOW, low, 0);
  }
  void add_high(uint64_t high) {
    fbb_.AddElement<uint64_t>(UUIDInfoFB::VT_HIGH, high, 0);
  }
  explicit UUIDInfoFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UUIDInfoFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UUIDInfoFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UUIDInfoFB> CreateUUIDInfoFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t low = 0,
    uint64_t high = 0) {
  UUIDInfoFBBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  return builder_.Finish();
}

::flatbuffers::Offset<UUIDInfoFB> CreateUUIDInfoFB(::flatbuffers::FlatBufferBuilder &_fbb, const UUIDInfoFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RootServerIdFBT : public ::flatbuffers::NativeTable {
  typedef RootServerIdFB TableType;
  std::unique_ptr<UUIDInfoFBT> uuid{};
  int64_t leader_term = 0;
  RootServerIdFBT() = default;
  RootServerIdFBT(const RootServerIdFBT &o);
  RootServerIdFBT(RootServerIdFBT&&) FLATBUFFERS_NOEXCEPT = default;
  RootServerIdFBT &operator=(RootServerIdFBT o) FLATBUFFERS_NOEXCEPT;
};

struct RootServerIdFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RootServerIdFBT NativeTableType;
  typedef RootServerIdFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RootServerIdFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_LEADER_TERM = 6
  };
  const UUIDInfoFB *uuid() const {
    return GetPointer<const UUIDInfoFB *>(VT_UUID);
  }
  int64_t leader_term() const {
    return GetField<int64_t>(VT_LEADER_TERM, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyTable(uuid()) &&
           VerifyField<int64_t>(verifier, VT_LEADER_TERM, 8) &&
           verifier.EndTable();
  }
  RootServerIdFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RootServerIdFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RootServerIdFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RootServerIdFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RootServerIdFBBuilder {
  typedef RootServerIdFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uuid(::flatbuffers::Offset<UUIDInfoFB> uuid) {
    fbb_.AddOffset(RootServerIdFB::VT_UUID, uuid);
  }
  void add_leader_term(int64_t leader_term) {
    fbb_.AddElement<int64_t>(RootServerIdFB::VT_LEADER_TERM, leader_term, 0);
  }
  explicit RootServerIdFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RootServerIdFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RootServerIdFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RootServerIdFB> CreateRootServerIdFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UUIDInfoFB> uuid = 0,
    int64_t leader_term = 0) {
  RootServerIdFBBuilder builder_(_fbb);
  builder_.add_leader_term(leader_term);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

::flatbuffers::Offset<RootServerIdFB> CreateRootServerIdFB(::flatbuffers::FlatBufferBuilder &_fbb, const RootServerIdFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChunkIdTypeCJFBT : public ::flatbuffers::NativeTable {
  typedef ChunkIdTypeCJFB TableType;
  uint64_t belonged_fileid = 0;
  uint32_t chunk_index = 0;
  uint32_t padding = 0;
};

struct ChunkIdTypeCJFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkIdTypeCJFBT NativeTableType;
  typedef ChunkIdTypeCJFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChunkIdTypeCJFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BELONGED_FILEID = 4,
    VT_CHUNK_INDEX = 6,
    VT_PADDING = 8
  };
  uint64_t belonged_fileid() const {
    return GetField<uint64_t>(VT_BELONGED_FILEID, 0);
  }
  uint32_t chunk_index() const {
    return GetField<uint32_t>(VT_CHUNK_INDEX, 0);
  }
  uint32_t padding() const {
    return GetField<uint32_t>(VT_PADDING, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BELONGED_FILEID, 8) &&
           VerifyField<uint32_t>(verifier, VT_CHUNK_INDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
  ChunkIdTypeCJFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChunkIdTypeCJFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ChunkIdTypeCJFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkIdTypeCJFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChunkIdTypeCJFBBuilder {
  typedef ChunkIdTypeCJFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_belonged_fileid(uint64_t belonged_fileid) {
    fbb_.AddElement<uint64_t>(ChunkIdTypeCJFB::VT_BELONGED_FILEID, belonged_fileid, 0);
  }
  void add_chunk_index(uint32_t chunk_index) {
    fbb_.AddElement<uint32_t>(ChunkIdTypeCJFB::VT_CHUNK_INDEX, chunk_index, 0);
  }
  void add_padding(uint32_t padding) {
    fbb_.AddElement<uint32_t>(ChunkIdTypeCJFB::VT_PADDING, padding, 0);
  }
  explicit ChunkIdTypeCJFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChunkIdTypeCJFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChunkIdTypeCJFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChunkIdTypeCJFB> CreateChunkIdTypeCJFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t belonged_fileid = 0,
    uint32_t chunk_index = 0,
    uint32_t padding = 0) {
  ChunkIdTypeCJFBBuilder builder_(_fbb);
  builder_.add_belonged_fileid(belonged_fileid);
  builder_.add_padding(padding);
  builder_.add_chunk_index(chunk_index);
  return builder_.Finish();
}

::flatbuffers::Offset<ChunkIdTypeCJFB> CreateChunkIdTypeCJFB(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkIdTypeCJFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PanguTraceSpanInfoFBT : public ::flatbuffers::NativeTable {
  typedef PanguTraceSpanInfoFB TableType;
  uint64_t trace_id_low = 0;
  uint64_t trace_id_high = 0;
  uint64_t span_id = 0;
};

struct PanguTraceSpanInfoFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PanguTraceSpanInfoFBT NativeTableType;
  typedef PanguTraceSpanInfoFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PanguTraceSpanInfoFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRACE_ID_LOW = 4,
    VT_TRACE_ID_HIGH = 6,
    VT_SPAN_ID = 8
  };
  uint64_t trace_id_low() const {
    return GetField<uint64_t>(VT_TRACE_ID_LOW, 0);
  }
  uint64_t trace_id_high() const {
    return GetField<uint64_t>(VT_TRACE_ID_HIGH, 0);
  }
  uint64_t span_id() const {
    return GetField<uint64_t>(VT_SPAN_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TRACE_ID_LOW, 8) &&
           VerifyField<uint64_t>(verifier, VT_TRACE_ID_HIGH, 8) &&
           VerifyField<uint64_t>(verifier, VT_SPAN_ID, 8) &&
           verifier.EndTable();
  }
  PanguTraceSpanInfoFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PanguTraceSpanInfoFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PanguTraceSpanInfoFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PanguTraceSpanInfoFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PanguTraceSpanInfoFBBuilder {
  typedef PanguTraceSpanInfoFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_trace_id_low(uint64_t trace_id_low) {
    fbb_.AddElement<uint64_t>(PanguTraceSpanInfoFB::VT_TRACE_ID_LOW, trace_id_low, 0);
  }
  void add_trace_id_high(uint64_t trace_id_high) {
    fbb_.AddElement<uint64_t>(PanguTraceSpanInfoFB::VT_TRACE_ID_HIGH, trace_id_high, 0);
  }
  void add_span_id(uint64_t span_id) {
    fbb_.AddElement<uint64_t>(PanguTraceSpanInfoFB::VT_SPAN_ID, span_id, 0);
  }
  explicit PanguTraceSpanInfoFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PanguTraceSpanInfoFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PanguTraceSpanInfoFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PanguTraceSpanInfoFB> CreatePanguTraceSpanInfoFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t trace_id_low = 0,
    uint64_t trace_id_high = 0,
    uint64_t span_id = 0) {
  PanguTraceSpanInfoFBBuilder builder_(_fbb);
  builder_.add_span_id(span_id);
  builder_.add_trace_id_high(trace_id_high);
  builder_.add_trace_id_low(trace_id_low);
  return builder_.Finish();
}

::flatbuffers::Offset<PanguTraceSpanInfoFB> CreatePanguTraceSpanInfoFB(::flatbuffers::FlatBufferBuilder &_fbb, const PanguTraceSpanInfoFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CsChooseDiskStrategySingleCJFBT : public ::flatbuffers::NativeTable {
  typedef CsChooseDiskStrategySingleCJFB TableType;
  uint32_t method = 0;
  uint32_t weight = 0;
  uint64_t parameter = 0;
};

struct CsChooseDiskStrategySingleCJFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CsChooseDiskStrategySingleCJFBT NativeTableType;
  typedef CsChooseDiskStrategySingleCJFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CsChooseDiskStrategySingleCJFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_WEIGHT = 6,
    VT_PARAMETER = 8
  };
  uint32_t method() const {
    return GetField<uint32_t>(VT_METHOD, 0);
  }
  uint32_t weight() const {
    return GetField<uint32_t>(VT_WEIGHT, 0);
  }
  uint64_t parameter() const {
    return GetField<uint64_t>(VT_PARAMETER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_METHOD, 4) &&
           VerifyField<uint32_t>(verifier, VT_WEIGHT, 4) &&
           VerifyField<uint64_t>(verifier, VT_PARAMETER, 8) &&
           verifier.EndTable();
  }
  CsChooseDiskStrategySingleCJFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CsChooseDiskStrategySingleCJFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CsChooseDiskStrategySingleCJFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CsChooseDiskStrategySingleCJFBBuilder {
  typedef CsChooseDiskStrategySingleCJFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_method(uint32_t method) {
    fbb_.AddElement<uint32_t>(CsChooseDiskStrategySingleCJFB::VT_METHOD, method, 0);
  }
  void add_weight(uint32_t weight) {
    fbb_.AddElement<uint32_t>(CsChooseDiskStrategySingleCJFB::VT_WEIGHT, weight, 0);
  }
  void add_parameter(uint64_t parameter) {
    fbb_.AddElement<uint64_t>(CsChooseDiskStrategySingleCJFB::VT_PARAMETER, parameter, 0);
  }
  explicit CsChooseDiskStrategySingleCJFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB> CreateCsChooseDiskStrategySingleCJFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t method = 0,
    uint32_t weight = 0,
    uint64_t parameter = 0) {
  CsChooseDiskStrategySingleCJFBBuilder builder_(_fbb);
  builder_.add_parameter(parameter);
  builder_.add_weight(weight);
  builder_.add_method(method);
  return builder_.Finish();
}

::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB> CreateCsChooseDiskStrategySingleCJFB(::flatbuffers::FlatBufferBuilder &_fbb, const CsChooseDiskStrategySingleCJFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlatLogFileFlushChunkRequestFBT : public ::flatbuffers::NativeTable {
  typedef FlatLogFileFlushChunkRequestFB TableType;
  std::unique_ptr<ChunkIdTypeCJFBT> chunk_id{};
  uint32_t offset = 0;
  uint32_t length = 0;
  uint32_t storage_id = 0;
  std::string data{};
  uint32_t hint = 0;
  bool is_replication = false;
  bool trace_open = false;
  std::unique_ptr<IONiceFBT> io_nice{};
  std::unique_ptr<AccelerateOpenOptionsFBT> open_chunkoptions{};
  int32_t open_mode = 0;
  int64_t handle = 0;
  bool data_sync = false;
  std::unique_ptr<PanguTraceSpanInfoFBT> trace_span{};
  bool create_ifnotexists = false;
  std::unique_ptr<CsChooseDiskStrategyCJFBT> strategy{};
  std::unique_ptr<ChunkOrStreamIdInfoFBT> chunk_id_v2{};
  std::unique_ptr<QosOptionsFBT> qos_options{};
  std::unique_ptr<FlushChecksumFBT> checksum{};
  std::unique_ptr<UUIDInfoFBT> volume_uuid{};
  uint32_t module_version = 0;
  std::string hostname{};
  uint32_t disk_id = 0;
  uint64_t request_id = 0;
  std::string user_id{};
  std::unique_ptr<RootServerIdFBT> root_server_id{};
  uint32_t required_min_csversion = 0;
  int32_t fromtype = 0;
  uint64_t offset64 = 0;
  uint32_t record_size = 0;
  uint32_t pool_id = 0;
  uint64_t storage_pool_confversion = 0;
  int32_t a = 0;
  FlatLogFileFlushChunkRequestFBT() = default;
  FlatLogFileFlushChunkRequestFBT(const FlatLogFileFlushChunkRequestFBT &o);
  FlatLogFileFlushChunkRequestFBT(FlatLogFileFlushChunkRequestFBT&&) FLATBUFFERS_NOEXCEPT = default;
  FlatLogFileFlushChunkRequestFBT &operator=(FlatLogFileFlushChunkRequestFBT o) FLATBUFFERS_NOEXCEPT;
};

struct FlatLogFileFlushChunkRequestFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatLogFileFlushChunkRequestFBT NativeTableType;
  typedef FlatLogFileFlushChunkRequestFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlatLogFileFlushChunkRequestFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNK_ID = 4,
    VT_OFFSET = 6,
    VT_LENGTH = 8,
    VT_STORAGE_ID = 10,
    VT_DATA = 12,
    VT_HINT = 14,
    VT_IS_REPLICATION = 16,
    VT_TRACE_OPEN = 18,
    VT_IO_NICE = 20,
    VT_OPEN_CHUNKOPTIONS = 22,
    VT_OPEN_MODE = 24,
    VT_HANDLE = 26,
    VT_DATA_SYNC = 28,
    VT_TRACE_SPAN = 30,
    VT_CREATE_IFNOTEXISTS = 32,
    VT_STRATEGY = 34,
    VT_CHUNK_ID_V2 = 36,
    VT_QOS_OPTIONS = 38,
    VT_CHECKSUM = 40,
    VT_VOLUME_UUID = 42,
    VT_MODULE_VERSION = 44,
    VT_HOSTNAME = 46,
    VT_DISK_ID = 48,
    VT_REQUEST_ID = 50,
    VT_USER_ID = 52,
    VT_ROOT_SERVER_ID = 54,
    VT_REQUIRED_MIN_CSVERSION = 56,
    VT_FROMTYPE = 58,
    VT_OFFSET64 = 60,
    VT_RECORD_SIZE = 62,
    VT_POOL_ID = 64,
    VT_STORAGE_POOL_CONFVERSION = 66,
    VT_A = 68
  };
  const ChunkIdTypeCJFB *chunk_id() const {
    return GetPointer<const ChunkIdTypeCJFB *>(VT_CHUNK_ID);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint32_t length() const {
    return GetField<uint32_t>(VT_LENGTH, 0);
  }
  uint32_t storage_id() const {
    return GetField<uint32_t>(VT_STORAGE_ID, 0);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  uint32_t hint() const {
    return GetField<uint32_t>(VT_HINT, 0);
  }
  bool is_replication() const {
    return GetField<uint8_t>(VT_IS_REPLICATION, 0) != 0;
  }
  bool trace_open() const {
    return GetField<uint8_t>(VT_TRACE_OPEN, 0) != 0;
  }
  const IONiceFB *io_nice() const {
    return GetPointer<const IONiceFB *>(VT_IO_NICE);
  }
  const AccelerateOpenOptionsFB *open_chunkoptions() const {
    return GetPointer<const AccelerateOpenOptionsFB *>(VT_OPEN_CHUNKOPTIONS);
  }
  int32_t open_mode() const {
    return GetField<int32_t>(VT_OPEN_MODE, 0);
  }
  int64_t handle() const {
    return GetField<int64_t>(VT_HANDLE, 0);
  }
  bool data_sync() const {
    return GetField<uint8_t>(VT_DATA_SYNC, 0) != 0;
  }
  const PanguTraceSpanInfoFB *trace_span() const {
    return GetPointer<const PanguTraceSpanInfoFB *>(VT_TRACE_SPAN);
  }
  bool create_ifnotexists() const {
    return GetField<uint8_t>(VT_CREATE_IFNOTEXISTS, 0) != 0;
  }
  const CsChooseDiskStrategyCJFB *strategy() const {
    return GetPointer<const CsChooseDiskStrategyCJFB *>(VT_STRATEGY);
  }
  const ChunkOrStreamIdInfoFB *chunk_id_v2() const {
    return GetPointer<const ChunkOrStreamIdInfoFB *>(VT_CHUNK_ID_V2);
  }
  const QosOptionsFB *qos_options() const {
    return GetPointer<const QosOptionsFB *>(VT_QOS_OPTIONS);
  }
  const FlushChecksumFB *checksum() const {
    return GetPointer<const FlushChecksumFB *>(VT_CHECKSUM);
  }
  const UUIDInfoFB *volume_uuid() const {
    return GetPointer<const UUIDInfoFB *>(VT_VOLUME_UUID);
  }
  uint32_t module_version() const {
    return GetField<uint32_t>(VT_MODULE_VERSION, 0);
  }
  const ::flatbuffers::String *hostname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOSTNAME);
  }
  uint32_t disk_id() const {
    return GetField<uint32_t>(VT_DISK_ID, 0);
  }
  uint64_t request_id() const {
    return GetField<uint64_t>(VT_REQUEST_ID, 0);
  }
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  const RootServerIdFB *root_server_id() const {
    return GetPointer<const RootServerIdFB *>(VT_ROOT_SERVER_ID);
  }
  uint32_t required_min_csversion() const {
    return GetField<uint32_t>(VT_REQUIRED_MIN_CSVERSION, 0);
  }
  int32_t fromtype() const {
    return GetField<int32_t>(VT_FROMTYPE, 0);
  }
  uint64_t offset64() const {
    return GetField<uint64_t>(VT_OFFSET64, 0);
  }
  uint32_t record_size() const {
    return GetField<uint32_t>(VT_RECORD_SIZE, 0);
  }
  uint32_t pool_id() const {
    return GetField<uint32_t>(VT_POOL_ID, 0);
  }
  uint64_t storage_pool_confversion() const {
    return GetField<uint64_t>(VT_STORAGE_POOL_CONFVERSION, 0);
  }
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNK_ID) &&
           verifier.VerifyTable(chunk_id()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_LENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_STORAGE_ID, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           VerifyField<uint32_t>(verifier, VT_HINT, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_REPLICATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRACE_OPEN, 1) &&
           VerifyOffset(verifier, VT_IO_NICE) &&
           verifier.VerifyTable(io_nice()) &&
           VerifyOffset(verifier, VT_OPEN_CHUNKOPTIONS) &&
           verifier.VerifyTable(open_chunkoptions()) &&
           VerifyField<int32_t>(verifier, VT_OPEN_MODE, 4) &&
           VerifyField<int64_t>(verifier, VT_HANDLE, 8) &&
           VerifyField<uint8_t>(verifier, VT_DATA_SYNC, 1) &&
           VerifyOffset(verifier, VT_TRACE_SPAN) &&
           verifier.VerifyTable(trace_span()) &&
           VerifyField<uint8_t>(verifier, VT_CREATE_IFNOTEXISTS, 1) &&
           VerifyOffset(verifier, VT_STRATEGY) &&
           verifier.VerifyTable(strategy()) &&
           VerifyOffset(verifier, VT_CHUNK_ID_V2) &&
           verifier.VerifyTable(chunk_id_v2()) &&
           VerifyOffset(verifier, VT_QOS_OPTIONS) &&
           verifier.VerifyTable(qos_options()) &&
           VerifyOffset(verifier, VT_CHECKSUM) &&
           verifier.VerifyTable(checksum()) &&
           VerifyOffset(verifier, VT_VOLUME_UUID) &&
           verifier.VerifyTable(volume_uuid()) &&
           VerifyField<uint32_t>(verifier, VT_MODULE_VERSION, 4) &&
           VerifyOffset(verifier, VT_HOSTNAME) &&
           verifier.VerifyString(hostname()) &&
           VerifyField<uint32_t>(verifier, VT_DISK_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_REQUEST_ID, 8) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyOffset(verifier, VT_ROOT_SERVER_ID) &&
           verifier.VerifyTable(root_server_id()) &&
           VerifyField<uint32_t>(verifier, VT_REQUIRED_MIN_CSVERSION, 4) &&
           VerifyField<int32_t>(verifier, VT_FROMTYPE, 4) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET64, 8) &&
           VerifyField<uint32_t>(verifier, VT_RECORD_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_POOL_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_STORAGE_POOL_CONFVERSION, 8) &&
           VerifyField<int32_t>(verifier, VT_A, 4) &&
           verifier.EndTable();
  }
  FlatLogFileFlushChunkRequestFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlatLogFileFlushChunkRequestFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlatLogFileFlushChunkRequestFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlatLogFileFlushChunkRequestFBBuilder {
  typedef FlatLogFileFlushChunkRequestFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chunk_id(::flatbuffers::Offset<ChunkIdTypeCJFB> chunk_id) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_CHUNK_ID, chunk_id);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_OFFSET, offset, 0);
  }
  void add_length(uint32_t length) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_LENGTH, length, 0);
  }
  void add_storage_id(uint32_t storage_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_STORAGE_ID, storage_id, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_DATA, data);
  }
  void add_hint(uint32_t hint) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_HINT, hint, 0);
  }
  void add_is_replication(bool is_replication) {
    fbb_.AddElement<uint8_t>(FlatLogFileFlushChunkRequestFB::VT_IS_REPLICATION, static_cast<uint8_t>(is_replication), 0);
  }
  void add_trace_open(bool trace_open) {
    fbb_.AddElement<uint8_t>(FlatLogFileFlushChunkRequestFB::VT_TRACE_OPEN, static_cast<uint8_t>(trace_open), 0);
  }
  void add_io_nice(::flatbuffers::Offset<IONiceFB> io_nice) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_IO_NICE, io_nice);
  }
  void add_open_chunkoptions(::flatbuffers::Offset<AccelerateOpenOptionsFB> open_chunkoptions) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_OPEN_CHUNKOPTIONS, open_chunkoptions);
  }
  void add_open_mode(int32_t open_mode) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkRequestFB::VT_OPEN_MODE, open_mode, 0);
  }
  void add_handle(int64_t handle) {
    fbb_.AddElement<int64_t>(FlatLogFileFlushChunkRequestFB::VT_HANDLE, handle, 0);
  }
  void add_data_sync(bool data_sync) {
    fbb_.AddElement<uint8_t>(FlatLogFileFlushChunkRequestFB::VT_DATA_SYNC, static_cast<uint8_t>(data_sync), 0);
  }
  void add_trace_span(::flatbuffers::Offset<PanguTraceSpanInfoFB> trace_span) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_TRACE_SPAN, trace_span);
  }
  void add_create_ifnotexists(bool create_ifnotexists) {
    fbb_.AddElement<uint8_t>(FlatLogFileFlushChunkRequestFB::VT_CREATE_IFNOTEXISTS, static_cast<uint8_t>(create_ifnotexists), 0);
  }
  void add_strategy(::flatbuffers::Offset<CsChooseDiskStrategyCJFB> strategy) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_STRATEGY, strategy);
  }
  void add_chunk_id_v2(::flatbuffers::Offset<ChunkOrStreamIdInfoFB> chunk_id_v2) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_CHUNK_ID_V2, chunk_id_v2);
  }
  void add_qos_options(::flatbuffers::Offset<QosOptionsFB> qos_options) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_QOS_OPTIONS, qos_options);
  }
  void add_checksum(::flatbuffers::Offset<FlushChecksumFB> checksum) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_CHECKSUM, checksum);
  }
  void add_volume_uuid(::flatbuffers::Offset<UUIDInfoFB> volume_uuid) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_VOLUME_UUID, volume_uuid);
  }
  void add_module_version(uint32_t module_version) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_MODULE_VERSION, module_version, 0);
  }
  void add_hostname(::flatbuffers::Offset<::flatbuffers::String> hostname) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_HOSTNAME, hostname);
  }
  void add_disk_id(uint32_t disk_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_DISK_ID, disk_id, 0);
  }
  void add_request_id(uint64_t request_id) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkRequestFB::VT_REQUEST_ID, request_id, 0);
  }
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_USER_ID, user_id);
  }
  void add_root_server_id(::flatbuffers::Offset<RootServerIdFB> root_server_id) {
    fbb_.AddOffset(FlatLogFileFlushChunkRequestFB::VT_ROOT_SERVER_ID, root_server_id);
  }
  void add_required_min_csversion(uint32_t required_min_csversion) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_REQUIRED_MIN_CSVERSION, required_min_csversion, 0);
  }
  void add_fromtype(int32_t fromtype) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkRequestFB::VT_FROMTYPE, fromtype, 0);
  }
  void add_offset64(uint64_t offset64) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkRequestFB::VT_OFFSET64, offset64, 0);
  }
  void add_record_size(uint32_t record_size) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_RECORD_SIZE, record_size, 0);
  }
  void add_pool_id(uint32_t pool_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkRequestFB::VT_POOL_ID, pool_id, 0);
  }
  void add_storage_pool_confversion(uint64_t storage_pool_confversion) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkRequestFB::VT_STORAGE_POOL_CONFVERSION, storage_pool_confversion, 0);
  }
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkRequestFB::VT_A, a, 0);
  }
  explicit FlatLogFileFlushChunkRequestFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> CreateFlatLogFileFlushChunkRequestFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChunkIdTypeCJFB> chunk_id = 0,
    uint32_t offset = 0,
    uint32_t length = 0,
    uint32_t storage_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0,
    uint32_t hint = 0,
    bool is_replication = false,
    bool trace_open = false,
    ::flatbuffers::Offset<IONiceFB> io_nice = 0,
    ::flatbuffers::Offset<AccelerateOpenOptionsFB> open_chunkoptions = 0,
    int32_t open_mode = 0,
    int64_t handle = 0,
    bool data_sync = false,
    ::flatbuffers::Offset<PanguTraceSpanInfoFB> trace_span = 0,
    bool create_ifnotexists = false,
    ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> strategy = 0,
    ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> chunk_id_v2 = 0,
    ::flatbuffers::Offset<QosOptionsFB> qos_options = 0,
    ::flatbuffers::Offset<FlushChecksumFB> checksum = 0,
    ::flatbuffers::Offset<UUIDInfoFB> volume_uuid = 0,
    uint32_t module_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hostname = 0,
    uint32_t disk_id = 0,
    uint64_t request_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    ::flatbuffers::Offset<RootServerIdFB> root_server_id = 0,
    uint32_t required_min_csversion = 0,
    int32_t fromtype = 0,
    uint64_t offset64 = 0,
    uint32_t record_size = 0,
    uint32_t pool_id = 0,
    uint64_t storage_pool_confversion = 0,
    int32_t a = 0) {
  FlatLogFileFlushChunkRequestFBBuilder builder_(_fbb);
  builder_.add_storage_pool_confversion(storage_pool_confversion);
  builder_.add_offset64(offset64);
  builder_.add_request_id(request_id);
  builder_.add_handle(handle);
  builder_.add_a(a);
  builder_.add_pool_id(pool_id);
  builder_.add_record_size(record_size);
  builder_.add_fromtype(fromtype);
  builder_.add_required_min_csversion(required_min_csversion);
  builder_.add_root_server_id(root_server_id);
  builder_.add_user_id(user_id);
  builder_.add_disk_id(disk_id);
  builder_.add_hostname(hostname);
  builder_.add_module_version(module_version);
  builder_.add_volume_uuid(volume_uuid);
  builder_.add_checksum(checksum);
  builder_.add_qos_options(qos_options);
  builder_.add_chunk_id_v2(chunk_id_v2);
  builder_.add_strategy(strategy);
  builder_.add_trace_span(trace_span);
  builder_.add_open_mode(open_mode);
  builder_.add_open_chunkoptions(open_chunkoptions);
  builder_.add_io_nice(io_nice);
  builder_.add_hint(hint);
  builder_.add_data(data);
  builder_.add_storage_id(storage_id);
  builder_.add_length(length);
  builder_.add_offset(offset);
  builder_.add_chunk_id(chunk_id);
  builder_.add_create_ifnotexists(create_ifnotexists);
  builder_.add_data_sync(data_sync);
  builder_.add_trace_open(trace_open);
  builder_.add_is_replication(is_replication);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> CreateFlatLogFileFlushChunkRequestFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ChunkIdTypeCJFB> chunk_id = 0,
    uint32_t offset = 0,
    uint32_t length = 0,
    uint32_t storage_id = 0,
    const char *data = nullptr,
    uint32_t hint = 0,
    bool is_replication = false,
    bool trace_open = false,
    ::flatbuffers::Offset<IONiceFB> io_nice = 0,
    ::flatbuffers::Offset<AccelerateOpenOptionsFB> open_chunkoptions = 0,
    int32_t open_mode = 0,
    int64_t handle = 0,
    bool data_sync = false,
    ::flatbuffers::Offset<PanguTraceSpanInfoFB> trace_span = 0,
    bool create_ifnotexists = false,
    ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> strategy = 0,
    ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> chunk_id_v2 = 0,
    ::flatbuffers::Offset<QosOptionsFB> qos_options = 0,
    ::flatbuffers::Offset<FlushChecksumFB> checksum = 0,
    ::flatbuffers::Offset<UUIDInfoFB> volume_uuid = 0,
    uint32_t module_version = 0,
    const char *hostname = nullptr,
    uint32_t disk_id = 0,
    uint64_t request_id = 0,
    const char *user_id = nullptr,
    ::flatbuffers::Offset<RootServerIdFB> root_server_id = 0,
    uint32_t required_min_csversion = 0,
    int32_t fromtype = 0,
    uint64_t offset64 = 0,
    uint32_t record_size = 0,
    uint32_t pool_id = 0,
    uint64_t storage_pool_confversion = 0,
    int32_t a = 0) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  return CreateFlatLogFileFlushChunkRequestFB(
      _fbb,
      chunk_id,
      offset,
      length,
      storage_id,
      data__,
      hint,
      is_replication,
      trace_open,
      io_nice,
      open_chunkoptions,
      open_mode,
      handle,
      data_sync,
      trace_span,
      create_ifnotexists,
      strategy,
      chunk_id_v2,
      qos_options,
      checksum,
      volume_uuid,
      module_version,
      hostname__,
      disk_id,
      request_id,
      user_id__,
      root_server_id,
      required_min_csversion,
      fromtype,
      offset64,
      record_size,
      pool_id,
      storage_pool_confversion,
      a);
}

::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> CreateFlatLogFileFlushChunkRequestFB(::flatbuffers::FlatBufferBuilder &_fbb, const FlatLogFileFlushChunkRequestFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlatLogFileFlushChunkResponseFBT : public ::flatbuffers::NativeTable {
  typedef FlatLogFileFlushChunkResponseFB TableType;
  int32_t errorcode = 0;
  uint32_t chunk_status = 0;
  uint32_t hint = 0;
  uint32_t ack_length = 0;
  uint32_t trace_type = 0;
  std::string trace_data{};
  int64_t handle = 0;
  uint32_t storage_id = 0;
  uint32_t disk_id = 0;
  uint64_t request_id = 0;
  int64_t checksum = 0;
  uint64_t left_replica_size = 0;
  int32_t a = 0;
};

struct FlatLogFileFlushChunkResponseFB FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatLogFileFlushChunkResponseFBT NativeTableType;
  typedef FlatLogFileFlushChunkResponseFBBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlatLogFileFlushChunkResponseFBTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4,
    VT_CHUNK_STATUS = 6,
    VT_HINT = 8,
    VT_ACK_LENGTH = 10,
    VT_TRACE_TYPE = 12,
    VT_TRACE_DATA = 14,
    VT_HANDLE = 16,
    VT_STORAGE_ID = 18,
    VT_DISK_ID = 20,
    VT_REQUEST_ID = 22,
    VT_CHECKSUM = 24,
    VT_LEFT_REPLICA_SIZE = 26,
    VT_A = 28
  };
  int32_t errorcode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  uint32_t chunk_status() const {
    return GetField<uint32_t>(VT_CHUNK_STATUS, 0);
  }
  uint32_t hint() const {
    return GetField<uint32_t>(VT_HINT, 0);
  }
  uint32_t ack_length() const {
    return GetField<uint32_t>(VT_ACK_LENGTH, 0);
  }
  uint32_t trace_type() const {
    return GetField<uint32_t>(VT_TRACE_TYPE, 0);
  }
  const ::flatbuffers::String *trace_data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACE_DATA);
  }
  int64_t handle() const {
    return GetField<int64_t>(VT_HANDLE, 0);
  }
  uint32_t storage_id() const {
    return GetField<uint32_t>(VT_STORAGE_ID, 0);
  }
  uint32_t disk_id() const {
    return GetField<uint32_t>(VT_DISK_ID, 0);
  }
  uint64_t request_id() const {
    return GetField<uint64_t>(VT_REQUEST_ID, 0);
  }
  int64_t checksum() const {
    return GetField<int64_t>(VT_CHECKSUM, 0);
  }
  uint64_t left_replica_size() const {
    return GetField<uint64_t>(VT_LEFT_REPLICA_SIZE, 0);
  }
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHUNK_STATUS, 4) &&
           VerifyField<uint32_t>(verifier, VT_HINT, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACK_LENGTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_TRACE_TYPE, 4) &&
           VerifyOffset(verifier, VT_TRACE_DATA) &&
           verifier.VerifyString(trace_data()) &&
           VerifyField<int64_t>(verifier, VT_HANDLE, 8) &&
           VerifyField<uint32_t>(verifier, VT_STORAGE_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_DISK_ID, 4) &&
           VerifyField<uint64_t>(verifier, VT_REQUEST_ID, 8) &&
           VerifyField<int64_t>(verifier, VT_CHECKSUM, 8) &&
           VerifyField<uint64_t>(verifier, VT_LEFT_REPLICA_SIZE, 8) &&
           VerifyField<int32_t>(verifier, VT_A, 4) &&
           verifier.EndTable();
  }
  FlatLogFileFlushChunkResponseFBT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlatLogFileFlushChunkResponseFBT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlatLogFileFlushChunkResponseFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlatLogFileFlushChunkResponseFBBuilder {
  typedef FlatLogFileFlushChunkResponseFB Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(int32_t errorcode) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkResponseFB::VT_ERRORCODE, errorcode, 0);
  }
  void add_chunk_status(uint32_t chunk_status) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_CHUNK_STATUS, chunk_status, 0);
  }
  void add_hint(uint32_t hint) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_HINT, hint, 0);
  }
  void add_ack_length(uint32_t ack_length) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_ACK_LENGTH, ack_length, 0);
  }
  void add_trace_type(uint32_t trace_type) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_TRACE_TYPE, trace_type, 0);
  }
  void add_trace_data(::flatbuffers::Offset<::flatbuffers::String> trace_data) {
    fbb_.AddOffset(FlatLogFileFlushChunkResponseFB::VT_TRACE_DATA, trace_data);
  }
  void add_handle(int64_t handle) {
    fbb_.AddElement<int64_t>(FlatLogFileFlushChunkResponseFB::VT_HANDLE, handle, 0);
  }
  void add_storage_id(uint32_t storage_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_STORAGE_ID, storage_id, 0);
  }
  void add_disk_id(uint32_t disk_id) {
    fbb_.AddElement<uint32_t>(FlatLogFileFlushChunkResponseFB::VT_DISK_ID, disk_id, 0);
  }
  void add_request_id(uint64_t request_id) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkResponseFB::VT_REQUEST_ID, request_id, 0);
  }
  void add_checksum(int64_t checksum) {
    fbb_.AddElement<int64_t>(FlatLogFileFlushChunkResponseFB::VT_CHECKSUM, checksum, 0);
  }
  void add_left_replica_size(uint64_t left_replica_size) {
    fbb_.AddElement<uint64_t>(FlatLogFileFlushChunkResponseFB::VT_LEFT_REPLICA_SIZE, left_replica_size, 0);
  }
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(FlatLogFileFlushChunkResponseFB::VT_A, a, 0);
  }
  explicit FlatLogFileFlushChunkResponseFBBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> CreateFlatLogFileFlushChunkResponseFB(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    uint32_t chunk_status = 0,
    uint32_t hint = 0,
    uint32_t ack_length = 0,
    uint32_t trace_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trace_data = 0,
    int64_t handle = 0,
    uint32_t storage_id = 0,
    uint32_t disk_id = 0,
    uint64_t request_id = 0,
    int64_t checksum = 0,
    uint64_t left_replica_size = 0,
    int32_t a = 0) {
  FlatLogFileFlushChunkResponseFBBuilder builder_(_fbb);
  builder_.add_left_replica_size(left_replica_size);
  builder_.add_checksum(checksum);
  builder_.add_request_id(request_id);
  builder_.add_handle(handle);
  builder_.add_a(a);
  builder_.add_disk_id(disk_id);
  builder_.add_storage_id(storage_id);
  builder_.add_trace_data(trace_data);
  builder_.add_trace_type(trace_type);
  builder_.add_ack_length(ack_length);
  builder_.add_hint(hint);
  builder_.add_chunk_status(chunk_status);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> CreateFlatLogFileFlushChunkResponseFBDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t errorcode = 0,
    uint32_t chunk_status = 0,
    uint32_t hint = 0,
    uint32_t ack_length = 0,
    uint32_t trace_type = 0,
    const char *trace_data = nullptr,
    int64_t handle = 0,
    uint32_t storage_id = 0,
    uint32_t disk_id = 0,
    uint64_t request_id = 0,
    int64_t checksum = 0,
    uint64_t left_replica_size = 0,
    int32_t a = 0) {
  auto trace_data__ = trace_data ? _fbb.CreateString(trace_data) : 0;
  return CreateFlatLogFileFlushChunkResponseFB(
      _fbb,
      errorcode,
      chunk_status,
      hint,
      ack_length,
      trace_type,
      trace_data__,
      handle,
      storage_id,
      disk_id,
      request_id,
      checksum,
      left_replica_size,
      a);
}

::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> CreateFlatLogFileFlushChunkResponseFB(::flatbuffers::FlatBufferBuilder &_fbb, const FlatLogFileFlushChunkResponseFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const FixedUUIDInfoFBT &lhs, const FixedUUIDInfoFBT &rhs) {
  return
      (lhs.low == rhs.low) &&
      (lhs.high == rhs.high);
}

inline bool operator!=(const FixedUUIDInfoFBT &lhs, const FixedUUIDInfoFBT &rhs) {
    return !(lhs == rhs);
}


inline FixedUUIDInfoFBT *FixedUUIDInfoFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FixedUUIDInfoFBT>(new FixedUUIDInfoFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FixedUUIDInfoFB::UnPackTo(FixedUUIDInfoFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = low(); _o->low = _e; }
  { auto _e = high(); _o->high = _e; }
}

inline ::flatbuffers::Offset<FixedUUIDInfoFB> FixedUUIDInfoFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FixedUUIDInfoFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFixedUUIDInfoFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FixedUUIDInfoFB> CreateFixedUUIDInfoFB(::flatbuffers::FlatBufferBuilder &_fbb, const FixedUUIDInfoFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FixedUUIDInfoFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _low = _o->low;
  auto _high = _o->high;
  return CreateFixedUUIDInfoFB(
      _fbb,
      _low,
      _high);
}


inline bool operator==(const MirrorArgsFBT &lhs, const MirrorArgsFBT &rhs) {
  return
      (lhs.copy == rhs.copy) &&
      (lhs.ftt == rhs.ftt);
}

inline bool operator!=(const MirrorArgsFBT &lhs, const MirrorArgsFBT &rhs) {
    return !(lhs == rhs);
}


inline MirrorArgsFBT *MirrorArgsFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MirrorArgsFBT>(new MirrorArgsFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MirrorArgsFB::UnPackTo(MirrorArgsFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = copy(); _o->copy = _e; }
  { auto _e = ftt(); _o->ftt = _e; }
}

inline ::flatbuffers::Offset<MirrorArgsFB> MirrorArgsFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorArgsFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMirrorArgsFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MirrorArgsFB> CreateMirrorArgsFB(::flatbuffers::FlatBufferBuilder &_fbb, const MirrorArgsFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MirrorArgsFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _copy = _o->copy;
  auto _ftt = _o->ftt;
  return CreateMirrorArgsFB(
      _fbb,
      _copy,
      _ftt);
}


inline bool operator==(const ChunkOptionsFBT &lhs, const ChunkOptionsFBT &rhs) {
  return
      (lhs.ftt_type == rhs.ftt_type) &&
      ((lhs.mirror == rhs.mirror) || (lhs.mirror && rhs.mirror && *lhs.mirror == *rhs.mirror)) &&
      (lhs.placement == rhs.placement);
}

inline bool operator!=(const ChunkOptionsFBT &lhs, const ChunkOptionsFBT &rhs) {
    return !(lhs == rhs);
}


inline ChunkOptionsFBT::ChunkOptionsFBT(const ChunkOptionsFBT &o)
      : ftt_type(o.ftt_type),
        mirror((o.mirror) ? new MirrorArgsFBT(*o.mirror) : nullptr),
        placement(o.placement) {
}

inline ChunkOptionsFBT &ChunkOptionsFBT::operator=(ChunkOptionsFBT o) FLATBUFFERS_NOEXCEPT {
  std::swap(ftt_type, o.ftt_type);
  std::swap(mirror, o.mirror);
  std::swap(placement, o.placement);
  return *this;
}

inline ChunkOptionsFBT *ChunkOptionsFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ChunkOptionsFBT>(new ChunkOptionsFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChunkOptionsFB::UnPackTo(ChunkOptionsFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ftt_type(); _o->ftt_type = _e; }
  { auto _e = mirror(); if (_e) { if(_o->mirror) { _e->UnPackTo(_o->mirror.get(), _resolver); } else { _o->mirror = std::unique_ptr<MirrorArgsFBT>(_e->UnPack(_resolver)); } } else if (_o->mirror) { _o->mirror.reset(); } }
  { auto _e = placement(); if (_e) _o->placement = _e->str(); }
}

inline ::flatbuffers::Offset<ChunkOptionsFB> ChunkOptionsFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkOptionsFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChunkOptionsFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ChunkOptionsFB> CreateChunkOptionsFB(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkOptionsFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ChunkOptionsFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ftt_type = _o->ftt_type;
  auto _mirror = _o->mirror ? CreateMirrorArgsFB(_fbb, _o->mirror.get(), _rehasher) : 0;
  auto _placement = _o->placement.empty() ? 0 : _fbb.CreateString(_o->placement);
  return CreateChunkOptionsFB(
      _fbb,
      _ftt_type,
      _mirror,
      _placement);
}


inline bool operator==(const ReplicaLocationFBT &lhs, const ReplicaLocationFBT &rhs) {
  return
      (lhs.cs_location == rhs.cs_location) &&
      (lhs.disk_location == rhs.disk_location) &&
      (lhs.disk_type == rhs.disk_type);
}

inline bool operator!=(const ReplicaLocationFBT &lhs, const ReplicaLocationFBT &rhs) {
    return !(lhs == rhs);
}


inline ReplicaLocationFBT *ReplicaLocationFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReplicaLocationFBT>(new ReplicaLocationFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReplicaLocationFB::UnPackTo(ReplicaLocationFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cs_location(); if (_e) _o->cs_location = _e->str(); }
  { auto _e = disk_location(); _o->disk_location = _e; }
  { auto _e = disk_type(); _o->disk_type = _e; }
}

inline ::flatbuffers::Offset<ReplicaLocationFB> ReplicaLocationFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReplicaLocationFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReplicaLocationFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReplicaLocationFB> CreateReplicaLocationFB(::flatbuffers::FlatBufferBuilder &_fbb, const ReplicaLocationFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReplicaLocationFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cs_location = _o->cs_location.empty() ? 0 : _fbb.CreateString(_o->cs_location);
  auto _disk_location = _o->disk_location;
  auto _disk_type = _o->disk_type;
  return CreateReplicaLocationFB(
      _fbb,
      _cs_location,
      _disk_location,
      _disk_type);
}


inline bool operator==(const AccelerateOpenOptionsFBT &lhs, const AccelerateOpenOptionsFBT &rhs) {
  return
      ((lhs.chunk_options == rhs.chunk_options) || (lhs.chunk_options && rhs.chunk_options && *lhs.chunk_options == *rhs.chunk_options)) &&
      (lhs.chunk_location.size() == rhs.chunk_location.size() && std::equal(lhs.chunk_location.cbegin(), lhs.chunk_location.cend(), rhs.chunk_location.cbegin(), [](std::unique_ptr<ReplicaLocationFBT> const &a, std::unique_ptr<ReplicaLocationFBT> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.chunk_sizeexponent == rhs.chunk_sizeexponent) &&
      (lhs.check_sumcategory == rhs.check_sumcategory);
}

inline bool operator!=(const AccelerateOpenOptionsFBT &lhs, const AccelerateOpenOptionsFBT &rhs) {
    return !(lhs == rhs);
}


inline AccelerateOpenOptionsFBT::AccelerateOpenOptionsFBT(const AccelerateOpenOptionsFBT &o)
      : chunk_options((o.chunk_options) ? new ChunkOptionsFBT(*o.chunk_options) : nullptr),
        chunk_sizeexponent(o.chunk_sizeexponent),
        check_sumcategory(o.check_sumcategory) {
  chunk_location.reserve(o.chunk_location.size());
  for (const auto &chunk_location_ : o.chunk_location) { chunk_location.emplace_back((chunk_location_) ? new ReplicaLocationFBT(*chunk_location_) : nullptr); }
}

inline AccelerateOpenOptionsFBT &AccelerateOpenOptionsFBT::operator=(AccelerateOpenOptionsFBT o) FLATBUFFERS_NOEXCEPT {
  std::swap(chunk_options, o.chunk_options);
  std::swap(chunk_location, o.chunk_location);
  std::swap(chunk_sizeexponent, o.chunk_sizeexponent);
  std::swap(check_sumcategory, o.check_sumcategory);
  return *this;
}

inline AccelerateOpenOptionsFBT *AccelerateOpenOptionsFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AccelerateOpenOptionsFBT>(new AccelerateOpenOptionsFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AccelerateOpenOptionsFB::UnPackTo(AccelerateOpenOptionsFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chunk_options(); if (_e) { if(_o->chunk_options) { _e->UnPackTo(_o->chunk_options.get(), _resolver); } else { _o->chunk_options = std::unique_ptr<ChunkOptionsFBT>(_e->UnPack(_resolver)); } } else if (_o->chunk_options) { _o->chunk_options.reset(); } }
  { auto _e = chunk_location(); if (_e) { _o->chunk_location.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->chunk_location[_i]) { _e->Get(_i)->UnPackTo(_o->chunk_location[_i].get(), _resolver); } else { _o->chunk_location[_i] = std::unique_ptr<ReplicaLocationFBT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->chunk_location.resize(0); } }
  { auto _e = chunk_sizeexponent(); _o->chunk_sizeexponent = _e; }
  { auto _e = check_sumcategory(); _o->check_sumcategory = _e; }
}

inline ::flatbuffers::Offset<AccelerateOpenOptionsFB> AccelerateOpenOptionsFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelerateOpenOptionsFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAccelerateOpenOptionsFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AccelerateOpenOptionsFB> CreateAccelerateOpenOptionsFB(::flatbuffers::FlatBufferBuilder &_fbb, const AccelerateOpenOptionsFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AccelerateOpenOptionsFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chunk_options = _o->chunk_options ? CreateChunkOptionsFB(_fbb, _o->chunk_options.get(), _rehasher) : 0;
  auto _chunk_location = _o->chunk_location.size() ? _fbb.CreateVector<::flatbuffers::Offset<ReplicaLocationFB>> (_o->chunk_location.size(), [](size_t i, _VectorArgs *__va) { return CreateReplicaLocationFB(*__va->__fbb, __va->__o->chunk_location[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _chunk_sizeexponent = _o->chunk_sizeexponent;
  auto _check_sumcategory = _o->check_sumcategory;
  return CreateAccelerateOpenOptionsFB(
      _fbb,
      _chunk_options,
      _chunk_location,
      _chunk_sizeexponent,
      _check_sumcategory);
}


inline bool operator==(const IONiceFBT &lhs, const IONiceFBT &rhs) {
  return
      (lhs.priority == rhs.priority) &&
      (lhs.io_class == rhs.io_class);
}

inline bool operator!=(const IONiceFBT &lhs, const IONiceFBT &rhs) {
    return !(lhs == rhs);
}


inline IONiceFBT *IONiceFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IONiceFBT>(new IONiceFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IONiceFB::UnPackTo(IONiceFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = priority(); _o->priority = _e; }
  { auto _e = io_class(); _o->io_class = _e; }
}

inline ::flatbuffers::Offset<IONiceFB> IONiceFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IONiceFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIONiceFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IONiceFB> CreateIONiceFB(::flatbuffers::FlatBufferBuilder &_fbb, const IONiceFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IONiceFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _priority = _o->priority;
  auto _io_class = _o->io_class;
  return CreateIONiceFB(
      _fbb,
      _priority,
      _io_class);
}


inline bool operator==(const CsChooseDiskStrategyCJFBT &lhs, const CsChooseDiskStrategyCJFBT &rhs) {
  return
      (lhs.strategies.size() == rhs.strategies.size() && std::equal(lhs.strategies.cbegin(), lhs.strategies.cend(), rhs.strategies.cbegin(), [](std::unique_ptr<CsChooseDiskStrategySingleCJFBT> const &a, std::unique_ptr<CsChooseDiskStrategySingleCJFBT> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.disk_storage_type == rhs.disk_storage_type) &&
      (lhs.target_storage_type == rhs.target_storage_type);
}

inline bool operator!=(const CsChooseDiskStrategyCJFBT &lhs, const CsChooseDiskStrategyCJFBT &rhs) {
    return !(lhs == rhs);
}


inline CsChooseDiskStrategyCJFBT::CsChooseDiskStrategyCJFBT(const CsChooseDiskStrategyCJFBT &o)
      : disk_storage_type(o.disk_storage_type),
        target_storage_type(o.target_storage_type) {
  strategies.reserve(o.strategies.size());
  for (const auto &strategies_ : o.strategies) { strategies.emplace_back((strategies_) ? new CsChooseDiskStrategySingleCJFBT(*strategies_) : nullptr); }
}

inline CsChooseDiskStrategyCJFBT &CsChooseDiskStrategyCJFBT::operator=(CsChooseDiskStrategyCJFBT o) FLATBUFFERS_NOEXCEPT {
  std::swap(strategies, o.strategies);
  std::swap(disk_storage_type, o.disk_storage_type);
  std::swap(target_storage_type, o.target_storage_type);
  return *this;
}

inline CsChooseDiskStrategyCJFBT *CsChooseDiskStrategyCJFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CsChooseDiskStrategyCJFBT>(new CsChooseDiskStrategyCJFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CsChooseDiskStrategyCJFB::UnPackTo(CsChooseDiskStrategyCJFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = strategies(); if (_e) { _o->strategies.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->strategies[_i]) { _e->Get(_i)->UnPackTo(_o->strategies[_i].get(), _resolver); } else { _o->strategies[_i] = std::unique_ptr<CsChooseDiskStrategySingleCJFBT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->strategies.resize(0); } }
  { auto _e = disk_storage_type(); _o->disk_storage_type = _e; }
  { auto _e = target_storage_type(); _o->target_storage_type = _e; }
}

inline ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> CsChooseDiskStrategyCJFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CsChooseDiskStrategyCJFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCsChooseDiskStrategyCJFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CsChooseDiskStrategyCJFB> CreateCsChooseDiskStrategyCJFB(::flatbuffers::FlatBufferBuilder &_fbb, const CsChooseDiskStrategyCJFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CsChooseDiskStrategyCJFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _strategies = _o->strategies.size() ? _fbb.CreateVector<::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB>> (_o->strategies.size(), [](size_t i, _VectorArgs *__va) { return CreateCsChooseDiskStrategySingleCJFB(*__va->__fbb, __va->__o->strategies[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _disk_storage_type = _o->disk_storage_type;
  auto _target_storage_type = _o->target_storage_type;
  return CreateCsChooseDiskStrategyCJFB(
      _fbb,
      _strategies,
      _disk_storage_type,
      _target_storage_type);
}


inline bool operator==(const ChunkOrStreamIdInfoFBT &lhs, const ChunkOrStreamIdInfoFBT &rhs) {
  return
      ((lhs.uuid == rhs.uuid) || (lhs.uuid && rhs.uuid && *lhs.uuid == *rhs.uuid)) &&
      (lhs.partition_index == rhs.partition_index) &&
      (lhs.padding == rhs.padding);
}

inline bool operator!=(const ChunkOrStreamIdInfoFBT &lhs, const ChunkOrStreamIdInfoFBT &rhs) {
    return !(lhs == rhs);
}


inline ChunkOrStreamIdInfoFBT::ChunkOrStreamIdInfoFBT(const ChunkOrStreamIdInfoFBT &o)
      : uuid((o.uuid) ? new UUIDInfoFBT(*o.uuid) : nullptr),
        partition_index(o.partition_index),
        padding(o.padding) {
}

inline ChunkOrStreamIdInfoFBT &ChunkOrStreamIdInfoFBT::operator=(ChunkOrStreamIdInfoFBT o) FLATBUFFERS_NOEXCEPT {
  std::swap(uuid, o.uuid);
  std::swap(partition_index, o.partition_index);
  std::swap(padding, o.padding);
  return *this;
}

inline ChunkOrStreamIdInfoFBT *ChunkOrStreamIdInfoFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ChunkOrStreamIdInfoFBT>(new ChunkOrStreamIdInfoFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChunkOrStreamIdInfoFB::UnPackTo(ChunkOrStreamIdInfoFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) { if(_o->uuid) { _e->UnPackTo(_o->uuid.get(), _resolver); } else { _o->uuid = std::unique_ptr<UUIDInfoFBT>(_e->UnPack(_resolver)); } } else if (_o->uuid) { _o->uuid.reset(); } }
  { auto _e = partition_index(); _o->partition_index = _e; }
  { auto _e = padding(); _o->padding = _e; }
}

inline ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> ChunkOrStreamIdInfoFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkOrStreamIdInfoFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChunkOrStreamIdInfoFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ChunkOrStreamIdInfoFB> CreateChunkOrStreamIdInfoFB(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkOrStreamIdInfoFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ChunkOrStreamIdInfoFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uuid = _o->uuid ? CreateUUIDInfoFB(_fbb, _o->uuid.get(), _rehasher) : 0;
  auto _partition_index = _o->partition_index;
  auto _padding = _o->padding;
  return CreateChunkOrStreamIdInfoFB(
      _fbb,
      _uuid,
      _partition_index,
      _padding);
}


inline bool operator==(const QosOptionsFBT &lhs, const QosOptionsFBT &rhs) {
  return
      (lhs.service_id == rhs.service_id) &&
      (lhs.flow_id == rhs.flow_id) &&
      (lhs.adjust == rhs.adjust) &&
      (lhs.cache_groupid == rhs.cache_groupid) &&
      (lhs.network_priority == rhs.network_priority);
}

inline bool operator!=(const QosOptionsFBT &lhs, const QosOptionsFBT &rhs) {
    return !(lhs == rhs);
}


inline QosOptionsFBT *QosOptionsFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QosOptionsFBT>(new QosOptionsFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QosOptionsFB::UnPackTo(QosOptionsFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = service_id(); _o->service_id = _e; }
  { auto _e = flow_id(); _o->flow_id = _e; }
  { auto _e = adjust(); _o->adjust = _e; }
  { auto _e = cache_groupid(); _o->cache_groupid = _e; }
  { auto _e = network_priority(); _o->network_priority = _e; }
}

inline ::flatbuffers::Offset<QosOptionsFB> QosOptionsFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QosOptionsFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQosOptionsFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<QosOptionsFB> CreateQosOptionsFB(::flatbuffers::FlatBufferBuilder &_fbb, const QosOptionsFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const QosOptionsFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _service_id = _o->service_id;
  auto _flow_id = _o->flow_id;
  auto _adjust = _o->adjust;
  auto _cache_groupid = _o->cache_groupid;
  auto _network_priority = _o->network_priority;
  return CreateQosOptionsFB(
      _fbb,
      _service_id,
      _flow_id,
      _adjust,
      _cache_groupid,
      _network_priority);
}


inline bool operator==(const FlushChecksumFBT &lhs, const FlushChecksumFBT &rhs) {
  return
      (lhs.category == rhs.category) &&
      (lhs.value == rhs.value);
}

inline bool operator!=(const FlushChecksumFBT &lhs, const FlushChecksumFBT &rhs) {
    return !(lhs == rhs);
}


inline FlushChecksumFBT *FlushChecksumFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlushChecksumFBT>(new FlushChecksumFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlushChecksumFB::UnPackTo(FlushChecksumFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = category(); _o->category = _e; }
  { auto _e = value(); _o->value = _e; }
}

inline ::flatbuffers::Offset<FlushChecksumFB> FlushChecksumFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlushChecksumFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlushChecksumFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlushChecksumFB> CreateFlushChecksumFB(::flatbuffers::FlatBufferBuilder &_fbb, const FlushChecksumFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlushChecksumFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _category = _o->category;
  auto _value = _o->value;
  return CreateFlushChecksumFB(
      _fbb,
      _category,
      _value);
}


inline bool operator==(const UUIDInfoFBT &lhs, const UUIDInfoFBT &rhs) {
  return
      (lhs.low == rhs.low) &&
      (lhs.high == rhs.high);
}

inline bool operator!=(const UUIDInfoFBT &lhs, const UUIDInfoFBT &rhs) {
    return !(lhs == rhs);
}


inline UUIDInfoFBT *UUIDInfoFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UUIDInfoFBT>(new UUIDInfoFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UUIDInfoFB::UnPackTo(UUIDInfoFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = low(); _o->low = _e; }
  { auto _e = high(); _o->high = _e; }
}

inline ::flatbuffers::Offset<UUIDInfoFB> UUIDInfoFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UUIDInfoFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUUIDInfoFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UUIDInfoFB> CreateUUIDInfoFB(::flatbuffers::FlatBufferBuilder &_fbb, const UUIDInfoFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UUIDInfoFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _low = _o->low;
  auto _high = _o->high;
  return CreateUUIDInfoFB(
      _fbb,
      _low,
      _high);
}


inline bool operator==(const RootServerIdFBT &lhs, const RootServerIdFBT &rhs) {
  return
      ((lhs.uuid == rhs.uuid) || (lhs.uuid && rhs.uuid && *lhs.uuid == *rhs.uuid)) &&
      (lhs.leader_term == rhs.leader_term);
}

inline bool operator!=(const RootServerIdFBT &lhs, const RootServerIdFBT &rhs) {
    return !(lhs == rhs);
}


inline RootServerIdFBT::RootServerIdFBT(const RootServerIdFBT &o)
      : uuid((o.uuid) ? new UUIDInfoFBT(*o.uuid) : nullptr),
        leader_term(o.leader_term) {
}

inline RootServerIdFBT &RootServerIdFBT::operator=(RootServerIdFBT o) FLATBUFFERS_NOEXCEPT {
  std::swap(uuid, o.uuid);
  std::swap(leader_term, o.leader_term);
  return *this;
}

inline RootServerIdFBT *RootServerIdFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RootServerIdFBT>(new RootServerIdFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RootServerIdFB::UnPackTo(RootServerIdFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) { if(_o->uuid) { _e->UnPackTo(_o->uuid.get(), _resolver); } else { _o->uuid = std::unique_ptr<UUIDInfoFBT>(_e->UnPack(_resolver)); } } else if (_o->uuid) { _o->uuid.reset(); } }
  { auto _e = leader_term(); _o->leader_term = _e; }
}

inline ::flatbuffers::Offset<RootServerIdFB> RootServerIdFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RootServerIdFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRootServerIdFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RootServerIdFB> CreateRootServerIdFB(::flatbuffers::FlatBufferBuilder &_fbb, const RootServerIdFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RootServerIdFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uuid = _o->uuid ? CreateUUIDInfoFB(_fbb, _o->uuid.get(), _rehasher) : 0;
  auto _leader_term = _o->leader_term;
  return CreateRootServerIdFB(
      _fbb,
      _uuid,
      _leader_term);
}


inline bool operator==(const ChunkIdTypeCJFBT &lhs, const ChunkIdTypeCJFBT &rhs) {
  return
      (lhs.belonged_fileid == rhs.belonged_fileid) &&
      (lhs.chunk_index == rhs.chunk_index) &&
      (lhs.padding == rhs.padding);
}

inline bool operator!=(const ChunkIdTypeCJFBT &lhs, const ChunkIdTypeCJFBT &rhs) {
    return !(lhs == rhs);
}


inline ChunkIdTypeCJFBT *ChunkIdTypeCJFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ChunkIdTypeCJFBT>(new ChunkIdTypeCJFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChunkIdTypeCJFB::UnPackTo(ChunkIdTypeCJFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = belonged_fileid(); _o->belonged_fileid = _e; }
  { auto _e = chunk_index(); _o->chunk_index = _e; }
  { auto _e = padding(); _o->padding = _e; }
}

inline ::flatbuffers::Offset<ChunkIdTypeCJFB> ChunkIdTypeCJFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkIdTypeCJFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChunkIdTypeCJFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ChunkIdTypeCJFB> CreateChunkIdTypeCJFB(::flatbuffers::FlatBufferBuilder &_fbb, const ChunkIdTypeCJFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ChunkIdTypeCJFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _belonged_fileid = _o->belonged_fileid;
  auto _chunk_index = _o->chunk_index;
  auto _padding = _o->padding;
  return CreateChunkIdTypeCJFB(
      _fbb,
      _belonged_fileid,
      _chunk_index,
      _padding);
}


inline bool operator==(const PanguTraceSpanInfoFBT &lhs, const PanguTraceSpanInfoFBT &rhs) {
  return
      (lhs.trace_id_low == rhs.trace_id_low) &&
      (lhs.trace_id_high == rhs.trace_id_high) &&
      (lhs.span_id == rhs.span_id);
}

inline bool operator!=(const PanguTraceSpanInfoFBT &lhs, const PanguTraceSpanInfoFBT &rhs) {
    return !(lhs == rhs);
}


inline PanguTraceSpanInfoFBT *PanguTraceSpanInfoFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PanguTraceSpanInfoFBT>(new PanguTraceSpanInfoFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PanguTraceSpanInfoFB::UnPackTo(PanguTraceSpanInfoFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = trace_id_low(); _o->trace_id_low = _e; }
  { auto _e = trace_id_high(); _o->trace_id_high = _e; }
  { auto _e = span_id(); _o->span_id = _e; }
}

inline ::flatbuffers::Offset<PanguTraceSpanInfoFB> PanguTraceSpanInfoFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PanguTraceSpanInfoFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePanguTraceSpanInfoFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PanguTraceSpanInfoFB> CreatePanguTraceSpanInfoFB(::flatbuffers::FlatBufferBuilder &_fbb, const PanguTraceSpanInfoFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PanguTraceSpanInfoFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _trace_id_low = _o->trace_id_low;
  auto _trace_id_high = _o->trace_id_high;
  auto _span_id = _o->span_id;
  return CreatePanguTraceSpanInfoFB(
      _fbb,
      _trace_id_low,
      _trace_id_high,
      _span_id);
}


inline bool operator==(const CsChooseDiskStrategySingleCJFBT &lhs, const CsChooseDiskStrategySingleCJFBT &rhs) {
  return
      (lhs.method == rhs.method) &&
      (lhs.weight == rhs.weight) &&
      (lhs.parameter == rhs.parameter);
}

inline bool operator!=(const CsChooseDiskStrategySingleCJFBT &lhs, const CsChooseDiskStrategySingleCJFBT &rhs) {
    return !(lhs == rhs);
}


inline CsChooseDiskStrategySingleCJFBT *CsChooseDiskStrategySingleCJFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CsChooseDiskStrategySingleCJFBT>(new CsChooseDiskStrategySingleCJFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CsChooseDiskStrategySingleCJFB::UnPackTo(CsChooseDiskStrategySingleCJFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = method(); _o->method = _e; }
  { auto _e = weight(); _o->weight = _e; }
  { auto _e = parameter(); _o->parameter = _e; }
}

inline ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB> CsChooseDiskStrategySingleCJFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CsChooseDiskStrategySingleCJFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCsChooseDiskStrategySingleCJFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CsChooseDiskStrategySingleCJFB> CreateCsChooseDiskStrategySingleCJFB(::flatbuffers::FlatBufferBuilder &_fbb, const CsChooseDiskStrategySingleCJFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CsChooseDiskStrategySingleCJFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _method = _o->method;
  auto _weight = _o->weight;
  auto _parameter = _o->parameter;
  return CreateCsChooseDiskStrategySingleCJFB(
      _fbb,
      _method,
      _weight,
      _parameter);
}


inline bool operator==(const FlatLogFileFlushChunkRequestFBT &lhs, const FlatLogFileFlushChunkRequestFBT &rhs) {
  return
      ((lhs.chunk_id == rhs.chunk_id) || (lhs.chunk_id && rhs.chunk_id && *lhs.chunk_id == *rhs.chunk_id)) &&
      (lhs.offset == rhs.offset) &&
      (lhs.length == rhs.length) &&
      (lhs.storage_id == rhs.storage_id) &&
      (lhs.data == rhs.data) &&
      (lhs.hint == rhs.hint) &&
      (lhs.is_replication == rhs.is_replication) &&
      (lhs.trace_open == rhs.trace_open) &&
      ((lhs.io_nice == rhs.io_nice) || (lhs.io_nice && rhs.io_nice && *lhs.io_nice == *rhs.io_nice)) &&
      ((lhs.open_chunkoptions == rhs.open_chunkoptions) || (lhs.open_chunkoptions && rhs.open_chunkoptions && *lhs.open_chunkoptions == *rhs.open_chunkoptions)) &&
      (lhs.open_mode == rhs.open_mode) &&
      (lhs.handle == rhs.handle) &&
      (lhs.data_sync == rhs.data_sync) &&
      ((lhs.trace_span == rhs.trace_span) || (lhs.trace_span && rhs.trace_span && *lhs.trace_span == *rhs.trace_span)) &&
      (lhs.create_ifnotexists == rhs.create_ifnotexists) &&
      ((lhs.strategy == rhs.strategy) || (lhs.strategy && rhs.strategy && *lhs.strategy == *rhs.strategy)) &&
      ((lhs.chunk_id_v2 == rhs.chunk_id_v2) || (lhs.chunk_id_v2 && rhs.chunk_id_v2 && *lhs.chunk_id_v2 == *rhs.chunk_id_v2)) &&
      ((lhs.qos_options == rhs.qos_options) || (lhs.qos_options && rhs.qos_options && *lhs.qos_options == *rhs.qos_options)) &&
      ((lhs.checksum == rhs.checksum) || (lhs.checksum && rhs.checksum && *lhs.checksum == *rhs.checksum)) &&
      ((lhs.volume_uuid == rhs.volume_uuid) || (lhs.volume_uuid && rhs.volume_uuid && *lhs.volume_uuid == *rhs.volume_uuid)) &&
      (lhs.module_version == rhs.module_version) &&
      (lhs.hostname == rhs.hostname) &&
      (lhs.disk_id == rhs.disk_id) &&
      (lhs.request_id == rhs.request_id) &&
      (lhs.user_id == rhs.user_id) &&
      ((lhs.root_server_id == rhs.root_server_id) || (lhs.root_server_id && rhs.root_server_id && *lhs.root_server_id == *rhs.root_server_id)) &&
      (lhs.required_min_csversion == rhs.required_min_csversion) &&
      (lhs.fromtype == rhs.fromtype) &&
      (lhs.offset64 == rhs.offset64) &&
      (lhs.record_size == rhs.record_size) &&
      (lhs.pool_id == rhs.pool_id) &&
      (lhs.storage_pool_confversion == rhs.storage_pool_confversion) &&
      (lhs.a == rhs.a);
}

inline bool operator!=(const FlatLogFileFlushChunkRequestFBT &lhs, const FlatLogFileFlushChunkRequestFBT &rhs) {
    return !(lhs == rhs);
}


inline FlatLogFileFlushChunkRequestFBT::FlatLogFileFlushChunkRequestFBT(const FlatLogFileFlushChunkRequestFBT &o)
      : chunk_id((o.chunk_id) ? new ChunkIdTypeCJFBT(*o.chunk_id) : nullptr),
        offset(o.offset),
        length(o.length),
        storage_id(o.storage_id),
        data(o.data),
        hint(o.hint),
        is_replication(o.is_replication),
        trace_open(o.trace_open),
        io_nice((o.io_nice) ? new IONiceFBT(*o.io_nice) : nullptr),
        open_chunkoptions((o.open_chunkoptions) ? new AccelerateOpenOptionsFBT(*o.open_chunkoptions) : nullptr),
        open_mode(o.open_mode),
        handle(o.handle),
        data_sync(o.data_sync),
        trace_span((o.trace_span) ? new PanguTraceSpanInfoFBT(*o.trace_span) : nullptr),
        create_ifnotexists(o.create_ifnotexists),
        strategy((o.strategy) ? new CsChooseDiskStrategyCJFBT(*o.strategy) : nullptr),
        chunk_id_v2((o.chunk_id_v2) ? new ChunkOrStreamIdInfoFBT(*o.chunk_id_v2) : nullptr),
        qos_options((o.qos_options) ? new QosOptionsFBT(*o.qos_options) : nullptr),
        checksum((o.checksum) ? new FlushChecksumFBT(*o.checksum) : nullptr),
        volume_uuid((o.volume_uuid) ? new UUIDInfoFBT(*o.volume_uuid) : nullptr),
        module_version(o.module_version),
        hostname(o.hostname),
        disk_id(o.disk_id),
        request_id(o.request_id),
        user_id(o.user_id),
        root_server_id((o.root_server_id) ? new RootServerIdFBT(*o.root_server_id) : nullptr),
        required_min_csversion(o.required_min_csversion),
        fromtype(o.fromtype),
        offset64(o.offset64),
        record_size(o.record_size),
        pool_id(o.pool_id),
        storage_pool_confversion(o.storage_pool_confversion),
        a(o.a) {
}

inline FlatLogFileFlushChunkRequestFBT &FlatLogFileFlushChunkRequestFBT::operator=(FlatLogFileFlushChunkRequestFBT o) FLATBUFFERS_NOEXCEPT {
  std::swap(chunk_id, o.chunk_id);
  std::swap(offset, o.offset);
  std::swap(length, o.length);
  std::swap(storage_id, o.storage_id);
  std::swap(data, o.data);
  std::swap(hint, o.hint);
  std::swap(is_replication, o.is_replication);
  std::swap(trace_open, o.trace_open);
  std::swap(io_nice, o.io_nice);
  std::swap(open_chunkoptions, o.open_chunkoptions);
  std::swap(open_mode, o.open_mode);
  std::swap(handle, o.handle);
  std::swap(data_sync, o.data_sync);
  std::swap(trace_span, o.trace_span);
  std::swap(create_ifnotexists, o.create_ifnotexists);
  std::swap(strategy, o.strategy);
  std::swap(chunk_id_v2, o.chunk_id_v2);
  std::swap(qos_options, o.qos_options);
  std::swap(checksum, o.checksum);
  std::swap(volume_uuid, o.volume_uuid);
  std::swap(module_version, o.module_version);
  std::swap(hostname, o.hostname);
  std::swap(disk_id, o.disk_id);
  std::swap(request_id, o.request_id);
  std::swap(user_id, o.user_id);
  std::swap(root_server_id, o.root_server_id);
  std::swap(required_min_csversion, o.required_min_csversion);
  std::swap(fromtype, o.fromtype);
  std::swap(offset64, o.offset64);
  std::swap(record_size, o.record_size);
  std::swap(pool_id, o.pool_id);
  std::swap(storage_pool_confversion, o.storage_pool_confversion);
  std::swap(a, o.a);
  return *this;
}

inline FlatLogFileFlushChunkRequestFBT *FlatLogFileFlushChunkRequestFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlatLogFileFlushChunkRequestFBT>(new FlatLogFileFlushChunkRequestFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlatLogFileFlushChunkRequestFB::UnPackTo(FlatLogFileFlushChunkRequestFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chunk_id(); if (_e) { if(_o->chunk_id) { _e->UnPackTo(_o->chunk_id.get(), _resolver); } else { _o->chunk_id = std::unique_ptr<ChunkIdTypeCJFBT>(_e->UnPack(_resolver)); } } else if (_o->chunk_id) { _o->chunk_id.reset(); } }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = length(); _o->length = _e; }
  { auto _e = storage_id(); _o->storage_id = _e; }
  { auto _e = data(); if (_e) _o->data = _e->str(); }
  { auto _e = hint(); _o->hint = _e; }
  { auto _e = is_replication(); _o->is_replication = _e; }
  { auto _e = trace_open(); _o->trace_open = _e; }
  { auto _e = io_nice(); if (_e) { if(_o->io_nice) { _e->UnPackTo(_o->io_nice.get(), _resolver); } else { _o->io_nice = std::unique_ptr<IONiceFBT>(_e->UnPack(_resolver)); } } else if (_o->io_nice) { _o->io_nice.reset(); } }
  { auto _e = open_chunkoptions(); if (_e) { if(_o->open_chunkoptions) { _e->UnPackTo(_o->open_chunkoptions.get(), _resolver); } else { _o->open_chunkoptions = std::unique_ptr<AccelerateOpenOptionsFBT>(_e->UnPack(_resolver)); } } else if (_o->open_chunkoptions) { _o->open_chunkoptions.reset(); } }
  { auto _e = open_mode(); _o->open_mode = _e; }
  { auto _e = handle(); _o->handle = _e; }
  { auto _e = data_sync(); _o->data_sync = _e; }
  { auto _e = trace_span(); if (_e) { if(_o->trace_span) { _e->UnPackTo(_o->trace_span.get(), _resolver); } else { _o->trace_span = std::unique_ptr<PanguTraceSpanInfoFBT>(_e->UnPack(_resolver)); } } else if (_o->trace_span) { _o->trace_span.reset(); } }
  { auto _e = create_ifnotexists(); _o->create_ifnotexists = _e; }
  { auto _e = strategy(); if (_e) { if(_o->strategy) { _e->UnPackTo(_o->strategy.get(), _resolver); } else { _o->strategy = std::unique_ptr<CsChooseDiskStrategyCJFBT>(_e->UnPack(_resolver)); } } else if (_o->strategy) { _o->strategy.reset(); } }
  { auto _e = chunk_id_v2(); if (_e) { if(_o->chunk_id_v2) { _e->UnPackTo(_o->chunk_id_v2.get(), _resolver); } else { _o->chunk_id_v2 = std::unique_ptr<ChunkOrStreamIdInfoFBT>(_e->UnPack(_resolver)); } } else if (_o->chunk_id_v2) { _o->chunk_id_v2.reset(); } }
  { auto _e = qos_options(); if (_e) { if(_o->qos_options) { _e->UnPackTo(_o->qos_options.get(), _resolver); } else { _o->qos_options = std::unique_ptr<QosOptionsFBT>(_e->UnPack(_resolver)); } } else if (_o->qos_options) { _o->qos_options.reset(); } }
  { auto _e = checksum(); if (_e) { if(_o->checksum) { _e->UnPackTo(_o->checksum.get(), _resolver); } else { _o->checksum = std::unique_ptr<FlushChecksumFBT>(_e->UnPack(_resolver)); } } else if (_o->checksum) { _o->checksum.reset(); } }
  { auto _e = volume_uuid(); if (_e) { if(_o->volume_uuid) { _e->UnPackTo(_o->volume_uuid.get(), _resolver); } else { _o->volume_uuid = std::unique_ptr<UUIDInfoFBT>(_e->UnPack(_resolver)); } } else if (_o->volume_uuid) { _o->volume_uuid.reset(); } }
  { auto _e = module_version(); _o->module_version = _e; }
  { auto _e = hostname(); if (_e) _o->hostname = _e->str(); }
  { auto _e = disk_id(); _o->disk_id = _e; }
  { auto _e = request_id(); _o->request_id = _e; }
  { auto _e = user_id(); if (_e) _o->user_id = _e->str(); }
  { auto _e = root_server_id(); if (_e) { if(_o->root_server_id) { _e->UnPackTo(_o->root_server_id.get(), _resolver); } else { _o->root_server_id = std::unique_ptr<RootServerIdFBT>(_e->UnPack(_resolver)); } } else if (_o->root_server_id) { _o->root_server_id.reset(); } }
  { auto _e = required_min_csversion(); _o->required_min_csversion = _e; }
  { auto _e = fromtype(); _o->fromtype = _e; }
  { auto _e = offset64(); _o->offset64 = _e; }
  { auto _e = record_size(); _o->record_size = _e; }
  { auto _e = pool_id(); _o->pool_id = _e; }
  { auto _e = storage_pool_confversion(); _o->storage_pool_confversion = _e; }
  { auto _e = a(); _o->a = _e; }
}

inline ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> FlatLogFileFlushChunkRequestFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlatLogFileFlushChunkRequestFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlatLogFileFlushChunkRequestFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlatLogFileFlushChunkRequestFB> CreateFlatLogFileFlushChunkRequestFB(::flatbuffers::FlatBufferBuilder &_fbb, const FlatLogFileFlushChunkRequestFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlatLogFileFlushChunkRequestFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chunk_id = _o->chunk_id ? CreateChunkIdTypeCJFB(_fbb, _o->chunk_id.get(), _rehasher) : 0;
  auto _offset = _o->offset;
  auto _length = _o->length;
  auto _storage_id = _o->storage_id;
  auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
  auto _hint = _o->hint;
  auto _is_replication = _o->is_replication;
  auto _trace_open = _o->trace_open;
  auto _io_nice = _o->io_nice ? CreateIONiceFB(_fbb, _o->io_nice.get(), _rehasher) : 0;
  auto _open_chunkoptions = _o->open_chunkoptions ? CreateAccelerateOpenOptionsFB(_fbb, _o->open_chunkoptions.get(), _rehasher) : 0;
  auto _open_mode = _o->open_mode;
  auto _handle = _o->handle;
  auto _data_sync = _o->data_sync;
  auto _trace_span = _o->trace_span ? CreatePanguTraceSpanInfoFB(_fbb, _o->trace_span.get(), _rehasher) : 0;
  auto _create_ifnotexists = _o->create_ifnotexists;
  auto _strategy = _o->strategy ? CreateCsChooseDiskStrategyCJFB(_fbb, _o->strategy.get(), _rehasher) : 0;
  auto _chunk_id_v2 = _o->chunk_id_v2 ? CreateChunkOrStreamIdInfoFB(_fbb, _o->chunk_id_v2.get(), _rehasher) : 0;
  auto _qos_options = _o->qos_options ? CreateQosOptionsFB(_fbb, _o->qos_options.get(), _rehasher) : 0;
  auto _checksum = _o->checksum ? CreateFlushChecksumFB(_fbb, _o->checksum.get(), _rehasher) : 0;
  auto _volume_uuid = _o->volume_uuid ? CreateUUIDInfoFB(_fbb, _o->volume_uuid.get(), _rehasher) : 0;
  auto _module_version = _o->module_version;
  auto _hostname = _o->hostname.empty() ? 0 : _fbb.CreateString(_o->hostname);
  auto _disk_id = _o->disk_id;
  auto _request_id = _o->request_id;
  auto _user_id = _o->user_id.empty() ? 0 : _fbb.CreateString(_o->user_id);
  auto _root_server_id = _o->root_server_id ? CreateRootServerIdFB(_fbb, _o->root_server_id.get(), _rehasher) : 0;
  auto _required_min_csversion = _o->required_min_csversion;
  auto _fromtype = _o->fromtype;
  auto _offset64 = _o->offset64;
  auto _record_size = _o->record_size;
  auto _pool_id = _o->pool_id;
  auto _storage_pool_confversion = _o->storage_pool_confversion;
  auto _a = _o->a;
  return CreateFlatLogFileFlushChunkRequestFB(
      _fbb,
      _chunk_id,
      _offset,
      _length,
      _storage_id,
      _data,
      _hint,
      _is_replication,
      _trace_open,
      _io_nice,
      _open_chunkoptions,
      _open_mode,
      _handle,
      _data_sync,
      _trace_span,
      _create_ifnotexists,
      _strategy,
      _chunk_id_v2,
      _qos_options,
      _checksum,
      _volume_uuid,
      _module_version,
      _hostname,
      _disk_id,
      _request_id,
      _user_id,
      _root_server_id,
      _required_min_csversion,
      _fromtype,
      _offset64,
      _record_size,
      _pool_id,
      _storage_pool_confversion,
      _a);
}


inline bool operator==(const FlatLogFileFlushChunkResponseFBT &lhs, const FlatLogFileFlushChunkResponseFBT &rhs) {
  return
      (lhs.errorcode == rhs.errorcode) &&
      (lhs.chunk_status == rhs.chunk_status) &&
      (lhs.hint == rhs.hint) &&
      (lhs.ack_length == rhs.ack_length) &&
      (lhs.trace_type == rhs.trace_type) &&
      (lhs.trace_data == rhs.trace_data) &&
      (lhs.handle == rhs.handle) &&
      (lhs.storage_id == rhs.storage_id) &&
      (lhs.disk_id == rhs.disk_id) &&
      (lhs.request_id == rhs.request_id) &&
      (lhs.checksum == rhs.checksum) &&
      (lhs.left_replica_size == rhs.left_replica_size) &&
      (lhs.a == rhs.a);
}

inline bool operator!=(const FlatLogFileFlushChunkResponseFBT &lhs, const FlatLogFileFlushChunkResponseFBT &rhs) {
    return !(lhs == rhs);
}


inline FlatLogFileFlushChunkResponseFBT *FlatLogFileFlushChunkResponseFB::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlatLogFileFlushChunkResponseFBT>(new FlatLogFileFlushChunkResponseFBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlatLogFileFlushChunkResponseFB::UnPackTo(FlatLogFileFlushChunkResponseFBT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = errorcode(); _o->errorcode = _e; }
  { auto _e = chunk_status(); _o->chunk_status = _e; }
  { auto _e = hint(); _o->hint = _e; }
  { auto _e = ack_length(); _o->ack_length = _e; }
  { auto _e = trace_type(); _o->trace_type = _e; }
  { auto _e = trace_data(); if (_e) _o->trace_data = _e->str(); }
  { auto _e = handle(); _o->handle = _e; }
  { auto _e = storage_id(); _o->storage_id = _e; }
  { auto _e = disk_id(); _o->disk_id = _e; }
  { auto _e = request_id(); _o->request_id = _e; }
  { auto _e = checksum(); _o->checksum = _e; }
  { auto _e = left_replica_size(); _o->left_replica_size = _e; }
  { auto _e = a(); _o->a = _e; }
}

inline ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> FlatLogFileFlushChunkResponseFB::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlatLogFileFlushChunkResponseFBT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlatLogFileFlushChunkResponseFB(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlatLogFileFlushChunkResponseFB> CreateFlatLogFileFlushChunkResponseFB(::flatbuffers::FlatBufferBuilder &_fbb, const FlatLogFileFlushChunkResponseFBT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlatLogFileFlushChunkResponseFBT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _errorcode = _o->errorcode;
  auto _chunk_status = _o->chunk_status;
  auto _hint = _o->hint;
  auto _ack_length = _o->ack_length;
  auto _trace_type = _o->trace_type;
  auto _trace_data = _o->trace_data.empty() ? 0 : _fbb.CreateString(_o->trace_data);
  auto _handle = _o->handle;
  auto _storage_id = _o->storage_id;
  auto _disk_id = _o->disk_id;
  auto _request_id = _o->request_id;
  auto _checksum = _o->checksum;
  auto _left_replica_size = _o->left_replica_size;
  auto _a = _o->a;
  return CreateFlatLogFileFlushChunkResponseFB(
      _fbb,
      _errorcode,
      _chunk_status,
      _hint,
      _ack_length,
      _trace_type,
      _trace_data,
      _handle,
      _storage_id,
      _disk_id,
      _request_id,
      _checksum,
      _left_replica_size,
      _a);
}

inline const ::flatbuffers::TypeTable *AdjustTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SHORT, 0, 0 },
    { ::flatbuffers::ET_SHORT, 0, 0 },
    { ::flatbuffers::ET_SHORT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    AdjustTypeTypeTable
  };
  static const int64_t values[] = { -1, 0, 1 };
  static const char * const names[] = {
    "LOWER",
    "KEEP",
    "HIGHER"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CacheGroupTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    CacheGroupTypeTypeTable
  };
  static const int64_t values[] = { 0, 1, 100, 101, 102, 4294967295 };
  static const char * const names[] = {
    "DEFAULT",
    "INTERNAL",
    "USER_BASE",
    "USER_0",
    "USER_1",
    "NO_CACHE"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FixedUUIDInfoFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "low",
    "high"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MirrorArgsFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "copy",
    "ftt"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ChunkOptionsFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    MirrorArgsFBTypeTable
  };
  static const char * const names[] = {
    "ftt_type",
    "mirror",
    "placement"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ReplicaLocationFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "cs_location",
    "disk_location",
    "disk_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AccelerateOpenOptionsFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ChunkOptionsFBTypeTable,
    ReplicaLocationFBTypeTable
  };
  static const char * const names[] = {
    "chunk_options",
    "chunk_location",
    "chunk_sizeexponent",
    "check_sumcategory"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *IONiceFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "priority",
    "io_class"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CsChooseDiskStrategyCJFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    CsChooseDiskStrategySingleCJFBTypeTable
  };
  static const char * const names[] = {
    "strategies",
    "disk_storage_type",
    "target_storage_type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ChunkOrStreamIdInfoFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UUIDInfoFBTypeTable
  };
  static const char * const names[] = {
    "uuid",
    "partition_index",
    "padding"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *QosOptionsFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "service_id",
    "flow_id",
    "adjust",
    "cache_groupid",
    "network_priority"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FlushChecksumFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "category",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *UUIDInfoFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "low",
    "high"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RootServerIdFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    UUIDInfoFBTypeTable
  };
  static const char * const names[] = {
    "uuid",
    "leader_term"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ChunkIdTypeCJFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "belonged_fileid",
    "chunk_index",
    "padding"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PanguTraceSpanInfoFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "trace_id_low",
    "trace_id_high",
    "span_id"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CsChooseDiskStrategySingleCJFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "method",
    "weight",
    "parameter"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FlatLogFileFlushChunkRequestFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 4 },
    { ::flatbuffers::ET_SEQUENCE, 0, 5 },
    { ::flatbuffers::ET_SEQUENCE, 0, 6 },
    { ::flatbuffers::ET_SEQUENCE, 0, 7 },
    { ::flatbuffers::ET_SEQUENCE, 0, 8 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 9 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    ChunkIdTypeCJFBTypeTable,
    IONiceFBTypeTable,
    AccelerateOpenOptionsFBTypeTable,
    PanguTraceSpanInfoFBTypeTable,
    CsChooseDiskStrategyCJFBTypeTable,
    ChunkOrStreamIdInfoFBTypeTable,
    QosOptionsFBTypeTable,
    FlushChecksumFBTypeTable,
    UUIDInfoFBTypeTable,
    RootServerIdFBTypeTable
  };
  static const char * const names[] = {
    "chunk_id",
    "offset",
    "length",
    "storage_id",
    "data",
    "hint",
    "is_replication",
    "trace_open",
    "io_nice",
    "open_chunkoptions",
    "open_mode",
    "handle",
    "data_sync",
    "trace_span",
    "create_ifnotexists",
    "strategy",
    "chunk_id_v2",
    "qos_options",
    "checksum",
    "volume_uuid",
    "module_version",
    "hostname",
    "disk_id",
    "request_id",
    "user_id",
    "root_server_id",
    "required_min_csversion",
    "fromtype",
    "offset64",
    "record_size",
    "pool_id",
    "storage_pool_confversion",
    "a"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 33, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FlatLogFileFlushChunkResponseFBTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "errorcode",
    "chunk_status",
    "hint",
    "ack_length",
    "trace_type",
    "trace_data",
    "handle",
    "storage_id",
    "disk_id",
    "request_id",
    "checksum",
    "left_replica_size",
    "a"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 13, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_FLAT_H_
